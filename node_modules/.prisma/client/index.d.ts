
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model actualite_images
 * 
 */
export type actualite_images = $Result.DefaultSelection<Prisma.$actualite_imagesPayload>
/**
 * Model actualites
 * 
 */
export type actualites = $Result.DefaultSelection<Prisma.$actualitesPayload>
/**
 * Model axes
 * 
 */
export type axes = $Result.DefaultSelection<Prisma.$axesPayload>
/**
 * Model category_user
 * 
 */
export type category_user = $Result.DefaultSelection<Prisma.$category_userPayload>
/**
 * Model commentaires
 * 
 */
export type commentaires = $Result.DefaultSelection<Prisma.$commentairesPayload>
/**
 * Model comptes
 * 
 */
export type comptes = $Result.DefaultSelection<Prisma.$comptesPayload>
/**
 * Model documents
 * 
 */
export type documents = $Result.DefaultSelection<Prisma.$documentsPayload>
/**
 * Model evaluations
 * 
 */
export type evaluations = $Result.DefaultSelection<Prisma.$evaluationsPayload>
/**
 * Model groupes
 * 
 */
export type groupes = $Result.DefaultSelection<Prisma.$groupesPayload>
/**
 * Model indicateurs
 * 
 */
export type indicateurs = $Result.DefaultSelection<Prisma.$indicateursPayload>
/**
 * Model GroupesUtilisateurs
 * 
 */
export type GroupesUtilisateurs = $Result.DefaultSelection<Prisma.$GroupesUtilisateursPayload>
/**
 * Model newsletter
 * 
 */
export type newsletter = $Result.DefaultSelection<Prisma.$newsletterPayload>
/**
 * Model permissions
 * 
 */
export type permissions = $Result.DefaultSelection<Prisma.$permissionsPayload>
/**
 * Model plans_action
 * 
 */
export type plans_action = $Result.DefaultSelection<Prisma.$plans_actionPayload>
/**
 * Model priority
 * 
 */
export type priority = $Result.DefaultSelection<Prisma.$priorityPayload>
/**
 * Model projet_groupes
 * 
 */
export type projet_groupes = $Result.DefaultSelection<Prisma.$projet_groupesPayload>
/**
 * Model projet_utilisateurs
 * 
 */
export type projet_utilisateurs = $Result.DefaultSelection<Prisma.$projet_utilisateursPayload>
/**
 * Model projets
 * 
 */
export type projets = $Result.DefaultSelection<Prisma.$projetsPayload>
/**
 * Model ressources
 * 
 */
export type ressources = $Result.DefaultSelection<Prisma.$ressourcesPayload>
/**
 * Model role_permissions
 * 
 */
export type role_permissions = $Result.DefaultSelection<Prisma.$role_permissionsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model suggestions
 * 
 */
export type suggestions = $Result.DefaultSelection<Prisma.$suggestionsPayload>
/**
 * Model tache_assignations_groupes
 * 
 */
export type tache_assignations_groupes = $Result.DefaultSelection<Prisma.$tache_assignations_groupesPayload>
/**
 * Model tache_assignations_utilisateurs
 * 
 */
export type tache_assignations_utilisateurs = $Result.DefaultSelection<Prisma.$tache_assignations_utilisateursPayload>
/**
 * Model taches
 * 
 */
export type taches = $Result.DefaultSelection<Prisma.$tachesPayload>
/**
 * Model utilisateurs
 * 
 */
export type utilisateurs = $Result.DefaultSelection<Prisma.$utilisateursPayload>
/**
 * Model votes
 * 
 */
export type votes = $Result.DefaultSelection<Prisma.$votesPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const comptes_validity: {
  D: 'D',
  Y: 'Y',
  N: 'N'
};

export type comptes_validity = (typeof comptes_validity)[keyof typeof comptes_validity]

}

export type comptes_validity = $Enums.comptes_validity

export const comptes_validity: typeof $Enums.comptes_validity

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Actualite_images
 * const actualite_images = await prisma.actualite_images.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Actualite_images
   * const actualite_images = await prisma.actualite_images.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.actualite_images`: Exposes CRUD operations for the **actualite_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actualite_images
    * const actualite_images = await prisma.actualite_images.findMany()
    * ```
    */
  get actualite_images(): Prisma.actualite_imagesDelegate<ExtArgs>;

  /**
   * `prisma.actualites`: Exposes CRUD operations for the **actualites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actualites
    * const actualites = await prisma.actualites.findMany()
    * ```
    */
  get actualites(): Prisma.actualitesDelegate<ExtArgs>;

  /**
   * `prisma.axes`: Exposes CRUD operations for the **axes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Axes
    * const axes = await prisma.axes.findMany()
    * ```
    */
  get axes(): Prisma.axesDelegate<ExtArgs>;

  /**
   * `prisma.category_user`: Exposes CRUD operations for the **category_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Category_users
    * const category_users = await prisma.category_user.findMany()
    * ```
    */
  get category_user(): Prisma.category_userDelegate<ExtArgs>;

  /**
   * `prisma.commentaires`: Exposes CRUD operations for the **commentaires** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commentaires
    * const commentaires = await prisma.commentaires.findMany()
    * ```
    */
  get commentaires(): Prisma.commentairesDelegate<ExtArgs>;

  /**
   * `prisma.comptes`: Exposes CRUD operations for the **comptes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comptes
    * const comptes = await prisma.comptes.findMany()
    * ```
    */
  get comptes(): Prisma.comptesDelegate<ExtArgs>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.documentsDelegate<ExtArgs>;

  /**
   * `prisma.evaluations`: Exposes CRUD operations for the **evaluations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluations.findMany()
    * ```
    */
  get evaluations(): Prisma.evaluationsDelegate<ExtArgs>;

  /**
   * `prisma.groupes`: Exposes CRUD operations for the **groupes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groupes
    * const groupes = await prisma.groupes.findMany()
    * ```
    */
  get groupes(): Prisma.groupesDelegate<ExtArgs>;

  /**
   * `prisma.indicateurs`: Exposes CRUD operations for the **indicateurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicateurs
    * const indicateurs = await prisma.indicateurs.findMany()
    * ```
    */
  get indicateurs(): Prisma.indicateursDelegate<ExtArgs>;

  /**
   * `prisma.groupesUtilisateurs`: Exposes CRUD operations for the **GroupesUtilisateurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupesUtilisateurs
    * const groupesUtilisateurs = await prisma.groupesUtilisateurs.findMany()
    * ```
    */
  get groupesUtilisateurs(): Prisma.GroupesUtilisateursDelegate<ExtArgs>;

  /**
   * `prisma.newsletter`: Exposes CRUD operations for the **newsletter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletters
    * const newsletters = await prisma.newsletter.findMany()
    * ```
    */
  get newsletter(): Prisma.newsletterDelegate<ExtArgs>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.permissionsDelegate<ExtArgs>;

  /**
   * `prisma.plans_action`: Exposes CRUD operations for the **plans_action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans_actions
    * const plans_actions = await prisma.plans_action.findMany()
    * ```
    */
  get plans_action(): Prisma.plans_actionDelegate<ExtArgs>;

  /**
   * `prisma.priority`: Exposes CRUD operations for the **priority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Priorities
    * const priorities = await prisma.priority.findMany()
    * ```
    */
  get priority(): Prisma.priorityDelegate<ExtArgs>;

  /**
   * `prisma.projet_groupes`: Exposes CRUD operations for the **projet_groupes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projet_groupes
    * const projet_groupes = await prisma.projet_groupes.findMany()
    * ```
    */
  get projet_groupes(): Prisma.projet_groupesDelegate<ExtArgs>;

  /**
   * `prisma.projet_utilisateurs`: Exposes CRUD operations for the **projet_utilisateurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projet_utilisateurs
    * const projet_utilisateurs = await prisma.projet_utilisateurs.findMany()
    * ```
    */
  get projet_utilisateurs(): Prisma.projet_utilisateursDelegate<ExtArgs>;

  /**
   * `prisma.projets`: Exposes CRUD operations for the **projets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projets
    * const projets = await prisma.projets.findMany()
    * ```
    */
  get projets(): Prisma.projetsDelegate<ExtArgs>;

  /**
   * `prisma.ressources`: Exposes CRUD operations for the **ressources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ressources
    * const ressources = await prisma.ressources.findMany()
    * ```
    */
  get ressources(): Prisma.ressourcesDelegate<ExtArgs>;

  /**
   * `prisma.role_permissions`: Exposes CRUD operations for the **role_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_permissions
    * const role_permissions = await prisma.role_permissions.findMany()
    * ```
    */
  get role_permissions(): Prisma.role_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.suggestions`: Exposes CRUD operations for the **suggestions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suggestions
    * const suggestions = await prisma.suggestions.findMany()
    * ```
    */
  get suggestions(): Prisma.suggestionsDelegate<ExtArgs>;

  /**
   * `prisma.tache_assignations_groupes`: Exposes CRUD operations for the **tache_assignations_groupes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tache_assignations_groupes
    * const tache_assignations_groupes = await prisma.tache_assignations_groupes.findMany()
    * ```
    */
  get tache_assignations_groupes(): Prisma.tache_assignations_groupesDelegate<ExtArgs>;

  /**
   * `prisma.tache_assignations_utilisateurs`: Exposes CRUD operations for the **tache_assignations_utilisateurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tache_assignations_utilisateurs
    * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.findMany()
    * ```
    */
  get tache_assignations_utilisateurs(): Prisma.tache_assignations_utilisateursDelegate<ExtArgs>;

  /**
   * `prisma.taches`: Exposes CRUD operations for the **taches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Taches
    * const taches = await prisma.taches.findMany()
    * ```
    */
  get taches(): Prisma.tachesDelegate<ExtArgs>;

  /**
   * `prisma.utilisateurs`: Exposes CRUD operations for the **utilisateurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateurs.findMany()
    * ```
    */
  get utilisateurs(): Prisma.utilisateursDelegate<ExtArgs>;

  /**
   * `prisma.votes`: Exposes CRUD operations for the **votes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.votes.findMany()
    * ```
    */
  get votes(): Prisma.votesDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    actualite_images: 'actualite_images',
    actualites: 'actualites',
    axes: 'axes',
    category_user: 'category_user',
    commentaires: 'commentaires',
    comptes: 'comptes',
    documents: 'documents',
    evaluations: 'evaluations',
    groupes: 'groupes',
    indicateurs: 'indicateurs',
    GroupesUtilisateurs: 'GroupesUtilisateurs',
    newsletter: 'newsletter',
    permissions: 'permissions',
    plans_action: 'plans_action',
    priority: 'priority',
    projet_groupes: 'projet_groupes',
    projet_utilisateurs: 'projet_utilisateurs',
    projets: 'projets',
    ressources: 'ressources',
    role_permissions: 'role_permissions',
    roles: 'roles',
    suggestions: 'suggestions',
    tache_assignations_groupes: 'tache_assignations_groupes',
    tache_assignations_utilisateurs: 'tache_assignations_utilisateurs',
    taches: 'taches',
    utilisateurs: 'utilisateurs',
    votes: 'votes',
    notifications: 'notifications'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "actualite_images" | "actualites" | "axes" | "category_user" | "commentaires" | "comptes" | "documents" | "evaluations" | "groupes" | "indicateurs" | "groupesUtilisateurs" | "newsletter" | "permissions" | "plans_action" | "priority" | "projet_groupes" | "projet_utilisateurs" | "projets" | "ressources" | "role_permissions" | "roles" | "suggestions" | "tache_assignations_groupes" | "tache_assignations_utilisateurs" | "taches" | "utilisateurs" | "votes" | "notifications"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      actualite_images: {
        payload: Prisma.$actualite_imagesPayload<ExtArgs>
        fields: Prisma.actualite_imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.actualite_imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.actualite_imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload>
          }
          findFirst: {
            args: Prisma.actualite_imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.actualite_imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload>
          }
          findMany: {
            args: Prisma.actualite_imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload>[]
          }
          create: {
            args: Prisma.actualite_imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload>
          }
          createMany: {
            args: Prisma.actualite_imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.actualite_imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload>
          }
          update: {
            args: Prisma.actualite_imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload>
          }
          deleteMany: {
            args: Prisma.actualite_imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.actualite_imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.actualite_imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualite_imagesPayload>
          }
          aggregate: {
            args: Prisma.Actualite_imagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActualite_images>
          }
          groupBy: {
            args: Prisma.actualite_imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Actualite_imagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.actualite_imagesCountArgs<ExtArgs>
            result: $Utils.Optional<Actualite_imagesCountAggregateOutputType> | number
          }
        }
      }
      actualites: {
        payload: Prisma.$actualitesPayload<ExtArgs>
        fields: Prisma.actualitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.actualitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.actualitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload>
          }
          findFirst: {
            args: Prisma.actualitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.actualitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload>
          }
          findMany: {
            args: Prisma.actualitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload>[]
          }
          create: {
            args: Prisma.actualitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload>
          }
          createMany: {
            args: Prisma.actualitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.actualitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload>
          }
          update: {
            args: Prisma.actualitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload>
          }
          deleteMany: {
            args: Prisma.actualitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.actualitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.actualitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actualitesPayload>
          }
          aggregate: {
            args: Prisma.ActualitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActualites>
          }
          groupBy: {
            args: Prisma.actualitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActualitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.actualitesCountArgs<ExtArgs>
            result: $Utils.Optional<ActualitesCountAggregateOutputType> | number
          }
        }
      }
      axes: {
        payload: Prisma.$axesPayload<ExtArgs>
        fields: Prisma.axesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.axesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.axesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload>
          }
          findFirst: {
            args: Prisma.axesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.axesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload>
          }
          findMany: {
            args: Prisma.axesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload>[]
          }
          create: {
            args: Prisma.axesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload>
          }
          createMany: {
            args: Prisma.axesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.axesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload>
          }
          update: {
            args: Prisma.axesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload>
          }
          deleteMany: {
            args: Prisma.axesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.axesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.axesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$axesPayload>
          }
          aggregate: {
            args: Prisma.AxesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAxes>
          }
          groupBy: {
            args: Prisma.axesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AxesGroupByOutputType>[]
          }
          count: {
            args: Prisma.axesCountArgs<ExtArgs>
            result: $Utils.Optional<AxesCountAggregateOutputType> | number
          }
        }
      }
      category_user: {
        payload: Prisma.$category_userPayload<ExtArgs>
        fields: Prisma.category_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.category_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.category_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload>
          }
          findFirst: {
            args: Prisma.category_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.category_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload>
          }
          findMany: {
            args: Prisma.category_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload>[]
          }
          create: {
            args: Prisma.category_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload>
          }
          createMany: {
            args: Prisma.category_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.category_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload>
          }
          update: {
            args: Prisma.category_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload>
          }
          deleteMany: {
            args: Prisma.category_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.category_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.category_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_userPayload>
          }
          aggregate: {
            args: Prisma.Category_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory_user>
          }
          groupBy: {
            args: Prisma.category_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Category_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.category_userCountArgs<ExtArgs>
            result: $Utils.Optional<Category_userCountAggregateOutputType> | number
          }
        }
      }
      commentaires: {
        payload: Prisma.$commentairesPayload<ExtArgs>
        fields: Prisma.commentairesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentairesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentairesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload>
          }
          findFirst: {
            args: Prisma.commentairesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentairesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload>
          }
          findMany: {
            args: Prisma.commentairesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload>[]
          }
          create: {
            args: Prisma.commentairesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload>
          }
          createMany: {
            args: Prisma.commentairesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.commentairesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload>
          }
          update: {
            args: Prisma.commentairesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload>
          }
          deleteMany: {
            args: Prisma.commentairesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentairesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.commentairesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentairesPayload>
          }
          aggregate: {
            args: Prisma.CommentairesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentaires>
          }
          groupBy: {
            args: Prisma.commentairesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentairesGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentairesCountArgs<ExtArgs>
            result: $Utils.Optional<CommentairesCountAggregateOutputType> | number
          }
        }
      }
      comptes: {
        payload: Prisma.$comptesPayload<ExtArgs>
        fields: Prisma.comptesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comptesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comptesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload>
          }
          findFirst: {
            args: Prisma.comptesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comptesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload>
          }
          findMany: {
            args: Prisma.comptesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload>[]
          }
          create: {
            args: Prisma.comptesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload>
          }
          createMany: {
            args: Prisma.comptesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.comptesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload>
          }
          update: {
            args: Prisma.comptesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload>
          }
          deleteMany: {
            args: Prisma.comptesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comptesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.comptesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comptesPayload>
          }
          aggregate: {
            args: Prisma.ComptesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComptes>
          }
          groupBy: {
            args: Prisma.comptesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComptesGroupByOutputType>[]
          }
          count: {
            args: Prisma.comptesCountArgs<ExtArgs>
            result: $Utils.Optional<ComptesCountAggregateOutputType> | number
          }
        }
      }
      documents: {
        payload: Prisma.$documentsPayload<ExtArgs>
        fields: Prisma.documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findFirst: {
            args: Prisma.documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findMany: {
            args: Prisma.documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          create: {
            args: Prisma.documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          createMany: {
            args: Prisma.documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          update: {
            args: Prisma.documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          deleteMany: {
            args: Prisma.documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.documentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      evaluations: {
        payload: Prisma.$evaluationsPayload<ExtArgs>
        fields: Prisma.evaluationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.evaluationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.evaluationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload>
          }
          findFirst: {
            args: Prisma.evaluationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.evaluationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload>
          }
          findMany: {
            args: Prisma.evaluationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload>[]
          }
          create: {
            args: Prisma.evaluationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload>
          }
          createMany: {
            args: Prisma.evaluationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.evaluationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload>
          }
          update: {
            args: Prisma.evaluationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload>
          }
          deleteMany: {
            args: Prisma.evaluationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.evaluationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.evaluationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$evaluationsPayload>
          }
          aggregate: {
            args: Prisma.EvaluationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluations>
          }
          groupBy: {
            args: Prisma.evaluationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.evaluationsCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationsCountAggregateOutputType> | number
          }
        }
      }
      groupes: {
        payload: Prisma.$groupesPayload<ExtArgs>
        fields: Prisma.groupesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload>
          }
          findFirst: {
            args: Prisma.groupesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload>
          }
          findMany: {
            args: Prisma.groupesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload>[]
          }
          create: {
            args: Prisma.groupesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload>
          }
          createMany: {
            args: Prisma.groupesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.groupesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload>
          }
          update: {
            args: Prisma.groupesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload>
          }
          deleteMany: {
            args: Prisma.groupesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.groupesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupesPayload>
          }
          aggregate: {
            args: Prisma.GroupesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupes>
          }
          groupBy: {
            args: Prisma.groupesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupesGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupesCountArgs<ExtArgs>
            result: $Utils.Optional<GroupesCountAggregateOutputType> | number
          }
        }
      }
      indicateurs: {
        payload: Prisma.$indicateursPayload<ExtArgs>
        fields: Prisma.indicateursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.indicateursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.indicateursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload>
          }
          findFirst: {
            args: Prisma.indicateursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.indicateursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload>
          }
          findMany: {
            args: Prisma.indicateursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload>[]
          }
          create: {
            args: Prisma.indicateursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload>
          }
          createMany: {
            args: Prisma.indicateursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.indicateursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload>
          }
          update: {
            args: Prisma.indicateursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload>
          }
          deleteMany: {
            args: Prisma.indicateursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.indicateursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.indicateursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicateursPayload>
          }
          aggregate: {
            args: Prisma.IndicateursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicateurs>
          }
          groupBy: {
            args: Prisma.indicateursGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicateursGroupByOutputType>[]
          }
          count: {
            args: Prisma.indicateursCountArgs<ExtArgs>
            result: $Utils.Optional<IndicateursCountAggregateOutputType> | number
          }
        }
      }
      GroupesUtilisateurs: {
        payload: Prisma.$GroupesUtilisateursPayload<ExtArgs>
        fields: Prisma.GroupesUtilisateursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupesUtilisateursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupesUtilisateursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload>
          }
          findFirst: {
            args: Prisma.GroupesUtilisateursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupesUtilisateursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload>
          }
          findMany: {
            args: Prisma.GroupesUtilisateursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload>[]
          }
          create: {
            args: Prisma.GroupesUtilisateursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload>
          }
          createMany: {
            args: Prisma.GroupesUtilisateursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GroupesUtilisateursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload>
          }
          update: {
            args: Prisma.GroupesUtilisateursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload>
          }
          deleteMany: {
            args: Prisma.GroupesUtilisateursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupesUtilisateursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupesUtilisateursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupesUtilisateursPayload>
          }
          aggregate: {
            args: Prisma.GroupesUtilisateursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupesUtilisateurs>
          }
          groupBy: {
            args: Prisma.GroupesUtilisateursGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupesUtilisateursGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupesUtilisateursCountArgs<ExtArgs>
            result: $Utils.Optional<GroupesUtilisateursCountAggregateOutputType> | number
          }
        }
      }
      newsletter: {
        payload: Prisma.$newsletterPayload<ExtArgs>
        fields: Prisma.newsletterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsletterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsletterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          findFirst: {
            args: Prisma.newsletterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsletterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          findMany: {
            args: Prisma.newsletterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>[]
          }
          create: {
            args: Prisma.newsletterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          createMany: {
            args: Prisma.newsletterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.newsletterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          update: {
            args: Prisma.newsletterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          deleteMany: {
            args: Prisma.newsletterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsletterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsletterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          aggregate: {
            args: Prisma.NewsletterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter>
          }
          groupBy: {
            args: Prisma.newsletterGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsletterCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterCountAggregateOutputType> | number
          }
        }
      }
      permissions: {
        payload: Prisma.$permissionsPayload<ExtArgs>
        fields: Prisma.permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findFirst: {
            args: Prisma.permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findMany: {
            args: Prisma.permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          create: {
            args: Prisma.permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          createMany: {
            args: Prisma.permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          update: {
            args: Prisma.permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          deleteMany: {
            args: Prisma.permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      plans_action: {
        payload: Prisma.$plans_actionPayload<ExtArgs>
        fields: Prisma.plans_actionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plans_actionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plans_actionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload>
          }
          findFirst: {
            args: Prisma.plans_actionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plans_actionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload>
          }
          findMany: {
            args: Prisma.plans_actionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload>[]
          }
          create: {
            args: Prisma.plans_actionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload>
          }
          createMany: {
            args: Prisma.plans_actionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.plans_actionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload>
          }
          update: {
            args: Prisma.plans_actionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload>
          }
          deleteMany: {
            args: Prisma.plans_actionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plans_actionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.plans_actionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plans_actionPayload>
          }
          aggregate: {
            args: Prisma.Plans_actionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlans_action>
          }
          groupBy: {
            args: Prisma.plans_actionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plans_actionGroupByOutputType>[]
          }
          count: {
            args: Prisma.plans_actionCountArgs<ExtArgs>
            result: $Utils.Optional<Plans_actionCountAggregateOutputType> | number
          }
        }
      }
      priority: {
        payload: Prisma.$priorityPayload<ExtArgs>
        fields: Prisma.priorityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.priorityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.priorityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload>
          }
          findFirst: {
            args: Prisma.priorityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.priorityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload>
          }
          findMany: {
            args: Prisma.priorityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload>[]
          }
          create: {
            args: Prisma.priorityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload>
          }
          createMany: {
            args: Prisma.priorityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.priorityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload>
          }
          update: {
            args: Prisma.priorityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload>
          }
          deleteMany: {
            args: Prisma.priorityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.priorityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.priorityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priorityPayload>
          }
          aggregate: {
            args: Prisma.PriorityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriority>
          }
          groupBy: {
            args: Prisma.priorityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriorityGroupByOutputType>[]
          }
          count: {
            args: Prisma.priorityCountArgs<ExtArgs>
            result: $Utils.Optional<PriorityCountAggregateOutputType> | number
          }
        }
      }
      projet_groupes: {
        payload: Prisma.$projet_groupesPayload<ExtArgs>
        fields: Prisma.projet_groupesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projet_groupesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projet_groupesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload>
          }
          findFirst: {
            args: Prisma.projet_groupesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projet_groupesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload>
          }
          findMany: {
            args: Prisma.projet_groupesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload>[]
          }
          create: {
            args: Prisma.projet_groupesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload>
          }
          createMany: {
            args: Prisma.projet_groupesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.projet_groupesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload>
          }
          update: {
            args: Prisma.projet_groupesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload>
          }
          deleteMany: {
            args: Prisma.projet_groupesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projet_groupesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projet_groupesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_groupesPayload>
          }
          aggregate: {
            args: Prisma.Projet_groupesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjet_groupes>
          }
          groupBy: {
            args: Prisma.projet_groupesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Projet_groupesGroupByOutputType>[]
          }
          count: {
            args: Prisma.projet_groupesCountArgs<ExtArgs>
            result: $Utils.Optional<Projet_groupesCountAggregateOutputType> | number
          }
        }
      }
      projet_utilisateurs: {
        payload: Prisma.$projet_utilisateursPayload<ExtArgs>
        fields: Prisma.projet_utilisateursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projet_utilisateursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projet_utilisateursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload>
          }
          findFirst: {
            args: Prisma.projet_utilisateursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projet_utilisateursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload>
          }
          findMany: {
            args: Prisma.projet_utilisateursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload>[]
          }
          create: {
            args: Prisma.projet_utilisateursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload>
          }
          createMany: {
            args: Prisma.projet_utilisateursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.projet_utilisateursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload>
          }
          update: {
            args: Prisma.projet_utilisateursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload>
          }
          deleteMany: {
            args: Prisma.projet_utilisateursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projet_utilisateursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projet_utilisateursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_utilisateursPayload>
          }
          aggregate: {
            args: Prisma.Projet_utilisateursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjet_utilisateurs>
          }
          groupBy: {
            args: Prisma.projet_utilisateursGroupByArgs<ExtArgs>
            result: $Utils.Optional<Projet_utilisateursGroupByOutputType>[]
          }
          count: {
            args: Prisma.projet_utilisateursCountArgs<ExtArgs>
            result: $Utils.Optional<Projet_utilisateursCountAggregateOutputType> | number
          }
        }
      }
      projets: {
        payload: Prisma.$projetsPayload<ExtArgs>
        fields: Prisma.projetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload>
          }
          findFirst: {
            args: Prisma.projetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload>
          }
          findMany: {
            args: Prisma.projetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload>[]
          }
          create: {
            args: Prisma.projetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload>
          }
          createMany: {
            args: Prisma.projetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.projetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload>
          }
          update: {
            args: Prisma.projetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload>
          }
          deleteMany: {
            args: Prisma.projetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetsPayload>
          }
          aggregate: {
            args: Prisma.ProjetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjets>
          }
          groupBy: {
            args: Prisma.projetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.projetsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjetsCountAggregateOutputType> | number
          }
        }
      }
      ressources: {
        payload: Prisma.$ressourcesPayload<ExtArgs>
        fields: Prisma.ressourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ressourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ressourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload>
          }
          findFirst: {
            args: Prisma.ressourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ressourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload>
          }
          findMany: {
            args: Prisma.ressourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload>[]
          }
          create: {
            args: Prisma.ressourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload>
          }
          createMany: {
            args: Prisma.ressourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ressourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload>
          }
          update: {
            args: Prisma.ressourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload>
          }
          deleteMany: {
            args: Prisma.ressourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ressourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ressourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressourcesPayload>
          }
          aggregate: {
            args: Prisma.RessourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRessources>
          }
          groupBy: {
            args: Prisma.ressourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RessourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ressourcesCountArgs<ExtArgs>
            result: $Utils.Optional<RessourcesCountAggregateOutputType> | number
          }
        }
      }
      role_permissions: {
        payload: Prisma.$role_permissionsPayload<ExtArgs>
        fields: Prisma.role_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.role_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.role_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          findFirst: {
            args: Prisma.role_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.role_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          findMany: {
            args: Prisma.role_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
          }
          create: {
            args: Prisma.role_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          createMany: {
            args: Prisma.role_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.role_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          update: {
            args: Prisma.role_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.role_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.role_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.role_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Role_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole_permissions>
          }
          groupBy: {
            args: Prisma.role_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.role_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      suggestions: {
        payload: Prisma.$suggestionsPayload<ExtArgs>
        fields: Prisma.suggestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.suggestionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.suggestionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          findFirst: {
            args: Prisma.suggestionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.suggestionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          findMany: {
            args: Prisma.suggestionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>[]
          }
          create: {
            args: Prisma.suggestionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          createMany: {
            args: Prisma.suggestionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.suggestionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          update: {
            args: Prisma.suggestionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          deleteMany: {
            args: Prisma.suggestionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.suggestionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.suggestionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suggestionsPayload>
          }
          aggregate: {
            args: Prisma.SuggestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestions>
          }
          groupBy: {
            args: Prisma.suggestionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.suggestionsCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestionsCountAggregateOutputType> | number
          }
        }
      }
      tache_assignations_groupes: {
        payload: Prisma.$tache_assignations_groupesPayload<ExtArgs>
        fields: Prisma.tache_assignations_groupesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tache_assignations_groupesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tache_assignations_groupesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload>
          }
          findFirst: {
            args: Prisma.tache_assignations_groupesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tache_assignations_groupesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload>
          }
          findMany: {
            args: Prisma.tache_assignations_groupesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload>[]
          }
          create: {
            args: Prisma.tache_assignations_groupesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload>
          }
          createMany: {
            args: Prisma.tache_assignations_groupesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tache_assignations_groupesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload>
          }
          update: {
            args: Prisma.tache_assignations_groupesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload>
          }
          deleteMany: {
            args: Prisma.tache_assignations_groupesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tache_assignations_groupesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tache_assignations_groupesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_groupesPayload>
          }
          aggregate: {
            args: Prisma.Tache_assignations_groupesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTache_assignations_groupes>
          }
          groupBy: {
            args: Prisma.tache_assignations_groupesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tache_assignations_groupesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tache_assignations_groupesCountArgs<ExtArgs>
            result: $Utils.Optional<Tache_assignations_groupesCountAggregateOutputType> | number
          }
        }
      }
      tache_assignations_utilisateurs: {
        payload: Prisma.$tache_assignations_utilisateursPayload<ExtArgs>
        fields: Prisma.tache_assignations_utilisateursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tache_assignations_utilisateursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tache_assignations_utilisateursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload>
          }
          findFirst: {
            args: Prisma.tache_assignations_utilisateursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tache_assignations_utilisateursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload>
          }
          findMany: {
            args: Prisma.tache_assignations_utilisateursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload>[]
          }
          create: {
            args: Prisma.tache_assignations_utilisateursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload>
          }
          createMany: {
            args: Prisma.tache_assignations_utilisateursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tache_assignations_utilisateursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload>
          }
          update: {
            args: Prisma.tache_assignations_utilisateursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload>
          }
          deleteMany: {
            args: Prisma.tache_assignations_utilisateursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tache_assignations_utilisateursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tache_assignations_utilisateursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tache_assignations_utilisateursPayload>
          }
          aggregate: {
            args: Prisma.Tache_assignations_utilisateursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTache_assignations_utilisateurs>
          }
          groupBy: {
            args: Prisma.tache_assignations_utilisateursGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tache_assignations_utilisateursGroupByOutputType>[]
          }
          count: {
            args: Prisma.tache_assignations_utilisateursCountArgs<ExtArgs>
            result: $Utils.Optional<Tache_assignations_utilisateursCountAggregateOutputType> | number
          }
        }
      }
      taches: {
        payload: Prisma.$tachesPayload<ExtArgs>
        fields: Prisma.tachesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tachesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tachesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload>
          }
          findFirst: {
            args: Prisma.tachesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tachesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload>
          }
          findMany: {
            args: Prisma.tachesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload>[]
          }
          create: {
            args: Prisma.tachesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload>
          }
          createMany: {
            args: Prisma.tachesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tachesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload>
          }
          update: {
            args: Prisma.tachesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload>
          }
          deleteMany: {
            args: Prisma.tachesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tachesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tachesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tachesPayload>
          }
          aggregate: {
            args: Prisma.TachesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaches>
          }
          groupBy: {
            args: Prisma.tachesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TachesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tachesCountArgs<ExtArgs>
            result: $Utils.Optional<TachesCountAggregateOutputType> | number
          }
        }
      }
      utilisateurs: {
        payload: Prisma.$utilisateursPayload<ExtArgs>
        fields: Prisma.utilisateursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.utilisateursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.utilisateursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          findFirst: {
            args: Prisma.utilisateursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.utilisateursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          findMany: {
            args: Prisma.utilisateursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>[]
          }
          create: {
            args: Prisma.utilisateursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          createMany: {
            args: Prisma.utilisateursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.utilisateursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          update: {
            args: Prisma.utilisateursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          deleteMany: {
            args: Prisma.utilisateursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.utilisateursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.utilisateursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utilisateursPayload>
          }
          aggregate: {
            args: Prisma.UtilisateursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtilisateurs>
          }
          groupBy: {
            args: Prisma.utilisateursGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtilisateursGroupByOutputType>[]
          }
          count: {
            args: Prisma.utilisateursCountArgs<ExtArgs>
            result: $Utils.Optional<UtilisateursCountAggregateOutputType> | number
          }
        }
      }
      votes: {
        payload: Prisma.$votesPayload<ExtArgs>
        fields: Prisma.votesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.votesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.votesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          findFirst: {
            args: Prisma.votesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.votesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          findMany: {
            args: Prisma.votesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]
          }
          create: {
            args: Prisma.votesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          createMany: {
            args: Prisma.votesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.votesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          update: {
            args: Prisma.votesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          deleteMany: {
            args: Prisma.votesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.votesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.votesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          aggregate: {
            args: Prisma.VotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVotes>
          }
          groupBy: {
            args: Prisma.votesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.votesCountArgs<ExtArgs>
            result: $Utils.Optional<VotesCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ActualitesCountOutputType
   */

  export type ActualitesCountOutputType = {
    actualite_images: number
  }

  export type ActualitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actualite_images?: boolean | ActualitesCountOutputTypeCountActualite_imagesArgs
  }

  // Custom InputTypes
  /**
   * ActualitesCountOutputType without action
   */
  export type ActualitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActualitesCountOutputType
     */
    select?: ActualitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActualitesCountOutputType without action
   */
  export type ActualitesCountOutputTypeCountActualite_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actualite_imagesWhereInput
  }


  /**
   * Count Type AxesCountOutputType
   */

  export type AxesCountOutputType = {
    projets: number
  }

  export type AxesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | AxesCountOutputTypeCountProjetsArgs
  }

  // Custom InputTypes
  /**
   * AxesCountOutputType without action
   */
  export type AxesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AxesCountOutputType
     */
    select?: AxesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AxesCountOutputType without action
   */
  export type AxesCountOutputTypeCountProjetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetsWhereInput
  }


  /**
   * Count Type Category_userCountOutputType
   */

  export type Category_userCountOutputType = {
    utilisateurs: number
  }

  export type Category_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateurs?: boolean | Category_userCountOutputTypeCountUtilisateursArgs
  }

  // Custom InputTypes
  /**
   * Category_userCountOutputType without action
   */
  export type Category_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category_userCountOutputType
     */
    select?: Category_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Category_userCountOutputType without action
   */
  export type Category_userCountOutputTypeCountUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: utilisateursWhereInput
  }


  /**
   * Count Type ComptesCountOutputType
   */

  export type ComptesCountOutputType = {
    commentaires: number
    suggestions: number
    votes: number
  }

  export type ComptesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commentaires?: boolean | ComptesCountOutputTypeCountCommentairesArgs
    suggestions?: boolean | ComptesCountOutputTypeCountSuggestionsArgs
    votes?: boolean | ComptesCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * ComptesCountOutputType without action
   */
  export type ComptesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComptesCountOutputType
     */
    select?: ComptesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComptesCountOutputType without action
   */
  export type ComptesCountOutputTypeCountCommentairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentairesWhereInput
  }

  /**
   * ComptesCountOutputType without action
   */
  export type ComptesCountOutputTypeCountSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suggestionsWhereInput
  }

  /**
   * ComptesCountOutputType without action
   */
  export type ComptesCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: votesWhereInput
  }


  /**
   * Count Type GroupesCountOutputType
   */

  export type GroupesCountOutputType = {
    projet_groupes: number
    tache_assignations_groupes: number
    groupesUtilisateurs: number
    Notification: number
  }

  export type GroupesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet_groupes?: boolean | GroupesCountOutputTypeCountProjet_groupesArgs
    tache_assignations_groupes?: boolean | GroupesCountOutputTypeCountTache_assignations_groupesArgs
    groupesUtilisateurs?: boolean | GroupesCountOutputTypeCountGroupesUtilisateursArgs
    Notification?: boolean | GroupesCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * GroupesCountOutputType without action
   */
  export type GroupesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesCountOutputType
     */
    select?: GroupesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupesCountOutputType without action
   */
  export type GroupesCountOutputTypeCountProjet_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_groupesWhereInput
  }

  /**
   * GroupesCountOutputType without action
   */
  export type GroupesCountOutputTypeCountTache_assignations_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tache_assignations_groupesWhereInput
  }

  /**
   * GroupesCountOutputType without action
   */
  export type GroupesCountOutputTypeCountGroupesUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupesUtilisateursWhereInput
  }

  /**
   * GroupesCountOutputType without action
   */
  export type GroupesCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }


  /**
   * Count Type IndicateursCountOutputType
   */

  export type IndicateursCountOutputType = {
    evaluations: number
  }

  export type IndicateursCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | IndicateursCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * IndicateursCountOutputType without action
   */
  export type IndicateursCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateursCountOutputType
     */
    select?: IndicateursCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicateursCountOutputType without action
   */
  export type IndicateursCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evaluationsWhereInput
  }


  /**
   * Count Type PermissionsCountOutputType
   */

  export type PermissionsCountOutputType = {
    role_permissions: number
  }

  export type PermissionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role_permissions?: boolean | PermissionsCountOutputTypeCountRole_permissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionsCountOutputType
     */
    select?: PermissionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountRole_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
  }


  /**
   * Count Type Plans_actionCountOutputType
   */

  export type Plans_actionCountOutputType = {
    axes: number
  }

  export type Plans_actionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    axes?: boolean | Plans_actionCountOutputTypeCountAxesArgs
  }

  // Custom InputTypes
  /**
   * Plans_actionCountOutputType without action
   */
  export type Plans_actionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plans_actionCountOutputType
     */
    select?: Plans_actionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Plans_actionCountOutputType without action
   */
  export type Plans_actionCountOutputTypeCountAxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: axesWhereInput
  }


  /**
   * Count Type PriorityCountOutputType
   */

  export type PriorityCountOutputType = {
    projets: number
  }

  export type PriorityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | PriorityCountOutputTypeCountProjetsArgs
  }

  // Custom InputTypes
  /**
   * PriorityCountOutputType without action
   */
  export type PriorityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityCountOutputType
     */
    select?: PriorityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PriorityCountOutputType without action
   */
  export type PriorityCountOutputTypeCountProjetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetsWhereInput
  }


  /**
   * Count Type ProjetsCountOutputType
   */

  export type ProjetsCountOutputType = {
    commentaires: number
    documents: number
    indicateurs: number
    projet_groupes: number
    projet_utilisateurs: number
    ressources: number
    suggestions: number
    taches: number
  }

  export type ProjetsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commentaires?: boolean | ProjetsCountOutputTypeCountCommentairesArgs
    documents?: boolean | ProjetsCountOutputTypeCountDocumentsArgs
    indicateurs?: boolean | ProjetsCountOutputTypeCountIndicateursArgs
    projet_groupes?: boolean | ProjetsCountOutputTypeCountProjet_groupesArgs
    projet_utilisateurs?: boolean | ProjetsCountOutputTypeCountProjet_utilisateursArgs
    ressources?: boolean | ProjetsCountOutputTypeCountRessourcesArgs
    suggestions?: boolean | ProjetsCountOutputTypeCountSuggestionsArgs
    taches?: boolean | ProjetsCountOutputTypeCountTachesArgs
  }

  // Custom InputTypes
  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjetsCountOutputType
     */
    select?: ProjetsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountCommentairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentairesWhereInput
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountIndicateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: indicateursWhereInput
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountProjet_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_groupesWhereInput
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountProjet_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_utilisateursWhereInput
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountRessourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ressourcesWhereInput
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suggestionsWhereInput
  }

  /**
   * ProjetsCountOutputType without action
   */
  export type ProjetsCountOutputTypeCountTachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tachesWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    comptes: number
    role_permissions: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comptes?: boolean | RolesCountOutputTypeCountComptesArgs
    role_permissions?: boolean | RolesCountOutputTypeCountRole_permissionsArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountComptesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comptesWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRole_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
  }


  /**
   * Count Type TachesCountOutputType
   */

  export type TachesCountOutputType = {
    tache_assignations_groupes: number
    tache_assignations_utilisateurs: number
  }

  export type TachesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tache_assignations_groupes?: boolean | TachesCountOutputTypeCountTache_assignations_groupesArgs
    tache_assignations_utilisateurs?: boolean | TachesCountOutputTypeCountTache_assignations_utilisateursArgs
  }

  // Custom InputTypes
  /**
   * TachesCountOutputType without action
   */
  export type TachesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TachesCountOutputType
     */
    select?: TachesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TachesCountOutputType without action
   */
  export type TachesCountOutputTypeCountTache_assignations_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tache_assignations_groupesWhereInput
  }

  /**
   * TachesCountOutputType without action
   */
  export type TachesCountOutputTypeCountTache_assignations_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tache_assignations_utilisateursWhereInput
  }


  /**
   * Count Type UtilisateursCountOutputType
   */

  export type UtilisateursCountOutputType = {
    comptes: number
    projet_utilisateurs: number
    projets: number
    tache_assignations_utilisateurs: number
    taches: number
    groupesUtilisateurs: number
    Notification: number
  }

  export type UtilisateursCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comptes?: boolean | UtilisateursCountOutputTypeCountComptesArgs
    projet_utilisateurs?: boolean | UtilisateursCountOutputTypeCountProjet_utilisateursArgs
    projets?: boolean | UtilisateursCountOutputTypeCountProjetsArgs
    tache_assignations_utilisateurs?: boolean | UtilisateursCountOutputTypeCountTache_assignations_utilisateursArgs
    taches?: boolean | UtilisateursCountOutputTypeCountTachesArgs
    groupesUtilisateurs?: boolean | UtilisateursCountOutputTypeCountGroupesUtilisateursArgs
    Notification?: boolean | UtilisateursCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilisateursCountOutputType
     */
    select?: UtilisateursCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeCountComptesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comptesWhereInput
  }

  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeCountProjet_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_utilisateursWhereInput
  }

  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeCountProjetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetsWhereInput
  }

  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeCountTache_assignations_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tache_assignations_utilisateursWhereInput
  }

  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeCountTachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tachesWhereInput
  }

  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeCountGroupesUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupesUtilisateursWhereInput
  }

  /**
   * UtilisateursCountOutputType without action
   */
  export type UtilisateursCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model actualite_images
   */

  export type AggregateActualite_images = {
    _count: Actualite_imagesCountAggregateOutputType | null
    _avg: Actualite_imagesAvgAggregateOutputType | null
    _sum: Actualite_imagesSumAggregateOutputType | null
    _min: Actualite_imagesMinAggregateOutputType | null
    _max: Actualite_imagesMaxAggregateOutputType | null
  }

  export type Actualite_imagesAvgAggregateOutputType = {
    id: number | null
    actualite_id: number | null
  }

  export type Actualite_imagesSumAggregateOutputType = {
    id: number | null
    actualite_id: number | null
  }

  export type Actualite_imagesMinAggregateOutputType = {
    id: number | null
    actualite_id: number | null
    image_url: string | null
  }

  export type Actualite_imagesMaxAggregateOutputType = {
    id: number | null
    actualite_id: number | null
    image_url: string | null
  }

  export type Actualite_imagesCountAggregateOutputType = {
    id: number
    actualite_id: number
    image_url: number
    _all: number
  }


  export type Actualite_imagesAvgAggregateInputType = {
    id?: true
    actualite_id?: true
  }

  export type Actualite_imagesSumAggregateInputType = {
    id?: true
    actualite_id?: true
  }

  export type Actualite_imagesMinAggregateInputType = {
    id?: true
    actualite_id?: true
    image_url?: true
  }

  export type Actualite_imagesMaxAggregateInputType = {
    id?: true
    actualite_id?: true
    image_url?: true
  }

  export type Actualite_imagesCountAggregateInputType = {
    id?: true
    actualite_id?: true
    image_url?: true
    _all?: true
  }

  export type Actualite_imagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actualite_images to aggregate.
     */
    where?: actualite_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualite_images to fetch.
     */
    orderBy?: actualite_imagesOrderByWithRelationInput | actualite_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: actualite_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualite_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualite_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned actualite_images
    **/
    _count?: true | Actualite_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Actualite_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Actualite_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Actualite_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Actualite_imagesMaxAggregateInputType
  }

  export type GetActualite_imagesAggregateType<T extends Actualite_imagesAggregateArgs> = {
        [P in keyof T & keyof AggregateActualite_images]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActualite_images[P]>
      : GetScalarType<T[P], AggregateActualite_images[P]>
  }




  export type actualite_imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actualite_imagesWhereInput
    orderBy?: actualite_imagesOrderByWithAggregationInput | actualite_imagesOrderByWithAggregationInput[]
    by: Actualite_imagesScalarFieldEnum[] | Actualite_imagesScalarFieldEnum
    having?: actualite_imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Actualite_imagesCountAggregateInputType | true
    _avg?: Actualite_imagesAvgAggregateInputType
    _sum?: Actualite_imagesSumAggregateInputType
    _min?: Actualite_imagesMinAggregateInputType
    _max?: Actualite_imagesMaxAggregateInputType
  }

  export type Actualite_imagesGroupByOutputType = {
    id: number
    actualite_id: number
    image_url: string
    _count: Actualite_imagesCountAggregateOutputType | null
    _avg: Actualite_imagesAvgAggregateOutputType | null
    _sum: Actualite_imagesSumAggregateOutputType | null
    _min: Actualite_imagesMinAggregateOutputType | null
    _max: Actualite_imagesMaxAggregateOutputType | null
  }

  type GetActualite_imagesGroupByPayload<T extends actualite_imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Actualite_imagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Actualite_imagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Actualite_imagesGroupByOutputType[P]>
            : GetScalarType<T[P], Actualite_imagesGroupByOutputType[P]>
        }
      >
    >


  export type actualite_imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actualite_id?: boolean
    image_url?: boolean
    actualites?: boolean | actualitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actualite_images"]>


  export type actualite_imagesSelectScalar = {
    id?: boolean
    actualite_id?: boolean
    image_url?: boolean
  }

  export type actualite_imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actualites?: boolean | actualitesDefaultArgs<ExtArgs>
  }

  export type $actualite_imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "actualite_images"
    objects: {
      actualites: Prisma.$actualitesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actualite_id: number
      image_url: string
    }, ExtArgs["result"]["actualite_images"]>
    composites: {}
  }

  type actualite_imagesGetPayload<S extends boolean | null | undefined | actualite_imagesDefaultArgs> = $Result.GetResult<Prisma.$actualite_imagesPayload, S>

  type actualite_imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<actualite_imagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Actualite_imagesCountAggregateInputType | true
    }

  export interface actualite_imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['actualite_images'], meta: { name: 'actualite_images' } }
    /**
     * Find zero or one Actualite_images that matches the filter.
     * @param {actualite_imagesFindUniqueArgs} args - Arguments to find a Actualite_images
     * @example
     * // Get one Actualite_images
     * const actualite_images = await prisma.actualite_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends actualite_imagesFindUniqueArgs>(args: SelectSubset<T, actualite_imagesFindUniqueArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Actualite_images that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {actualite_imagesFindUniqueOrThrowArgs} args - Arguments to find a Actualite_images
     * @example
     * // Get one Actualite_images
     * const actualite_images = await prisma.actualite_images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends actualite_imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, actualite_imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Actualite_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualite_imagesFindFirstArgs} args - Arguments to find a Actualite_images
     * @example
     * // Get one Actualite_images
     * const actualite_images = await prisma.actualite_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends actualite_imagesFindFirstArgs>(args?: SelectSubset<T, actualite_imagesFindFirstArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Actualite_images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualite_imagesFindFirstOrThrowArgs} args - Arguments to find a Actualite_images
     * @example
     * // Get one Actualite_images
     * const actualite_images = await prisma.actualite_images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends actualite_imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, actualite_imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Actualite_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualite_imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actualite_images
     * const actualite_images = await prisma.actualite_images.findMany()
     * 
     * // Get first 10 Actualite_images
     * const actualite_images = await prisma.actualite_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actualite_imagesWithIdOnly = await prisma.actualite_images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends actualite_imagesFindManyArgs>(args?: SelectSubset<T, actualite_imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Actualite_images.
     * @param {actualite_imagesCreateArgs} args - Arguments to create a Actualite_images.
     * @example
     * // Create one Actualite_images
     * const Actualite_images = await prisma.actualite_images.create({
     *   data: {
     *     // ... data to create a Actualite_images
     *   }
     * })
     * 
     */
    create<T extends actualite_imagesCreateArgs>(args: SelectSubset<T, actualite_imagesCreateArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Actualite_images.
     * @param {actualite_imagesCreateManyArgs} args - Arguments to create many Actualite_images.
     * @example
     * // Create many Actualite_images
     * const actualite_images = await prisma.actualite_images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends actualite_imagesCreateManyArgs>(args?: SelectSubset<T, actualite_imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actualite_images.
     * @param {actualite_imagesDeleteArgs} args - Arguments to delete one Actualite_images.
     * @example
     * // Delete one Actualite_images
     * const Actualite_images = await prisma.actualite_images.delete({
     *   where: {
     *     // ... filter to delete one Actualite_images
     *   }
     * })
     * 
     */
    delete<T extends actualite_imagesDeleteArgs>(args: SelectSubset<T, actualite_imagesDeleteArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Actualite_images.
     * @param {actualite_imagesUpdateArgs} args - Arguments to update one Actualite_images.
     * @example
     * // Update one Actualite_images
     * const actualite_images = await prisma.actualite_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends actualite_imagesUpdateArgs>(args: SelectSubset<T, actualite_imagesUpdateArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Actualite_images.
     * @param {actualite_imagesDeleteManyArgs} args - Arguments to filter Actualite_images to delete.
     * @example
     * // Delete a few Actualite_images
     * const { count } = await prisma.actualite_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends actualite_imagesDeleteManyArgs>(args?: SelectSubset<T, actualite_imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actualite_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualite_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actualite_images
     * const actualite_images = await prisma.actualite_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends actualite_imagesUpdateManyArgs>(args: SelectSubset<T, actualite_imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actualite_images.
     * @param {actualite_imagesUpsertArgs} args - Arguments to update or create a Actualite_images.
     * @example
     * // Update or create a Actualite_images
     * const actualite_images = await prisma.actualite_images.upsert({
     *   create: {
     *     // ... data to create a Actualite_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actualite_images we want to update
     *   }
     * })
     */
    upsert<T extends actualite_imagesUpsertArgs>(args: SelectSubset<T, actualite_imagesUpsertArgs<ExtArgs>>): Prisma__actualite_imagesClient<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Actualite_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualite_imagesCountArgs} args - Arguments to filter Actualite_images to count.
     * @example
     * // Count the number of Actualite_images
     * const count = await prisma.actualite_images.count({
     *   where: {
     *     // ... the filter for the Actualite_images we want to count
     *   }
     * })
    **/
    count<T extends actualite_imagesCountArgs>(
      args?: Subset<T, actualite_imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Actualite_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actualite_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Actualite_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Actualite_imagesAggregateArgs>(args: Subset<T, Actualite_imagesAggregateArgs>): Prisma.PrismaPromise<GetActualite_imagesAggregateType<T>>

    /**
     * Group by Actualite_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualite_imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends actualite_imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: actualite_imagesGroupByArgs['orderBy'] }
        : { orderBy?: actualite_imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, actualite_imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActualite_imagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the actualite_images model
   */
  readonly fields: actualite_imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for actualite_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__actualite_imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actualites<T extends actualitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, actualitesDefaultArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the actualite_images model
   */ 
  interface actualite_imagesFieldRefs {
    readonly id: FieldRef<"actualite_images", 'Int'>
    readonly actualite_id: FieldRef<"actualite_images", 'Int'>
    readonly image_url: FieldRef<"actualite_images", 'String'>
  }
    

  // Custom InputTypes
  /**
   * actualite_images findUnique
   */
  export type actualite_imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * Filter, which actualite_images to fetch.
     */
    where: actualite_imagesWhereUniqueInput
  }

  /**
   * actualite_images findUniqueOrThrow
   */
  export type actualite_imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * Filter, which actualite_images to fetch.
     */
    where: actualite_imagesWhereUniqueInput
  }

  /**
   * actualite_images findFirst
   */
  export type actualite_imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * Filter, which actualite_images to fetch.
     */
    where?: actualite_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualite_images to fetch.
     */
    orderBy?: actualite_imagesOrderByWithRelationInput | actualite_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actualite_images.
     */
    cursor?: actualite_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualite_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualite_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actualite_images.
     */
    distinct?: Actualite_imagesScalarFieldEnum | Actualite_imagesScalarFieldEnum[]
  }

  /**
   * actualite_images findFirstOrThrow
   */
  export type actualite_imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * Filter, which actualite_images to fetch.
     */
    where?: actualite_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualite_images to fetch.
     */
    orderBy?: actualite_imagesOrderByWithRelationInput | actualite_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actualite_images.
     */
    cursor?: actualite_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualite_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualite_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actualite_images.
     */
    distinct?: Actualite_imagesScalarFieldEnum | Actualite_imagesScalarFieldEnum[]
  }

  /**
   * actualite_images findMany
   */
  export type actualite_imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * Filter, which actualite_images to fetch.
     */
    where?: actualite_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualite_images to fetch.
     */
    orderBy?: actualite_imagesOrderByWithRelationInput | actualite_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing actualite_images.
     */
    cursor?: actualite_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualite_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualite_images.
     */
    skip?: number
    distinct?: Actualite_imagesScalarFieldEnum | Actualite_imagesScalarFieldEnum[]
  }

  /**
   * actualite_images create
   */
  export type actualite_imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a actualite_images.
     */
    data: XOR<actualite_imagesCreateInput, actualite_imagesUncheckedCreateInput>
  }

  /**
   * actualite_images createMany
   */
  export type actualite_imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many actualite_images.
     */
    data: actualite_imagesCreateManyInput | actualite_imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * actualite_images update
   */
  export type actualite_imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a actualite_images.
     */
    data: XOR<actualite_imagesUpdateInput, actualite_imagesUncheckedUpdateInput>
    /**
     * Choose, which actualite_images to update.
     */
    where: actualite_imagesWhereUniqueInput
  }

  /**
   * actualite_images updateMany
   */
  export type actualite_imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update actualite_images.
     */
    data: XOR<actualite_imagesUpdateManyMutationInput, actualite_imagesUncheckedUpdateManyInput>
    /**
     * Filter which actualite_images to update
     */
    where?: actualite_imagesWhereInput
  }

  /**
   * actualite_images upsert
   */
  export type actualite_imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the actualite_images to update in case it exists.
     */
    where: actualite_imagesWhereUniqueInput
    /**
     * In case the actualite_images found by the `where` argument doesn't exist, create a new actualite_images with this data.
     */
    create: XOR<actualite_imagesCreateInput, actualite_imagesUncheckedCreateInput>
    /**
     * In case the actualite_images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<actualite_imagesUpdateInput, actualite_imagesUncheckedUpdateInput>
  }

  /**
   * actualite_images delete
   */
  export type actualite_imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    /**
     * Filter which actualite_images to delete.
     */
    where: actualite_imagesWhereUniqueInput
  }

  /**
   * actualite_images deleteMany
   */
  export type actualite_imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actualite_images to delete
     */
    where?: actualite_imagesWhereInput
  }

  /**
   * actualite_images without action
   */
  export type actualite_imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
  }


  /**
   * Model actualites
   */

  export type AggregateActualites = {
    _count: ActualitesCountAggregateOutputType | null
    _avg: ActualitesAvgAggregateOutputType | null
    _sum: ActualitesSumAggregateOutputType | null
    _min: ActualitesMinAggregateOutputType | null
    _max: ActualitesMaxAggregateOutputType | null
  }

  export type ActualitesAvgAggregateOutputType = {
    id: number | null
  }

  export type ActualitesSumAggregateOutputType = {
    id: number | null
  }

  export type ActualitesMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type ActualitesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type ActualitesCountAggregateOutputType = {
    id: number
    title: number
    content: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type ActualitesAvgAggregateInputType = {
    id?: true
  }

  export type ActualitesSumAggregateInputType = {
    id?: true
  }

  export type ActualitesMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_date?: true
    last_updated?: true
  }

  export type ActualitesMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_date?: true
    last_updated?: true
  }

  export type ActualitesCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type ActualitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actualites to aggregate.
     */
    where?: actualitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualites to fetch.
     */
    orderBy?: actualitesOrderByWithRelationInput | actualitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: actualitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned actualites
    **/
    _count?: true | ActualitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActualitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActualitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActualitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActualitesMaxAggregateInputType
  }

  export type GetActualitesAggregateType<T extends ActualitesAggregateArgs> = {
        [P in keyof T & keyof AggregateActualites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActualites[P]>
      : GetScalarType<T[P], AggregateActualites[P]>
  }




  export type actualitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actualitesWhereInput
    orderBy?: actualitesOrderByWithAggregationInput | actualitesOrderByWithAggregationInput[]
    by: ActualitesScalarFieldEnum[] | ActualitesScalarFieldEnum
    having?: actualitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActualitesCountAggregateInputType | true
    _avg?: ActualitesAvgAggregateInputType
    _sum?: ActualitesSumAggregateInputType
    _min?: ActualitesMinAggregateInputType
    _max?: ActualitesMaxAggregateInputType
  }

  export type ActualitesGroupByOutputType = {
    id: number
    title: string
    content: string
    created_date: Date
    last_updated: Date
    _count: ActualitesCountAggregateOutputType | null
    _avg: ActualitesAvgAggregateOutputType | null
    _sum: ActualitesSumAggregateOutputType | null
    _min: ActualitesMinAggregateOutputType | null
    _max: ActualitesMaxAggregateOutputType | null
  }

  type GetActualitesGroupByPayload<T extends actualitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActualitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActualitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActualitesGroupByOutputType[P]>
            : GetScalarType<T[P], ActualitesGroupByOutputType[P]>
        }
      >
    >


  export type actualitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_date?: boolean
    last_updated?: boolean
    actualite_images?: boolean | actualites$actualite_imagesArgs<ExtArgs>
    _count?: boolean | ActualitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actualites"]>


  export type actualitesSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type actualitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actualite_images?: boolean | actualites$actualite_imagesArgs<ExtArgs>
    _count?: boolean | ActualitesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $actualitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "actualites"
    objects: {
      actualite_images: Prisma.$actualite_imagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["actualites"]>
    composites: {}
  }

  type actualitesGetPayload<S extends boolean | null | undefined | actualitesDefaultArgs> = $Result.GetResult<Prisma.$actualitesPayload, S>

  type actualitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<actualitesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActualitesCountAggregateInputType | true
    }

  export interface actualitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['actualites'], meta: { name: 'actualites' } }
    /**
     * Find zero or one Actualites that matches the filter.
     * @param {actualitesFindUniqueArgs} args - Arguments to find a Actualites
     * @example
     * // Get one Actualites
     * const actualites = await prisma.actualites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends actualitesFindUniqueArgs>(args: SelectSubset<T, actualitesFindUniqueArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Actualites that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {actualitesFindUniqueOrThrowArgs} args - Arguments to find a Actualites
     * @example
     * // Get one Actualites
     * const actualites = await prisma.actualites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends actualitesFindUniqueOrThrowArgs>(args: SelectSubset<T, actualitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Actualites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualitesFindFirstArgs} args - Arguments to find a Actualites
     * @example
     * // Get one Actualites
     * const actualites = await prisma.actualites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends actualitesFindFirstArgs>(args?: SelectSubset<T, actualitesFindFirstArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Actualites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualitesFindFirstOrThrowArgs} args - Arguments to find a Actualites
     * @example
     * // Get one Actualites
     * const actualites = await prisma.actualites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends actualitesFindFirstOrThrowArgs>(args?: SelectSubset<T, actualitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Actualites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actualites
     * const actualites = await prisma.actualites.findMany()
     * 
     * // Get first 10 Actualites
     * const actualites = await prisma.actualites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actualitesWithIdOnly = await prisma.actualites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends actualitesFindManyArgs>(args?: SelectSubset<T, actualitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Actualites.
     * @param {actualitesCreateArgs} args - Arguments to create a Actualites.
     * @example
     * // Create one Actualites
     * const Actualites = await prisma.actualites.create({
     *   data: {
     *     // ... data to create a Actualites
     *   }
     * })
     * 
     */
    create<T extends actualitesCreateArgs>(args: SelectSubset<T, actualitesCreateArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Actualites.
     * @param {actualitesCreateManyArgs} args - Arguments to create many Actualites.
     * @example
     * // Create many Actualites
     * const actualites = await prisma.actualites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends actualitesCreateManyArgs>(args?: SelectSubset<T, actualitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actualites.
     * @param {actualitesDeleteArgs} args - Arguments to delete one Actualites.
     * @example
     * // Delete one Actualites
     * const Actualites = await prisma.actualites.delete({
     *   where: {
     *     // ... filter to delete one Actualites
     *   }
     * })
     * 
     */
    delete<T extends actualitesDeleteArgs>(args: SelectSubset<T, actualitesDeleteArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Actualites.
     * @param {actualitesUpdateArgs} args - Arguments to update one Actualites.
     * @example
     * // Update one Actualites
     * const actualites = await prisma.actualites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends actualitesUpdateArgs>(args: SelectSubset<T, actualitesUpdateArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Actualites.
     * @param {actualitesDeleteManyArgs} args - Arguments to filter Actualites to delete.
     * @example
     * // Delete a few Actualites
     * const { count } = await prisma.actualites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends actualitesDeleteManyArgs>(args?: SelectSubset<T, actualitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actualites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actualites
     * const actualites = await prisma.actualites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends actualitesUpdateManyArgs>(args: SelectSubset<T, actualitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actualites.
     * @param {actualitesUpsertArgs} args - Arguments to update or create a Actualites.
     * @example
     * // Update or create a Actualites
     * const actualites = await prisma.actualites.upsert({
     *   create: {
     *     // ... data to create a Actualites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actualites we want to update
     *   }
     * })
     */
    upsert<T extends actualitesUpsertArgs>(args: SelectSubset<T, actualitesUpsertArgs<ExtArgs>>): Prisma__actualitesClient<$Result.GetResult<Prisma.$actualitesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Actualites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualitesCountArgs} args - Arguments to filter Actualites to count.
     * @example
     * // Count the number of Actualites
     * const count = await prisma.actualites.count({
     *   where: {
     *     // ... the filter for the Actualites we want to count
     *   }
     * })
    **/
    count<T extends actualitesCountArgs>(
      args?: Subset<T, actualitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActualitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actualites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActualitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActualitesAggregateArgs>(args: Subset<T, ActualitesAggregateArgs>): Prisma.PrismaPromise<GetActualitesAggregateType<T>>

    /**
     * Group by Actualites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actualitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends actualitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: actualitesGroupByArgs['orderBy'] }
        : { orderBy?: actualitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, actualitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActualitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the actualites model
   */
  readonly fields: actualitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for actualites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__actualitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actualite_images<T extends actualites$actualite_imagesArgs<ExtArgs> = {}>(args?: Subset<T, actualites$actualite_imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actualite_imagesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the actualites model
   */ 
  interface actualitesFieldRefs {
    readonly id: FieldRef<"actualites", 'Int'>
    readonly title: FieldRef<"actualites", 'String'>
    readonly content: FieldRef<"actualites", 'String'>
    readonly created_date: FieldRef<"actualites", 'DateTime'>
    readonly last_updated: FieldRef<"actualites", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * actualites findUnique
   */
  export type actualitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * Filter, which actualites to fetch.
     */
    where: actualitesWhereUniqueInput
  }

  /**
   * actualites findUniqueOrThrow
   */
  export type actualitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * Filter, which actualites to fetch.
     */
    where: actualitesWhereUniqueInput
  }

  /**
   * actualites findFirst
   */
  export type actualitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * Filter, which actualites to fetch.
     */
    where?: actualitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualites to fetch.
     */
    orderBy?: actualitesOrderByWithRelationInput | actualitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actualites.
     */
    cursor?: actualitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actualites.
     */
    distinct?: ActualitesScalarFieldEnum | ActualitesScalarFieldEnum[]
  }

  /**
   * actualites findFirstOrThrow
   */
  export type actualitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * Filter, which actualites to fetch.
     */
    where?: actualitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualites to fetch.
     */
    orderBy?: actualitesOrderByWithRelationInput | actualitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actualites.
     */
    cursor?: actualitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actualites.
     */
    distinct?: ActualitesScalarFieldEnum | ActualitesScalarFieldEnum[]
  }

  /**
   * actualites findMany
   */
  export type actualitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * Filter, which actualites to fetch.
     */
    where?: actualitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actualites to fetch.
     */
    orderBy?: actualitesOrderByWithRelationInput | actualitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing actualites.
     */
    cursor?: actualitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actualites.
     */
    skip?: number
    distinct?: ActualitesScalarFieldEnum | ActualitesScalarFieldEnum[]
  }

  /**
   * actualites create
   */
  export type actualitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * The data needed to create a actualites.
     */
    data: XOR<actualitesCreateInput, actualitesUncheckedCreateInput>
  }

  /**
   * actualites createMany
   */
  export type actualitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many actualites.
     */
    data: actualitesCreateManyInput | actualitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * actualites update
   */
  export type actualitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * The data needed to update a actualites.
     */
    data: XOR<actualitesUpdateInput, actualitesUncheckedUpdateInput>
    /**
     * Choose, which actualites to update.
     */
    where: actualitesWhereUniqueInput
  }

  /**
   * actualites updateMany
   */
  export type actualitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update actualites.
     */
    data: XOR<actualitesUpdateManyMutationInput, actualitesUncheckedUpdateManyInput>
    /**
     * Filter which actualites to update
     */
    where?: actualitesWhereInput
  }

  /**
   * actualites upsert
   */
  export type actualitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * The filter to search for the actualites to update in case it exists.
     */
    where: actualitesWhereUniqueInput
    /**
     * In case the actualites found by the `where` argument doesn't exist, create a new actualites with this data.
     */
    create: XOR<actualitesCreateInput, actualitesUncheckedCreateInput>
    /**
     * In case the actualites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<actualitesUpdateInput, actualitesUncheckedUpdateInput>
  }

  /**
   * actualites delete
   */
  export type actualitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
    /**
     * Filter which actualites to delete.
     */
    where: actualitesWhereUniqueInput
  }

  /**
   * actualites deleteMany
   */
  export type actualitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actualites to delete
     */
    where?: actualitesWhereInput
  }

  /**
   * actualites.actualite_images
   */
  export type actualites$actualite_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualite_images
     */
    select?: actualite_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualite_imagesInclude<ExtArgs> | null
    where?: actualite_imagesWhereInput
    orderBy?: actualite_imagesOrderByWithRelationInput | actualite_imagesOrderByWithRelationInput[]
    cursor?: actualite_imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Actualite_imagesScalarFieldEnum | Actualite_imagesScalarFieldEnum[]
  }

  /**
   * actualites without action
   */
  export type actualitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actualites
     */
    select?: actualitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: actualitesInclude<ExtArgs> | null
  }


  /**
   * Model axes
   */

  export type AggregateAxes = {
    _count: AxesCountAggregateOutputType | null
    _avg: AxesAvgAggregateOutputType | null
    _sum: AxesSumAggregateOutputType | null
    _min: AxesMinAggregateOutputType | null
    _max: AxesMaxAggregateOutputType | null
  }

  export type AxesAvgAggregateOutputType = {
    id: number | null
    plan_id: number | null
  }

  export type AxesSumAggregateOutputType = {
    id: number | null
    plan_id: number | null
  }

  export type AxesMinAggregateOutputType = {
    id: number | null
    plan_id: number | null
    name: string | null
    description: string | null
    statut: string | null
    objectif: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type AxesMaxAggregateOutputType = {
    id: number | null
    plan_id: number | null
    name: string | null
    description: string | null
    statut: string | null
    objectif: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type AxesCountAggregateOutputType = {
    id: number
    plan_id: number
    name: number
    description: number
    statut: number
    objectif: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type AxesAvgAggregateInputType = {
    id?: true
    plan_id?: true
  }

  export type AxesSumAggregateInputType = {
    id?: true
    plan_id?: true
  }

  export type AxesMinAggregateInputType = {
    id?: true
    plan_id?: true
    name?: true
    description?: true
    statut?: true
    objectif?: true
    created_date?: true
    last_updated?: true
  }

  export type AxesMaxAggregateInputType = {
    id?: true
    plan_id?: true
    name?: true
    description?: true
    statut?: true
    objectif?: true
    created_date?: true
    last_updated?: true
  }

  export type AxesCountAggregateInputType = {
    id?: true
    plan_id?: true
    name?: true
    description?: true
    statut?: true
    objectif?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type AxesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which axes to aggregate.
     */
    where?: axesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of axes to fetch.
     */
    orderBy?: axesOrderByWithRelationInput | axesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: axesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` axes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` axes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned axes
    **/
    _count?: true | AxesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AxesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AxesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AxesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AxesMaxAggregateInputType
  }

  export type GetAxesAggregateType<T extends AxesAggregateArgs> = {
        [P in keyof T & keyof AggregateAxes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAxes[P]>
      : GetScalarType<T[P], AggregateAxes[P]>
  }




  export type axesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: axesWhereInput
    orderBy?: axesOrderByWithAggregationInput | axesOrderByWithAggregationInput[]
    by: AxesScalarFieldEnum[] | AxesScalarFieldEnum
    having?: axesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AxesCountAggregateInputType | true
    _avg?: AxesAvgAggregateInputType
    _sum?: AxesSumAggregateInputType
    _min?: AxesMinAggregateInputType
    _max?: AxesMaxAggregateInputType
  }

  export type AxesGroupByOutputType = {
    id: number
    plan_id: number
    name: string
    description: string | null
    statut: string | null
    objectif: string | null
    created_date: Date
    last_updated: Date
    _count: AxesCountAggregateOutputType | null
    _avg: AxesAvgAggregateOutputType | null
    _sum: AxesSumAggregateOutputType | null
    _min: AxesMinAggregateOutputType | null
    _max: AxesMaxAggregateOutputType | null
  }

  type GetAxesGroupByPayload<T extends axesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AxesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AxesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AxesGroupByOutputType[P]>
            : GetScalarType<T[P], AxesGroupByOutputType[P]>
        }
      >
    >


  export type axesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plan_id?: boolean
    name?: boolean
    description?: boolean
    statut?: boolean
    objectif?: boolean
    created_date?: boolean
    last_updated?: boolean
    plans_action?: boolean | plans_actionDefaultArgs<ExtArgs>
    projets?: boolean | axes$projetsArgs<ExtArgs>
    _count?: boolean | AxesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["axes"]>


  export type axesSelectScalar = {
    id?: boolean
    plan_id?: boolean
    name?: boolean
    description?: boolean
    statut?: boolean
    objectif?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type axesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans_action?: boolean | plans_actionDefaultArgs<ExtArgs>
    projets?: boolean | axes$projetsArgs<ExtArgs>
    _count?: boolean | AxesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $axesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "axes"
    objects: {
      plans_action: Prisma.$plans_actionPayload<ExtArgs>
      projets: Prisma.$projetsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plan_id: number
      name: string
      description: string | null
      statut: string | null
      objectif: string | null
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["axes"]>
    composites: {}
  }

  type axesGetPayload<S extends boolean | null | undefined | axesDefaultArgs> = $Result.GetResult<Prisma.$axesPayload, S>

  type axesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<axesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AxesCountAggregateInputType | true
    }

  export interface axesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['axes'], meta: { name: 'axes' } }
    /**
     * Find zero or one Axes that matches the filter.
     * @param {axesFindUniqueArgs} args - Arguments to find a Axes
     * @example
     * // Get one Axes
     * const axes = await prisma.axes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends axesFindUniqueArgs>(args: SelectSubset<T, axesFindUniqueArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Axes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {axesFindUniqueOrThrowArgs} args - Arguments to find a Axes
     * @example
     * // Get one Axes
     * const axes = await prisma.axes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends axesFindUniqueOrThrowArgs>(args: SelectSubset<T, axesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Axes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {axesFindFirstArgs} args - Arguments to find a Axes
     * @example
     * // Get one Axes
     * const axes = await prisma.axes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends axesFindFirstArgs>(args?: SelectSubset<T, axesFindFirstArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Axes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {axesFindFirstOrThrowArgs} args - Arguments to find a Axes
     * @example
     * // Get one Axes
     * const axes = await prisma.axes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends axesFindFirstOrThrowArgs>(args?: SelectSubset<T, axesFindFirstOrThrowArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Axes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {axesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Axes
     * const axes = await prisma.axes.findMany()
     * 
     * // Get first 10 Axes
     * const axes = await prisma.axes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const axesWithIdOnly = await prisma.axes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends axesFindManyArgs>(args?: SelectSubset<T, axesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Axes.
     * @param {axesCreateArgs} args - Arguments to create a Axes.
     * @example
     * // Create one Axes
     * const Axes = await prisma.axes.create({
     *   data: {
     *     // ... data to create a Axes
     *   }
     * })
     * 
     */
    create<T extends axesCreateArgs>(args: SelectSubset<T, axesCreateArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Axes.
     * @param {axesCreateManyArgs} args - Arguments to create many Axes.
     * @example
     * // Create many Axes
     * const axes = await prisma.axes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends axesCreateManyArgs>(args?: SelectSubset<T, axesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Axes.
     * @param {axesDeleteArgs} args - Arguments to delete one Axes.
     * @example
     * // Delete one Axes
     * const Axes = await prisma.axes.delete({
     *   where: {
     *     // ... filter to delete one Axes
     *   }
     * })
     * 
     */
    delete<T extends axesDeleteArgs>(args: SelectSubset<T, axesDeleteArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Axes.
     * @param {axesUpdateArgs} args - Arguments to update one Axes.
     * @example
     * // Update one Axes
     * const axes = await prisma.axes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends axesUpdateArgs>(args: SelectSubset<T, axesUpdateArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Axes.
     * @param {axesDeleteManyArgs} args - Arguments to filter Axes to delete.
     * @example
     * // Delete a few Axes
     * const { count } = await prisma.axes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends axesDeleteManyArgs>(args?: SelectSubset<T, axesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Axes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {axesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Axes
     * const axes = await prisma.axes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends axesUpdateManyArgs>(args: SelectSubset<T, axesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Axes.
     * @param {axesUpsertArgs} args - Arguments to update or create a Axes.
     * @example
     * // Update or create a Axes
     * const axes = await prisma.axes.upsert({
     *   create: {
     *     // ... data to create a Axes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Axes we want to update
     *   }
     * })
     */
    upsert<T extends axesUpsertArgs>(args: SelectSubset<T, axesUpsertArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Axes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {axesCountArgs} args - Arguments to filter Axes to count.
     * @example
     * // Count the number of Axes
     * const count = await prisma.axes.count({
     *   where: {
     *     // ... the filter for the Axes we want to count
     *   }
     * })
    **/
    count<T extends axesCountArgs>(
      args?: Subset<T, axesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AxesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Axes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AxesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AxesAggregateArgs>(args: Subset<T, AxesAggregateArgs>): Prisma.PrismaPromise<GetAxesAggregateType<T>>

    /**
     * Group by Axes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {axesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends axesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: axesGroupByArgs['orderBy'] }
        : { orderBy?: axesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, axesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAxesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the axes model
   */
  readonly fields: axesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for axes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__axesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plans_action<T extends plans_actionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, plans_actionDefaultArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projets<T extends axes$projetsArgs<ExtArgs> = {}>(args?: Subset<T, axes$projetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the axes model
   */ 
  interface axesFieldRefs {
    readonly id: FieldRef<"axes", 'Int'>
    readonly plan_id: FieldRef<"axes", 'Int'>
    readonly name: FieldRef<"axes", 'String'>
    readonly description: FieldRef<"axes", 'String'>
    readonly statut: FieldRef<"axes", 'String'>
    readonly objectif: FieldRef<"axes", 'String'>
    readonly created_date: FieldRef<"axes", 'DateTime'>
    readonly last_updated: FieldRef<"axes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * axes findUnique
   */
  export type axesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * Filter, which axes to fetch.
     */
    where: axesWhereUniqueInput
  }

  /**
   * axes findUniqueOrThrow
   */
  export type axesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * Filter, which axes to fetch.
     */
    where: axesWhereUniqueInput
  }

  /**
   * axes findFirst
   */
  export type axesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * Filter, which axes to fetch.
     */
    where?: axesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of axes to fetch.
     */
    orderBy?: axesOrderByWithRelationInput | axesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for axes.
     */
    cursor?: axesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` axes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` axes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of axes.
     */
    distinct?: AxesScalarFieldEnum | AxesScalarFieldEnum[]
  }

  /**
   * axes findFirstOrThrow
   */
  export type axesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * Filter, which axes to fetch.
     */
    where?: axesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of axes to fetch.
     */
    orderBy?: axesOrderByWithRelationInput | axesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for axes.
     */
    cursor?: axesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` axes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` axes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of axes.
     */
    distinct?: AxesScalarFieldEnum | AxesScalarFieldEnum[]
  }

  /**
   * axes findMany
   */
  export type axesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * Filter, which axes to fetch.
     */
    where?: axesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of axes to fetch.
     */
    orderBy?: axesOrderByWithRelationInput | axesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing axes.
     */
    cursor?: axesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` axes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` axes.
     */
    skip?: number
    distinct?: AxesScalarFieldEnum | AxesScalarFieldEnum[]
  }

  /**
   * axes create
   */
  export type axesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * The data needed to create a axes.
     */
    data: XOR<axesCreateInput, axesUncheckedCreateInput>
  }

  /**
   * axes createMany
   */
  export type axesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many axes.
     */
    data: axesCreateManyInput | axesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * axes update
   */
  export type axesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * The data needed to update a axes.
     */
    data: XOR<axesUpdateInput, axesUncheckedUpdateInput>
    /**
     * Choose, which axes to update.
     */
    where: axesWhereUniqueInput
  }

  /**
   * axes updateMany
   */
  export type axesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update axes.
     */
    data: XOR<axesUpdateManyMutationInput, axesUncheckedUpdateManyInput>
    /**
     * Filter which axes to update
     */
    where?: axesWhereInput
  }

  /**
   * axes upsert
   */
  export type axesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * The filter to search for the axes to update in case it exists.
     */
    where: axesWhereUniqueInput
    /**
     * In case the axes found by the `where` argument doesn't exist, create a new axes with this data.
     */
    create: XOR<axesCreateInput, axesUncheckedCreateInput>
    /**
     * In case the axes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<axesUpdateInput, axesUncheckedUpdateInput>
  }

  /**
   * axes delete
   */
  export type axesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    /**
     * Filter which axes to delete.
     */
    where: axesWhereUniqueInput
  }

  /**
   * axes deleteMany
   */
  export type axesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which axes to delete
     */
    where?: axesWhereInput
  }

  /**
   * axes.projets
   */
  export type axes$projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    where?: projetsWhereInput
    orderBy?: projetsOrderByWithRelationInput | projetsOrderByWithRelationInput[]
    cursor?: projetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetsScalarFieldEnum | ProjetsScalarFieldEnum[]
  }

  /**
   * axes without action
   */
  export type axesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
  }


  /**
   * Model category_user
   */

  export type AggregateCategory_user = {
    _count: Category_userCountAggregateOutputType | null
    _avg: Category_userAvgAggregateOutputType | null
    _sum: Category_userSumAggregateOutputType | null
    _min: Category_userMinAggregateOutputType | null
    _max: Category_userMaxAggregateOutputType | null
  }

  export type Category_userAvgAggregateOutputType = {
    id: number | null
  }

  export type Category_userSumAggregateOutputType = {
    id: number | null
  }

  export type Category_userMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type Category_userMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type Category_userCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type Category_userAvgAggregateInputType = {
    id?: true
  }

  export type Category_userSumAggregateInputType = {
    id?: true
  }

  export type Category_userMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    last_updated?: true
  }

  export type Category_userMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    last_updated?: true
  }

  export type Category_userCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type Category_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_user to aggregate.
     */
    where?: category_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_users to fetch.
     */
    orderBy?: category_userOrderByWithRelationInput | category_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: category_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned category_users
    **/
    _count?: true | Category_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Category_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Category_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Category_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Category_userMaxAggregateInputType
  }

  export type GetCategory_userAggregateType<T extends Category_userAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory_user[P]>
      : GetScalarType<T[P], AggregateCategory_user[P]>
  }




  export type category_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_userWhereInput
    orderBy?: category_userOrderByWithAggregationInput | category_userOrderByWithAggregationInput[]
    by: Category_userScalarFieldEnum[] | Category_userScalarFieldEnum
    having?: category_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Category_userCountAggregateInputType | true
    _avg?: Category_userAvgAggregateInputType
    _sum?: Category_userSumAggregateInputType
    _min?: Category_userMinAggregateInputType
    _max?: Category_userMaxAggregateInputType
  }

  export type Category_userGroupByOutputType = {
    id: number
    name: string
    description: string
    created_date: Date
    last_updated: Date
    _count: Category_userCountAggregateOutputType | null
    _avg: Category_userAvgAggregateOutputType | null
    _sum: Category_userSumAggregateOutputType | null
    _min: Category_userMinAggregateOutputType | null
    _max: Category_userMaxAggregateOutputType | null
  }

  type GetCategory_userGroupByPayload<T extends category_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Category_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Category_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Category_userGroupByOutputType[P]>
            : GetScalarType<T[P], Category_userGroupByOutputType[P]>
        }
      >
    >


  export type category_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_date?: boolean
    last_updated?: boolean
    utilisateurs?: boolean | category_user$utilisateursArgs<ExtArgs>
    _count?: boolean | Category_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category_user"]>


  export type category_userSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type category_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateurs?: boolean | category_user$utilisateursArgs<ExtArgs>
    _count?: boolean | Category_userCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $category_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category_user"
    objects: {
      utilisateurs: Prisma.$utilisateursPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["category_user"]>
    composites: {}
  }

  type category_userGetPayload<S extends boolean | null | undefined | category_userDefaultArgs> = $Result.GetResult<Prisma.$category_userPayload, S>

  type category_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<category_userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Category_userCountAggregateInputType | true
    }

  export interface category_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category_user'], meta: { name: 'category_user' } }
    /**
     * Find zero or one Category_user that matches the filter.
     * @param {category_userFindUniqueArgs} args - Arguments to find a Category_user
     * @example
     * // Get one Category_user
     * const category_user = await prisma.category_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends category_userFindUniqueArgs>(args: SelectSubset<T, category_userFindUniqueArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category_user that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {category_userFindUniqueOrThrowArgs} args - Arguments to find a Category_user
     * @example
     * // Get one Category_user
     * const category_user = await prisma.category_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends category_userFindUniqueOrThrowArgs>(args: SelectSubset<T, category_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_userFindFirstArgs} args - Arguments to find a Category_user
     * @example
     * // Get one Category_user
     * const category_user = await prisma.category_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends category_userFindFirstArgs>(args?: SelectSubset<T, category_userFindFirstArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_userFindFirstOrThrowArgs} args - Arguments to find a Category_user
     * @example
     * // Get one Category_user
     * const category_user = await prisma.category_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends category_userFindFirstOrThrowArgs>(args?: SelectSubset<T, category_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Category_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Category_users
     * const category_users = await prisma.category_user.findMany()
     * 
     * // Get first 10 Category_users
     * const category_users = await prisma.category_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const category_userWithIdOnly = await prisma.category_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends category_userFindManyArgs>(args?: SelectSubset<T, category_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category_user.
     * @param {category_userCreateArgs} args - Arguments to create a Category_user.
     * @example
     * // Create one Category_user
     * const Category_user = await prisma.category_user.create({
     *   data: {
     *     // ... data to create a Category_user
     *   }
     * })
     * 
     */
    create<T extends category_userCreateArgs>(args: SelectSubset<T, category_userCreateArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Category_users.
     * @param {category_userCreateManyArgs} args - Arguments to create many Category_users.
     * @example
     * // Create many Category_users
     * const category_user = await prisma.category_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends category_userCreateManyArgs>(args?: SelectSubset<T, category_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category_user.
     * @param {category_userDeleteArgs} args - Arguments to delete one Category_user.
     * @example
     * // Delete one Category_user
     * const Category_user = await prisma.category_user.delete({
     *   where: {
     *     // ... filter to delete one Category_user
     *   }
     * })
     * 
     */
    delete<T extends category_userDeleteArgs>(args: SelectSubset<T, category_userDeleteArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category_user.
     * @param {category_userUpdateArgs} args - Arguments to update one Category_user.
     * @example
     * // Update one Category_user
     * const category_user = await prisma.category_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends category_userUpdateArgs>(args: SelectSubset<T, category_userUpdateArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Category_users.
     * @param {category_userDeleteManyArgs} args - Arguments to filter Category_users to delete.
     * @example
     * // Delete a few Category_users
     * const { count } = await prisma.category_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends category_userDeleteManyArgs>(args?: SelectSubset<T, category_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Category_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Category_users
     * const category_user = await prisma.category_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends category_userUpdateManyArgs>(args: SelectSubset<T, category_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category_user.
     * @param {category_userUpsertArgs} args - Arguments to update or create a Category_user.
     * @example
     * // Update or create a Category_user
     * const category_user = await prisma.category_user.upsert({
     *   create: {
     *     // ... data to create a Category_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category_user we want to update
     *   }
     * })
     */
    upsert<T extends category_userUpsertArgs>(args: SelectSubset<T, category_userUpsertArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Category_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_userCountArgs} args - Arguments to filter Category_users to count.
     * @example
     * // Count the number of Category_users
     * const count = await prisma.category_user.count({
     *   where: {
     *     // ... the filter for the Category_users we want to count
     *   }
     * })
    **/
    count<T extends category_userCountArgs>(
      args?: Subset<T, category_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Category_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Category_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Category_userAggregateArgs>(args: Subset<T, Category_userAggregateArgs>): Prisma.PrismaPromise<GetCategory_userAggregateType<T>>

    /**
     * Group by Category_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends category_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: category_userGroupByArgs['orderBy'] }
        : { orderBy?: category_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, category_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategory_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category_user model
   */
  readonly fields: category_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__category_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateurs<T extends category_user$utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, category_user$utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category_user model
   */ 
  interface category_userFieldRefs {
    readonly id: FieldRef<"category_user", 'Int'>
    readonly name: FieldRef<"category_user", 'String'>
    readonly description: FieldRef<"category_user", 'String'>
    readonly created_date: FieldRef<"category_user", 'DateTime'>
    readonly last_updated: FieldRef<"category_user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * category_user findUnique
   */
  export type category_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * Filter, which category_user to fetch.
     */
    where: category_userWhereUniqueInput
  }

  /**
   * category_user findUniqueOrThrow
   */
  export type category_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * Filter, which category_user to fetch.
     */
    where: category_userWhereUniqueInput
  }

  /**
   * category_user findFirst
   */
  export type category_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * Filter, which category_user to fetch.
     */
    where?: category_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_users to fetch.
     */
    orderBy?: category_userOrderByWithRelationInput | category_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_users.
     */
    cursor?: category_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_users.
     */
    distinct?: Category_userScalarFieldEnum | Category_userScalarFieldEnum[]
  }

  /**
   * category_user findFirstOrThrow
   */
  export type category_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * Filter, which category_user to fetch.
     */
    where?: category_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_users to fetch.
     */
    orderBy?: category_userOrderByWithRelationInput | category_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_users.
     */
    cursor?: category_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_users.
     */
    distinct?: Category_userScalarFieldEnum | Category_userScalarFieldEnum[]
  }

  /**
   * category_user findMany
   */
  export type category_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * Filter, which category_users to fetch.
     */
    where?: category_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_users to fetch.
     */
    orderBy?: category_userOrderByWithRelationInput | category_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing category_users.
     */
    cursor?: category_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_users.
     */
    skip?: number
    distinct?: Category_userScalarFieldEnum | Category_userScalarFieldEnum[]
  }

  /**
   * category_user create
   */
  export type category_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * The data needed to create a category_user.
     */
    data: XOR<category_userCreateInput, category_userUncheckedCreateInput>
  }

  /**
   * category_user createMany
   */
  export type category_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many category_users.
     */
    data: category_userCreateManyInput | category_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category_user update
   */
  export type category_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * The data needed to update a category_user.
     */
    data: XOR<category_userUpdateInput, category_userUncheckedUpdateInput>
    /**
     * Choose, which category_user to update.
     */
    where: category_userWhereUniqueInput
  }

  /**
   * category_user updateMany
   */
  export type category_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update category_users.
     */
    data: XOR<category_userUpdateManyMutationInput, category_userUncheckedUpdateManyInput>
    /**
     * Filter which category_users to update
     */
    where?: category_userWhereInput
  }

  /**
   * category_user upsert
   */
  export type category_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * The filter to search for the category_user to update in case it exists.
     */
    where: category_userWhereUniqueInput
    /**
     * In case the category_user found by the `where` argument doesn't exist, create a new category_user with this data.
     */
    create: XOR<category_userCreateInput, category_userUncheckedCreateInput>
    /**
     * In case the category_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<category_userUpdateInput, category_userUncheckedUpdateInput>
  }

  /**
   * category_user delete
   */
  export type category_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    /**
     * Filter which category_user to delete.
     */
    where: category_userWhereUniqueInput
  }

  /**
   * category_user deleteMany
   */
  export type category_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_users to delete
     */
    where?: category_userWhereInput
  }

  /**
   * category_user.utilisateurs
   */
  export type category_user$utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    where?: utilisateursWhereInput
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    cursor?: utilisateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * category_user without action
   */
  export type category_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
  }


  /**
   * Model commentaires
   */

  export type AggregateCommentaires = {
    _count: CommentairesCountAggregateOutputType | null
    _avg: CommentairesAvgAggregateOutputType | null
    _sum: CommentairesSumAggregateOutputType | null
    _min: CommentairesMinAggregateOutputType | null
    _max: CommentairesMaxAggregateOutputType | null
  }

  export type CommentairesAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
    compte_id: number | null
  }

  export type CommentairesSumAggregateOutputType = {
    id: number | null
    project_id: number | null
    compte_id: number | null
  }

  export type CommentairesMinAggregateOutputType = {
    id: number | null
    project_id: number | null
    compte_id: number | null
    content: string | null
    created_at: Date | null
  }

  export type CommentairesMaxAggregateOutputType = {
    id: number | null
    project_id: number | null
    compte_id: number | null
    content: string | null
    created_at: Date | null
  }

  export type CommentairesCountAggregateOutputType = {
    id: number
    project_id: number
    compte_id: number
    content: number
    created_at: number
    _all: number
  }


  export type CommentairesAvgAggregateInputType = {
    id?: true
    project_id?: true
    compte_id?: true
  }

  export type CommentairesSumAggregateInputType = {
    id?: true
    project_id?: true
    compte_id?: true
  }

  export type CommentairesMinAggregateInputType = {
    id?: true
    project_id?: true
    compte_id?: true
    content?: true
    created_at?: true
  }

  export type CommentairesMaxAggregateInputType = {
    id?: true
    project_id?: true
    compte_id?: true
    content?: true
    created_at?: true
  }

  export type CommentairesCountAggregateInputType = {
    id?: true
    project_id?: true
    compte_id?: true
    content?: true
    created_at?: true
    _all?: true
  }

  export type CommentairesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which commentaires to aggregate.
     */
    where?: commentairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commentaires to fetch.
     */
    orderBy?: commentairesOrderByWithRelationInput | commentairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned commentaires
    **/
    _count?: true | CommentairesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentairesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentairesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentairesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentairesMaxAggregateInputType
  }

  export type GetCommentairesAggregateType<T extends CommentairesAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentaires]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentaires[P]>
      : GetScalarType<T[P], AggregateCommentaires[P]>
  }




  export type commentairesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentairesWhereInput
    orderBy?: commentairesOrderByWithAggregationInput | commentairesOrderByWithAggregationInput[]
    by: CommentairesScalarFieldEnum[] | CommentairesScalarFieldEnum
    having?: commentairesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentairesCountAggregateInputType | true
    _avg?: CommentairesAvgAggregateInputType
    _sum?: CommentairesSumAggregateInputType
    _min?: CommentairesMinAggregateInputType
    _max?: CommentairesMaxAggregateInputType
  }

  export type CommentairesGroupByOutputType = {
    id: number
    project_id: number
    compte_id: number
    content: string
    created_at: Date
    _count: CommentairesCountAggregateOutputType | null
    _avg: CommentairesAvgAggregateOutputType | null
    _sum: CommentairesSumAggregateOutputType | null
    _min: CommentairesMinAggregateOutputType | null
    _max: CommentairesMaxAggregateOutputType | null
  }

  type GetCommentairesGroupByPayload<T extends commentairesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentairesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentairesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentairesGroupByOutputType[P]>
            : GetScalarType<T[P], CommentairesGroupByOutputType[P]>
        }
      >
    >


  export type commentairesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    compte_id?: boolean
    content?: boolean
    created_at?: boolean
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    comptes?: boolean | comptesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentaires"]>


  export type commentairesSelectScalar = {
    id?: boolean
    project_id?: boolean
    compte_id?: boolean
    content?: boolean
    created_at?: boolean
  }

  export type commentairesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    comptes?: boolean | comptesDefaultArgs<ExtArgs>
  }

  export type $commentairesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "commentaires"
    objects: {
      projets: Prisma.$projetsPayload<ExtArgs>
      comptes: Prisma.$comptesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      project_id: number
      compte_id: number
      content: string
      created_at: Date
    }, ExtArgs["result"]["commentaires"]>
    composites: {}
  }

  type commentairesGetPayload<S extends boolean | null | undefined | commentairesDefaultArgs> = $Result.GetResult<Prisma.$commentairesPayload, S>

  type commentairesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<commentairesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentairesCountAggregateInputType | true
    }

  export interface commentairesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['commentaires'], meta: { name: 'commentaires' } }
    /**
     * Find zero or one Commentaires that matches the filter.
     * @param {commentairesFindUniqueArgs} args - Arguments to find a Commentaires
     * @example
     * // Get one Commentaires
     * const commentaires = await prisma.commentaires.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentairesFindUniqueArgs>(args: SelectSubset<T, commentairesFindUniqueArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Commentaires that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {commentairesFindUniqueOrThrowArgs} args - Arguments to find a Commentaires
     * @example
     * // Get one Commentaires
     * const commentaires = await prisma.commentaires.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentairesFindUniqueOrThrowArgs>(args: SelectSubset<T, commentairesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Commentaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentairesFindFirstArgs} args - Arguments to find a Commentaires
     * @example
     * // Get one Commentaires
     * const commentaires = await prisma.commentaires.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentairesFindFirstArgs>(args?: SelectSubset<T, commentairesFindFirstArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Commentaires that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentairesFindFirstOrThrowArgs} args - Arguments to find a Commentaires
     * @example
     * // Get one Commentaires
     * const commentaires = await prisma.commentaires.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentairesFindFirstOrThrowArgs>(args?: SelectSubset<T, commentairesFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Commentaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentairesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commentaires
     * const commentaires = await prisma.commentaires.findMany()
     * 
     * // Get first 10 Commentaires
     * const commentaires = await prisma.commentaires.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentairesWithIdOnly = await prisma.commentaires.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends commentairesFindManyArgs>(args?: SelectSubset<T, commentairesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Commentaires.
     * @param {commentairesCreateArgs} args - Arguments to create a Commentaires.
     * @example
     * // Create one Commentaires
     * const Commentaires = await prisma.commentaires.create({
     *   data: {
     *     // ... data to create a Commentaires
     *   }
     * })
     * 
     */
    create<T extends commentairesCreateArgs>(args: SelectSubset<T, commentairesCreateArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Commentaires.
     * @param {commentairesCreateManyArgs} args - Arguments to create many Commentaires.
     * @example
     * // Create many Commentaires
     * const commentaires = await prisma.commentaires.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentairesCreateManyArgs>(args?: SelectSubset<T, commentairesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commentaires.
     * @param {commentairesDeleteArgs} args - Arguments to delete one Commentaires.
     * @example
     * // Delete one Commentaires
     * const Commentaires = await prisma.commentaires.delete({
     *   where: {
     *     // ... filter to delete one Commentaires
     *   }
     * })
     * 
     */
    delete<T extends commentairesDeleteArgs>(args: SelectSubset<T, commentairesDeleteArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Commentaires.
     * @param {commentairesUpdateArgs} args - Arguments to update one Commentaires.
     * @example
     * // Update one Commentaires
     * const commentaires = await prisma.commentaires.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentairesUpdateArgs>(args: SelectSubset<T, commentairesUpdateArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Commentaires.
     * @param {commentairesDeleteManyArgs} args - Arguments to filter Commentaires to delete.
     * @example
     * // Delete a few Commentaires
     * const { count } = await prisma.commentaires.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentairesDeleteManyArgs>(args?: SelectSubset<T, commentairesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentairesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commentaires
     * const commentaires = await prisma.commentaires.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentairesUpdateManyArgs>(args: SelectSubset<T, commentairesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commentaires.
     * @param {commentairesUpsertArgs} args - Arguments to update or create a Commentaires.
     * @example
     * // Update or create a Commentaires
     * const commentaires = await prisma.commentaires.upsert({
     *   create: {
     *     // ... data to create a Commentaires
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commentaires we want to update
     *   }
     * })
     */
    upsert<T extends commentairesUpsertArgs>(args: SelectSubset<T, commentairesUpsertArgs<ExtArgs>>): Prisma__commentairesClient<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentairesCountArgs} args - Arguments to filter Commentaires to count.
     * @example
     * // Count the number of Commentaires
     * const count = await prisma.commentaires.count({
     *   where: {
     *     // ... the filter for the Commentaires we want to count
     *   }
     * })
    **/
    count<T extends commentairesCountArgs>(
      args?: Subset<T, commentairesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentairesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentairesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentairesAggregateArgs>(args: Subset<T, CommentairesAggregateArgs>): Prisma.PrismaPromise<GetCommentairesAggregateType<T>>

    /**
     * Group by Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentairesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentairesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentairesGroupByArgs['orderBy'] }
        : { orderBy?: commentairesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentairesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentairesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the commentaires model
   */
  readonly fields: commentairesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for commentaires.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentairesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projets<T extends projetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetsDefaultArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comptes<T extends comptesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, comptesDefaultArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the commentaires model
   */ 
  interface commentairesFieldRefs {
    readonly id: FieldRef<"commentaires", 'Int'>
    readonly project_id: FieldRef<"commentaires", 'Int'>
    readonly compte_id: FieldRef<"commentaires", 'Int'>
    readonly content: FieldRef<"commentaires", 'String'>
    readonly created_at: FieldRef<"commentaires", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * commentaires findUnique
   */
  export type commentairesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * Filter, which commentaires to fetch.
     */
    where: commentairesWhereUniqueInput
  }

  /**
   * commentaires findUniqueOrThrow
   */
  export type commentairesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * Filter, which commentaires to fetch.
     */
    where: commentairesWhereUniqueInput
  }

  /**
   * commentaires findFirst
   */
  export type commentairesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * Filter, which commentaires to fetch.
     */
    where?: commentairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commentaires to fetch.
     */
    orderBy?: commentairesOrderByWithRelationInput | commentairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commentaires.
     */
    cursor?: commentairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commentaires.
     */
    distinct?: CommentairesScalarFieldEnum | CommentairesScalarFieldEnum[]
  }

  /**
   * commentaires findFirstOrThrow
   */
  export type commentairesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * Filter, which commentaires to fetch.
     */
    where?: commentairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commentaires to fetch.
     */
    orderBy?: commentairesOrderByWithRelationInput | commentairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commentaires.
     */
    cursor?: commentairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commentaires.
     */
    distinct?: CommentairesScalarFieldEnum | CommentairesScalarFieldEnum[]
  }

  /**
   * commentaires findMany
   */
  export type commentairesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * Filter, which commentaires to fetch.
     */
    where?: commentairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commentaires to fetch.
     */
    orderBy?: commentairesOrderByWithRelationInput | commentairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing commentaires.
     */
    cursor?: commentairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commentaires.
     */
    skip?: number
    distinct?: CommentairesScalarFieldEnum | CommentairesScalarFieldEnum[]
  }

  /**
   * commentaires create
   */
  export type commentairesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * The data needed to create a commentaires.
     */
    data: XOR<commentairesCreateInput, commentairesUncheckedCreateInput>
  }

  /**
   * commentaires createMany
   */
  export type commentairesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many commentaires.
     */
    data: commentairesCreateManyInput | commentairesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * commentaires update
   */
  export type commentairesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * The data needed to update a commentaires.
     */
    data: XOR<commentairesUpdateInput, commentairesUncheckedUpdateInput>
    /**
     * Choose, which commentaires to update.
     */
    where: commentairesWhereUniqueInput
  }

  /**
   * commentaires updateMany
   */
  export type commentairesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update commentaires.
     */
    data: XOR<commentairesUpdateManyMutationInput, commentairesUncheckedUpdateManyInput>
    /**
     * Filter which commentaires to update
     */
    where?: commentairesWhereInput
  }

  /**
   * commentaires upsert
   */
  export type commentairesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * The filter to search for the commentaires to update in case it exists.
     */
    where: commentairesWhereUniqueInput
    /**
     * In case the commentaires found by the `where` argument doesn't exist, create a new commentaires with this data.
     */
    create: XOR<commentairesCreateInput, commentairesUncheckedCreateInput>
    /**
     * In case the commentaires was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentairesUpdateInput, commentairesUncheckedUpdateInput>
  }

  /**
   * commentaires delete
   */
  export type commentairesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    /**
     * Filter which commentaires to delete.
     */
    where: commentairesWhereUniqueInput
  }

  /**
   * commentaires deleteMany
   */
  export type commentairesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which commentaires to delete
     */
    where?: commentairesWhereInput
  }

  /**
   * commentaires without action
   */
  export type commentairesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
  }


  /**
   * Model comptes
   */

  export type AggregateComptes = {
    _count: ComptesCountAggregateOutputType | null
    _avg: ComptesAvgAggregateOutputType | null
    _sum: ComptesSumAggregateOutputType | null
    _min: ComptesMinAggregateOutputType | null
    _max: ComptesMaxAggregateOutputType | null
  }

  export type ComptesAvgAggregateOutputType = {
    id: number | null
    role_id: number | null
    user_id: number | null
  }

  export type ComptesSumAggregateOutputType = {
    id: number | null
    role_id: number | null
    user_id: number | null
  }

  export type ComptesMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role_id: number | null
    validity: $Enums.comptes_validity | null
    user_id: number | null
  }

  export type ComptesMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role_id: number | null
    validity: $Enums.comptes_validity | null
    user_id: number | null
  }

  export type ComptesCountAggregateOutputType = {
    id: number
    username: number
    password: number
    role_id: number
    validity: number
    user_id: number
    _all: number
  }


  export type ComptesAvgAggregateInputType = {
    id?: true
    role_id?: true
    user_id?: true
  }

  export type ComptesSumAggregateInputType = {
    id?: true
    role_id?: true
    user_id?: true
  }

  export type ComptesMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role_id?: true
    validity?: true
    user_id?: true
  }

  export type ComptesMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role_id?: true
    validity?: true
    user_id?: true
  }

  export type ComptesCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role_id?: true
    validity?: true
    user_id?: true
    _all?: true
  }

  export type ComptesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comptes to aggregate.
     */
    where?: comptesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: comptesOrderByWithRelationInput | comptesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comptesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comptes
    **/
    _count?: true | ComptesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComptesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComptesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComptesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComptesMaxAggregateInputType
  }

  export type GetComptesAggregateType<T extends ComptesAggregateArgs> = {
        [P in keyof T & keyof AggregateComptes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComptes[P]>
      : GetScalarType<T[P], AggregateComptes[P]>
  }




  export type comptesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comptesWhereInput
    orderBy?: comptesOrderByWithAggregationInput | comptesOrderByWithAggregationInput[]
    by: ComptesScalarFieldEnum[] | ComptesScalarFieldEnum
    having?: comptesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComptesCountAggregateInputType | true
    _avg?: ComptesAvgAggregateInputType
    _sum?: ComptesSumAggregateInputType
    _min?: ComptesMinAggregateInputType
    _max?: ComptesMaxAggregateInputType
  }

  export type ComptesGroupByOutputType = {
    id: number
    username: string
    password: string
    role_id: number
    validity: $Enums.comptes_validity
    user_id: number | null
    _count: ComptesCountAggregateOutputType | null
    _avg: ComptesAvgAggregateOutputType | null
    _sum: ComptesSumAggregateOutputType | null
    _min: ComptesMinAggregateOutputType | null
    _max: ComptesMaxAggregateOutputType | null
  }

  type GetComptesGroupByPayload<T extends comptesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComptesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComptesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComptesGroupByOutputType[P]>
            : GetScalarType<T[P], ComptesGroupByOutputType[P]>
        }
      >
    >


  export type comptesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role_id?: boolean
    validity?: boolean
    user_id?: boolean
    commentaires?: boolean | comptes$commentairesArgs<ExtArgs>
    utilisateurs?: boolean | comptes$utilisateursArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    suggestions?: boolean | comptes$suggestionsArgs<ExtArgs>
    votes?: boolean | comptes$votesArgs<ExtArgs>
    _count?: boolean | ComptesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comptes"]>


  export type comptesSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    role_id?: boolean
    validity?: boolean
    user_id?: boolean
  }

  export type comptesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commentaires?: boolean | comptes$commentairesArgs<ExtArgs>
    utilisateurs?: boolean | comptes$utilisateursArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    suggestions?: boolean | comptes$suggestionsArgs<ExtArgs>
    votes?: boolean | comptes$votesArgs<ExtArgs>
    _count?: boolean | ComptesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $comptesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comptes"
    objects: {
      commentaires: Prisma.$commentairesPayload<ExtArgs>[]
      utilisateurs: Prisma.$utilisateursPayload<ExtArgs> | null
      roles: Prisma.$rolesPayload<ExtArgs>
      suggestions: Prisma.$suggestionsPayload<ExtArgs>[]
      votes: Prisma.$votesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      role_id: number
      validity: $Enums.comptes_validity
      user_id: number | null
    }, ExtArgs["result"]["comptes"]>
    composites: {}
  }

  type comptesGetPayload<S extends boolean | null | undefined | comptesDefaultArgs> = $Result.GetResult<Prisma.$comptesPayload, S>

  type comptesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comptesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComptesCountAggregateInputType | true
    }

  export interface comptesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comptes'], meta: { name: 'comptes' } }
    /**
     * Find zero or one Comptes that matches the filter.
     * @param {comptesFindUniqueArgs} args - Arguments to find a Comptes
     * @example
     * // Get one Comptes
     * const comptes = await prisma.comptes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comptesFindUniqueArgs>(args: SelectSubset<T, comptesFindUniqueArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comptes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {comptesFindUniqueOrThrowArgs} args - Arguments to find a Comptes
     * @example
     * // Get one Comptes
     * const comptes = await prisma.comptes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comptesFindUniqueOrThrowArgs>(args: SelectSubset<T, comptesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comptes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comptesFindFirstArgs} args - Arguments to find a Comptes
     * @example
     * // Get one Comptes
     * const comptes = await prisma.comptes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comptesFindFirstArgs>(args?: SelectSubset<T, comptesFindFirstArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comptes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comptesFindFirstOrThrowArgs} args - Arguments to find a Comptes
     * @example
     * // Get one Comptes
     * const comptes = await prisma.comptes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comptesFindFirstOrThrowArgs>(args?: SelectSubset<T, comptesFindFirstOrThrowArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comptes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comptesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comptes
     * const comptes = await prisma.comptes.findMany()
     * 
     * // Get first 10 Comptes
     * const comptes = await prisma.comptes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comptesWithIdOnly = await prisma.comptes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends comptesFindManyArgs>(args?: SelectSubset<T, comptesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comptes.
     * @param {comptesCreateArgs} args - Arguments to create a Comptes.
     * @example
     * // Create one Comptes
     * const Comptes = await prisma.comptes.create({
     *   data: {
     *     // ... data to create a Comptes
     *   }
     * })
     * 
     */
    create<T extends comptesCreateArgs>(args: SelectSubset<T, comptesCreateArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comptes.
     * @param {comptesCreateManyArgs} args - Arguments to create many Comptes.
     * @example
     * // Create many Comptes
     * const comptes = await prisma.comptes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comptesCreateManyArgs>(args?: SelectSubset<T, comptesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comptes.
     * @param {comptesDeleteArgs} args - Arguments to delete one Comptes.
     * @example
     * // Delete one Comptes
     * const Comptes = await prisma.comptes.delete({
     *   where: {
     *     // ... filter to delete one Comptes
     *   }
     * })
     * 
     */
    delete<T extends comptesDeleteArgs>(args: SelectSubset<T, comptesDeleteArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comptes.
     * @param {comptesUpdateArgs} args - Arguments to update one Comptes.
     * @example
     * // Update one Comptes
     * const comptes = await prisma.comptes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comptesUpdateArgs>(args: SelectSubset<T, comptesUpdateArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comptes.
     * @param {comptesDeleteManyArgs} args - Arguments to filter Comptes to delete.
     * @example
     * // Delete a few Comptes
     * const { count } = await prisma.comptes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comptesDeleteManyArgs>(args?: SelectSubset<T, comptesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comptesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comptes
     * const comptes = await prisma.comptes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comptesUpdateManyArgs>(args: SelectSubset<T, comptesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comptes.
     * @param {comptesUpsertArgs} args - Arguments to update or create a Comptes.
     * @example
     * // Update or create a Comptes
     * const comptes = await prisma.comptes.upsert({
     *   create: {
     *     // ... data to create a Comptes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comptes we want to update
     *   }
     * })
     */
    upsert<T extends comptesUpsertArgs>(args: SelectSubset<T, comptesUpsertArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comptesCountArgs} args - Arguments to filter Comptes to count.
     * @example
     * // Count the number of Comptes
     * const count = await prisma.comptes.count({
     *   where: {
     *     // ... the filter for the Comptes we want to count
     *   }
     * })
    **/
    count<T extends comptesCountArgs>(
      args?: Subset<T, comptesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComptesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComptesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComptesAggregateArgs>(args: Subset<T, ComptesAggregateArgs>): Prisma.PrismaPromise<GetComptesAggregateType<T>>

    /**
     * Group by Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comptesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comptesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comptesGroupByArgs['orderBy'] }
        : { orderBy?: comptesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comptesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComptesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comptes model
   */
  readonly fields: comptesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comptes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comptesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commentaires<T extends comptes$commentairesArgs<ExtArgs> = {}>(args?: Subset<T, comptes$commentairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "findMany"> | Null>
    utilisateurs<T extends comptes$utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, comptes$utilisateursArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    suggestions<T extends comptes$suggestionsArgs<ExtArgs> = {}>(args?: Subset<T, comptes$suggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findMany"> | Null>
    votes<T extends comptes$votesArgs<ExtArgs> = {}>(args?: Subset<T, comptes$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comptes model
   */ 
  interface comptesFieldRefs {
    readonly id: FieldRef<"comptes", 'Int'>
    readonly username: FieldRef<"comptes", 'String'>
    readonly password: FieldRef<"comptes", 'String'>
    readonly role_id: FieldRef<"comptes", 'Int'>
    readonly validity: FieldRef<"comptes", 'comptes_validity'>
    readonly user_id: FieldRef<"comptes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * comptes findUnique
   */
  export type comptesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * Filter, which comptes to fetch.
     */
    where: comptesWhereUniqueInput
  }

  /**
   * comptes findUniqueOrThrow
   */
  export type comptesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * Filter, which comptes to fetch.
     */
    where: comptesWhereUniqueInput
  }

  /**
   * comptes findFirst
   */
  export type comptesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * Filter, which comptes to fetch.
     */
    where?: comptesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: comptesOrderByWithRelationInput | comptesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comptes.
     */
    cursor?: comptesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comptes.
     */
    distinct?: ComptesScalarFieldEnum | ComptesScalarFieldEnum[]
  }

  /**
   * comptes findFirstOrThrow
   */
  export type comptesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * Filter, which comptes to fetch.
     */
    where?: comptesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: comptesOrderByWithRelationInput | comptesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comptes.
     */
    cursor?: comptesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comptes.
     */
    distinct?: ComptesScalarFieldEnum | ComptesScalarFieldEnum[]
  }

  /**
   * comptes findMany
   */
  export type comptesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * Filter, which comptes to fetch.
     */
    where?: comptesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comptes to fetch.
     */
    orderBy?: comptesOrderByWithRelationInput | comptesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comptes.
     */
    cursor?: comptesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comptes.
     */
    skip?: number
    distinct?: ComptesScalarFieldEnum | ComptesScalarFieldEnum[]
  }

  /**
   * comptes create
   */
  export type comptesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * The data needed to create a comptes.
     */
    data: XOR<comptesCreateInput, comptesUncheckedCreateInput>
  }

  /**
   * comptes createMany
   */
  export type comptesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comptes.
     */
    data: comptesCreateManyInput | comptesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comptes update
   */
  export type comptesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * The data needed to update a comptes.
     */
    data: XOR<comptesUpdateInput, comptesUncheckedUpdateInput>
    /**
     * Choose, which comptes to update.
     */
    where: comptesWhereUniqueInput
  }

  /**
   * comptes updateMany
   */
  export type comptesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comptes.
     */
    data: XOR<comptesUpdateManyMutationInput, comptesUncheckedUpdateManyInput>
    /**
     * Filter which comptes to update
     */
    where?: comptesWhereInput
  }

  /**
   * comptes upsert
   */
  export type comptesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * The filter to search for the comptes to update in case it exists.
     */
    where: comptesWhereUniqueInput
    /**
     * In case the comptes found by the `where` argument doesn't exist, create a new comptes with this data.
     */
    create: XOR<comptesCreateInput, comptesUncheckedCreateInput>
    /**
     * In case the comptes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comptesUpdateInput, comptesUncheckedUpdateInput>
  }

  /**
   * comptes delete
   */
  export type comptesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    /**
     * Filter which comptes to delete.
     */
    where: comptesWhereUniqueInput
  }

  /**
   * comptes deleteMany
   */
  export type comptesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comptes to delete
     */
    where?: comptesWhereInput
  }

  /**
   * comptes.commentaires
   */
  export type comptes$commentairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    where?: commentairesWhereInput
    orderBy?: commentairesOrderByWithRelationInput | commentairesOrderByWithRelationInput[]
    cursor?: commentairesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentairesScalarFieldEnum | CommentairesScalarFieldEnum[]
  }

  /**
   * comptes.utilisateurs
   */
  export type comptes$utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    where?: utilisateursWhereInput
  }

  /**
   * comptes.suggestions
   */
  export type comptes$suggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    where?: suggestionsWhereInput
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    cursor?: suggestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * comptes.votes
   */
  export type comptes$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    where?: votesWhereInput
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    cursor?: votesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * comptes without action
   */
  export type comptesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
  }


  /**
   * Model documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
  }

  export type DocumentsSumAggregateOutputType = {
    id: number | null
    project_id: number | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: number | null
    project_id: number | null
    name: string | null
    file_path: string | null
    uploaded_at: Date | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: number | null
    project_id: number | null
    name: string | null
    file_path: string | null
    uploaded_at: Date | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    project_id: number
    name: number
    file_path: number
    uploaded_at: number
    _all: number
  }


  export type DocumentsAvgAggregateInputType = {
    id?: true
    project_id?: true
  }

  export type DocumentsSumAggregateInputType = {
    id?: true
    project_id?: true
  }

  export type DocumentsMinAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    file_path?: true
    uploaded_at?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    file_path?: true
    uploaded_at?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    file_path?: true
    uploaded_at?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to aggregate.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithAggregationInput | documentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _avg?: DocumentsAvgAggregateInputType
    _sum?: DocumentsSumAggregateInputType
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: number
    project_id: number
    name: string
    file_path: string | null
    uploaded_at: Date
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    name?: boolean
    file_path?: boolean
    uploaded_at?: boolean
    projets?: boolean | projetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>


  export type documentsSelectScalar = {
    id?: boolean
    project_id?: boolean
    name?: boolean
    file_path?: boolean
    uploaded_at?: boolean
  }

  export type documentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | projetsDefaultArgs<ExtArgs>
  }

  export type $documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documents"
    objects: {
      projets: Prisma.$projetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      project_id: number
      name: string
      file_path: string | null
      uploaded_at: Date
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type documentsGetPayload<S extends boolean | null | undefined | documentsDefaultArgs> = $Result.GetResult<Prisma.$documentsPayload, S>

  type documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<documentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documents'], meta: { name: 'documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {documentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentsFindUniqueArgs>(args: SelectSubset<T, documentsFindUniqueArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {documentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentsFindFirstArgs>(args?: SelectSubset<T, documentsFindFirstArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentsFindManyArgs>(args?: SelectSubset<T, documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Documents.
     * @param {documentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends documentsCreateArgs>(args: SelectSubset<T, documentsCreateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {documentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentsCreateManyArgs>(args?: SelectSubset<T, documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Documents.
     * @param {documentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends documentsDeleteArgs>(args: SelectSubset<T, documentsDeleteArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Documents.
     * @param {documentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentsUpdateArgs>(args: SelectSubset<T, documentsUpdateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {documentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentsDeleteManyArgs>(args?: SelectSubset<T, documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentsUpdateManyArgs>(args: SelectSubset<T, documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documents.
     * @param {documentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends documentsUpsertArgs>(args: SelectSubset<T, documentsUpsertArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends documentsCountArgs>(
      args?: Subset<T, documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentsGroupByArgs['orderBy'] }
        : { orderBy?: documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documents model
   */
  readonly fields: documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projets<T extends projetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetsDefaultArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documents model
   */ 
  interface documentsFieldRefs {
    readonly id: FieldRef<"documents", 'Int'>
    readonly project_id: FieldRef<"documents", 'Int'>
    readonly name: FieldRef<"documents", 'String'>
    readonly file_path: FieldRef<"documents", 'String'>
    readonly uploaded_at: FieldRef<"documents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * documents findUnique
   */
  export type documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findUniqueOrThrow
   */
  export type documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findFirst
   */
  export type documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findFirstOrThrow
   */
  export type documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findMany
   */
  export type documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents create
   */
  export type documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * The data needed to create a documents.
     */
    data: XOR<documentsCreateInput, documentsUncheckedCreateInput>
  }

  /**
   * documents createMany
   */
  export type documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documents update
   */
  export type documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * The data needed to update a documents.
     */
    data: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
    /**
     * Choose, which documents to update.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents updateMany
   */
  export type documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documents.
     */
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyInput>
    /**
     * Filter which documents to update
     */
    where?: documentsWhereInput
  }

  /**
   * documents upsert
   */
  export type documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * The filter to search for the documents to update in case it exists.
     */
    where: documentsWhereUniqueInput
    /**
     * In case the documents found by the `where` argument doesn't exist, create a new documents with this data.
     */
    create: XOR<documentsCreateInput, documentsUncheckedCreateInput>
    /**
     * In case the documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
  }

  /**
   * documents delete
   */
  export type documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter which documents to delete.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents deleteMany
   */
  export type documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to delete
     */
    where?: documentsWhereInput
  }

  /**
   * documents without action
   */
  export type documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
  }


  /**
   * Model evaluations
   */

  export type AggregateEvaluations = {
    _count: EvaluationsCountAggregateOutputType | null
    _avg: EvaluationsAvgAggregateOutputType | null
    _sum: EvaluationsSumAggregateOutputType | null
    _min: EvaluationsMinAggregateOutputType | null
    _max: EvaluationsMaxAggregateOutputType | null
  }

  export type EvaluationsAvgAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    value: number | null
  }

  export type EvaluationsSumAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    value: number | null
  }

  export type EvaluationsMinAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    evaluation_date: Date | null
    value: number | null
    comment: string | null
  }

  export type EvaluationsMaxAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    evaluation_date: Date | null
    value: number | null
    comment: string | null
  }

  export type EvaluationsCountAggregateOutputType = {
    id: number
    indicator_id: number
    evaluation_date: number
    value: number
    comment: number
    _all: number
  }


  export type EvaluationsAvgAggregateInputType = {
    id?: true
    indicator_id?: true
    value?: true
  }

  export type EvaluationsSumAggregateInputType = {
    id?: true
    indicator_id?: true
    value?: true
  }

  export type EvaluationsMinAggregateInputType = {
    id?: true
    indicator_id?: true
    evaluation_date?: true
    value?: true
    comment?: true
  }

  export type EvaluationsMaxAggregateInputType = {
    id?: true
    indicator_id?: true
    evaluation_date?: true
    value?: true
    comment?: true
  }

  export type EvaluationsCountAggregateInputType = {
    id?: true
    indicator_id?: true
    evaluation_date?: true
    value?: true
    comment?: true
    _all?: true
  }

  export type EvaluationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evaluations to aggregate.
     */
    where?: evaluationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluations to fetch.
     */
    orderBy?: evaluationsOrderByWithRelationInput | evaluationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: evaluationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned evaluations
    **/
    _count?: true | EvaluationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationsMaxAggregateInputType
  }

  export type GetEvaluationsAggregateType<T extends EvaluationsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluations[P]>
      : GetScalarType<T[P], AggregateEvaluations[P]>
  }




  export type evaluationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: evaluationsWhereInput
    orderBy?: evaluationsOrderByWithAggregationInput | evaluationsOrderByWithAggregationInput[]
    by: EvaluationsScalarFieldEnum[] | EvaluationsScalarFieldEnum
    having?: evaluationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationsCountAggregateInputType | true
    _avg?: EvaluationsAvgAggregateInputType
    _sum?: EvaluationsSumAggregateInputType
    _min?: EvaluationsMinAggregateInputType
    _max?: EvaluationsMaxAggregateInputType
  }

  export type EvaluationsGroupByOutputType = {
    id: number
    indicator_id: number
    evaluation_date: Date | null
    value: number | null
    comment: string | null
    _count: EvaluationsCountAggregateOutputType | null
    _avg: EvaluationsAvgAggregateOutputType | null
    _sum: EvaluationsSumAggregateOutputType | null
    _min: EvaluationsMinAggregateOutputType | null
    _max: EvaluationsMaxAggregateOutputType | null
  }

  type GetEvaluationsGroupByPayload<T extends evaluationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationsGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationsGroupByOutputType[P]>
        }
      >
    >


  export type evaluationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicator_id?: boolean
    evaluation_date?: boolean
    value?: boolean
    comment?: boolean
    indicateurs?: boolean | indicateursDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluations"]>


  export type evaluationsSelectScalar = {
    id?: boolean
    indicator_id?: boolean
    evaluation_date?: boolean
    value?: boolean
    comment?: boolean
  }

  export type evaluationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicateurs?: boolean | indicateursDefaultArgs<ExtArgs>
  }

  export type $evaluationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "evaluations"
    objects: {
      indicateurs: Prisma.$indicateursPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indicator_id: number
      evaluation_date: Date | null
      value: number | null
      comment: string | null
    }, ExtArgs["result"]["evaluations"]>
    composites: {}
  }

  type evaluationsGetPayload<S extends boolean | null | undefined | evaluationsDefaultArgs> = $Result.GetResult<Prisma.$evaluationsPayload, S>

  type evaluationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<evaluationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationsCountAggregateInputType | true
    }

  export interface evaluationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['evaluations'], meta: { name: 'evaluations' } }
    /**
     * Find zero or one Evaluations that matches the filter.
     * @param {evaluationsFindUniqueArgs} args - Arguments to find a Evaluations
     * @example
     * // Get one Evaluations
     * const evaluations = await prisma.evaluations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends evaluationsFindUniqueArgs>(args: SelectSubset<T, evaluationsFindUniqueArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evaluations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {evaluationsFindUniqueOrThrowArgs} args - Arguments to find a Evaluations
     * @example
     * // Get one Evaluations
     * const evaluations = await prisma.evaluations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends evaluationsFindUniqueOrThrowArgs>(args: SelectSubset<T, evaluationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluationsFindFirstArgs} args - Arguments to find a Evaluations
     * @example
     * // Get one Evaluations
     * const evaluations = await prisma.evaluations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends evaluationsFindFirstArgs>(args?: SelectSubset<T, evaluationsFindFirstArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evaluations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluationsFindFirstOrThrowArgs} args - Arguments to find a Evaluations
     * @example
     * // Get one Evaluations
     * const evaluations = await prisma.evaluations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends evaluationsFindFirstOrThrowArgs>(args?: SelectSubset<T, evaluationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluations.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationsWithIdOnly = await prisma.evaluations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends evaluationsFindManyArgs>(args?: SelectSubset<T, evaluationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evaluations.
     * @param {evaluationsCreateArgs} args - Arguments to create a Evaluations.
     * @example
     * // Create one Evaluations
     * const Evaluations = await prisma.evaluations.create({
     *   data: {
     *     // ... data to create a Evaluations
     *   }
     * })
     * 
     */
    create<T extends evaluationsCreateArgs>(args: SelectSubset<T, evaluationsCreateArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evaluations.
     * @param {evaluationsCreateManyArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluations = await prisma.evaluations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends evaluationsCreateManyArgs>(args?: SelectSubset<T, evaluationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evaluations.
     * @param {evaluationsDeleteArgs} args - Arguments to delete one Evaluations.
     * @example
     * // Delete one Evaluations
     * const Evaluations = await prisma.evaluations.delete({
     *   where: {
     *     // ... filter to delete one Evaluations
     *   }
     * })
     * 
     */
    delete<T extends evaluationsDeleteArgs>(args: SelectSubset<T, evaluationsDeleteArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evaluations.
     * @param {evaluationsUpdateArgs} args - Arguments to update one Evaluations.
     * @example
     * // Update one Evaluations
     * const evaluations = await prisma.evaluations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends evaluationsUpdateArgs>(args: SelectSubset<T, evaluationsUpdateArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evaluations.
     * @param {evaluationsDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends evaluationsDeleteManyArgs>(args?: SelectSubset<T, evaluationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluations = await prisma.evaluations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends evaluationsUpdateManyArgs>(args: SelectSubset<T, evaluationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluations.
     * @param {evaluationsUpsertArgs} args - Arguments to update or create a Evaluations.
     * @example
     * // Update or create a Evaluations
     * const evaluations = await prisma.evaluations.upsert({
     *   create: {
     *     // ... data to create a Evaluations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluations we want to update
     *   }
     * })
     */
    upsert<T extends evaluationsUpsertArgs>(args: SelectSubset<T, evaluationsUpsertArgs<ExtArgs>>): Prisma__evaluationsClient<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluationsCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluations.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends evaluationsCountArgs>(
      args?: Subset<T, evaluationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationsAggregateArgs>(args: Subset<T, EvaluationsAggregateArgs>): Prisma.PrismaPromise<GetEvaluationsAggregateType<T>>

    /**
     * Group by Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {evaluationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends evaluationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: evaluationsGroupByArgs['orderBy'] }
        : { orderBy?: evaluationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, evaluationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the evaluations model
   */
  readonly fields: evaluationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for evaluations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__evaluationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicateurs<T extends indicateursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, indicateursDefaultArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the evaluations model
   */ 
  interface evaluationsFieldRefs {
    readonly id: FieldRef<"evaluations", 'Int'>
    readonly indicator_id: FieldRef<"evaluations", 'Int'>
    readonly evaluation_date: FieldRef<"evaluations", 'DateTime'>
    readonly value: FieldRef<"evaluations", 'Float'>
    readonly comment: FieldRef<"evaluations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * evaluations findUnique
   */
  export type evaluationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * Filter, which evaluations to fetch.
     */
    where: evaluationsWhereUniqueInput
  }

  /**
   * evaluations findUniqueOrThrow
   */
  export type evaluationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * Filter, which evaluations to fetch.
     */
    where: evaluationsWhereUniqueInput
  }

  /**
   * evaluations findFirst
   */
  export type evaluationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * Filter, which evaluations to fetch.
     */
    where?: evaluationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluations to fetch.
     */
    orderBy?: evaluationsOrderByWithRelationInput | evaluationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evaluations.
     */
    cursor?: evaluationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evaluations.
     */
    distinct?: EvaluationsScalarFieldEnum | EvaluationsScalarFieldEnum[]
  }

  /**
   * evaluations findFirstOrThrow
   */
  export type evaluationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * Filter, which evaluations to fetch.
     */
    where?: evaluationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluations to fetch.
     */
    orderBy?: evaluationsOrderByWithRelationInput | evaluationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for evaluations.
     */
    cursor?: evaluationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of evaluations.
     */
    distinct?: EvaluationsScalarFieldEnum | EvaluationsScalarFieldEnum[]
  }

  /**
   * evaluations findMany
   */
  export type evaluationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * Filter, which evaluations to fetch.
     */
    where?: evaluationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of evaluations to fetch.
     */
    orderBy?: evaluationsOrderByWithRelationInput | evaluationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing evaluations.
     */
    cursor?: evaluationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` evaluations.
     */
    skip?: number
    distinct?: EvaluationsScalarFieldEnum | EvaluationsScalarFieldEnum[]
  }

  /**
   * evaluations create
   */
  export type evaluationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * The data needed to create a evaluations.
     */
    data: XOR<evaluationsCreateInput, evaluationsUncheckedCreateInput>
  }

  /**
   * evaluations createMany
   */
  export type evaluationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many evaluations.
     */
    data: evaluationsCreateManyInput | evaluationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * evaluations update
   */
  export type evaluationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * The data needed to update a evaluations.
     */
    data: XOR<evaluationsUpdateInput, evaluationsUncheckedUpdateInput>
    /**
     * Choose, which evaluations to update.
     */
    where: evaluationsWhereUniqueInput
  }

  /**
   * evaluations updateMany
   */
  export type evaluationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update evaluations.
     */
    data: XOR<evaluationsUpdateManyMutationInput, evaluationsUncheckedUpdateManyInput>
    /**
     * Filter which evaluations to update
     */
    where?: evaluationsWhereInput
  }

  /**
   * evaluations upsert
   */
  export type evaluationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * The filter to search for the evaluations to update in case it exists.
     */
    where: evaluationsWhereUniqueInput
    /**
     * In case the evaluations found by the `where` argument doesn't exist, create a new evaluations with this data.
     */
    create: XOR<evaluationsCreateInput, evaluationsUncheckedCreateInput>
    /**
     * In case the evaluations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<evaluationsUpdateInput, evaluationsUncheckedUpdateInput>
  }

  /**
   * evaluations delete
   */
  export type evaluationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    /**
     * Filter which evaluations to delete.
     */
    where: evaluationsWhereUniqueInput
  }

  /**
   * evaluations deleteMany
   */
  export type evaluationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which evaluations to delete
     */
    where?: evaluationsWhereInput
  }

  /**
   * evaluations without action
   */
  export type evaluationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
  }


  /**
   * Model groupes
   */

  export type AggregateGroupes = {
    _count: GroupesCountAggregateOutputType | null
    _avg: GroupesAvgAggregateOutputType | null
    _sum: GroupesSumAggregateOutputType | null
    _min: GroupesMinAggregateOutputType | null
    _max: GroupesMaxAggregateOutputType | null
  }

  export type GroupesAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupesSumAggregateOutputType = {
    id: number | null
  }

  export type GroupesMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type GroupesMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type GroupesCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type GroupesAvgAggregateInputType = {
    id?: true
  }

  export type GroupesSumAggregateInputType = {
    id?: true
  }

  export type GroupesMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type GroupesMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type GroupesCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type GroupesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupes to aggregate.
     */
    where?: groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupes to fetch.
     */
    orderBy?: groupesOrderByWithRelationInput | groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groupes
    **/
    _count?: true | GroupesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupesMaxAggregateInputType
  }

  export type GetGroupesAggregateType<T extends GroupesAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupes[P]>
      : GetScalarType<T[P], AggregateGroupes[P]>
  }




  export type groupesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupesWhereInput
    orderBy?: groupesOrderByWithAggregationInput | groupesOrderByWithAggregationInput[]
    by: GroupesScalarFieldEnum[] | GroupesScalarFieldEnum
    having?: groupesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupesCountAggregateInputType | true
    _avg?: GroupesAvgAggregateInputType
    _sum?: GroupesSumAggregateInputType
    _min?: GroupesMinAggregateInputType
    _max?: GroupesMaxAggregateInputType
  }

  export type GroupesGroupByOutputType = {
    id: number
    nom: string
    _count: GroupesCountAggregateOutputType | null
    _avg: GroupesAvgAggregateOutputType | null
    _sum: GroupesSumAggregateOutputType | null
    _min: GroupesMinAggregateOutputType | null
    _max: GroupesMaxAggregateOutputType | null
  }

  type GetGroupesGroupByPayload<T extends groupesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupesGroupByOutputType[P]>
            : GetScalarType<T[P], GroupesGroupByOutputType[P]>
        }
      >
    >


  export type groupesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    projet_groupes?: boolean | groupes$projet_groupesArgs<ExtArgs>
    tache_assignations_groupes?: boolean | groupes$tache_assignations_groupesArgs<ExtArgs>
    groupesUtilisateurs?: boolean | groupes$groupesUtilisateursArgs<ExtArgs>
    Notification?: boolean | groupes$NotificationArgs<ExtArgs>
    _count?: boolean | GroupesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupes"]>


  export type groupesSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type groupesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet_groupes?: boolean | groupes$projet_groupesArgs<ExtArgs>
    tache_assignations_groupes?: boolean | groupes$tache_assignations_groupesArgs<ExtArgs>
    groupesUtilisateurs?: boolean | groupes$groupesUtilisateursArgs<ExtArgs>
    Notification?: boolean | groupes$NotificationArgs<ExtArgs>
    _count?: boolean | GroupesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $groupesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groupes"
    objects: {
      projet_groupes: Prisma.$projet_groupesPayload<ExtArgs>[]
      tache_assignations_groupes: Prisma.$tache_assignations_groupesPayload<ExtArgs>[]
      groupesUtilisateurs: Prisma.$GroupesUtilisateursPayload<ExtArgs>[]
      Notification: Prisma.$notificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["groupes"]>
    composites: {}
  }

  type groupesGetPayload<S extends boolean | null | undefined | groupesDefaultArgs> = $Result.GetResult<Prisma.$groupesPayload, S>

  type groupesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groupesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupesCountAggregateInputType | true
    }

  export interface groupesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groupes'], meta: { name: 'groupes' } }
    /**
     * Find zero or one Groupes that matches the filter.
     * @param {groupesFindUniqueArgs} args - Arguments to find a Groupes
     * @example
     * // Get one Groupes
     * const groupes = await prisma.groupes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupesFindUniqueArgs>(args: SelectSubset<T, groupesFindUniqueArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Groupes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {groupesFindUniqueOrThrowArgs} args - Arguments to find a Groupes
     * @example
     * // Get one Groupes
     * const groupes = await prisma.groupes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupesFindUniqueOrThrowArgs>(args: SelectSubset<T, groupesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupesFindFirstArgs} args - Arguments to find a Groupes
     * @example
     * // Get one Groupes
     * const groupes = await prisma.groupes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupesFindFirstArgs>(args?: SelectSubset<T, groupesFindFirstArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Groupes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupesFindFirstOrThrowArgs} args - Arguments to find a Groupes
     * @example
     * // Get one Groupes
     * const groupes = await prisma.groupes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupesFindFirstOrThrowArgs>(args?: SelectSubset<T, groupesFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groupes
     * const groupes = await prisma.groupes.findMany()
     * 
     * // Get first 10 Groupes
     * const groupes = await prisma.groupes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupesWithIdOnly = await prisma.groupes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupesFindManyArgs>(args?: SelectSubset<T, groupesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Groupes.
     * @param {groupesCreateArgs} args - Arguments to create a Groupes.
     * @example
     * // Create one Groupes
     * const Groupes = await prisma.groupes.create({
     *   data: {
     *     // ... data to create a Groupes
     *   }
     * })
     * 
     */
    create<T extends groupesCreateArgs>(args: SelectSubset<T, groupesCreateArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groupes.
     * @param {groupesCreateManyArgs} args - Arguments to create many Groupes.
     * @example
     * // Create many Groupes
     * const groupes = await prisma.groupes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupesCreateManyArgs>(args?: SelectSubset<T, groupesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groupes.
     * @param {groupesDeleteArgs} args - Arguments to delete one Groupes.
     * @example
     * // Delete one Groupes
     * const Groupes = await prisma.groupes.delete({
     *   where: {
     *     // ... filter to delete one Groupes
     *   }
     * })
     * 
     */
    delete<T extends groupesDeleteArgs>(args: SelectSubset<T, groupesDeleteArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Groupes.
     * @param {groupesUpdateArgs} args - Arguments to update one Groupes.
     * @example
     * // Update one Groupes
     * const groupes = await prisma.groupes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupesUpdateArgs>(args: SelectSubset<T, groupesUpdateArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groupes.
     * @param {groupesDeleteManyArgs} args - Arguments to filter Groupes to delete.
     * @example
     * // Delete a few Groupes
     * const { count } = await prisma.groupes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupesDeleteManyArgs>(args?: SelectSubset<T, groupesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groupes
     * const groupes = await prisma.groupes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupesUpdateManyArgs>(args: SelectSubset<T, groupesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groupes.
     * @param {groupesUpsertArgs} args - Arguments to update or create a Groupes.
     * @example
     * // Update or create a Groupes
     * const groupes = await prisma.groupes.upsert({
     *   create: {
     *     // ... data to create a Groupes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groupes we want to update
     *   }
     * })
     */
    upsert<T extends groupesUpsertArgs>(args: SelectSubset<T, groupesUpsertArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupesCountArgs} args - Arguments to filter Groupes to count.
     * @example
     * // Count the number of Groupes
     * const count = await prisma.groupes.count({
     *   where: {
     *     // ... the filter for the Groupes we want to count
     *   }
     * })
    **/
    count<T extends groupesCountArgs>(
      args?: Subset<T, groupesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupesAggregateArgs>(args: Subset<T, GroupesAggregateArgs>): Prisma.PrismaPromise<GetGroupesAggregateType<T>>

    /**
     * Group by Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupesGroupByArgs['orderBy'] }
        : { orderBy?: groupesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groupes model
   */
  readonly fields: groupesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groupes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projet_groupes<T extends groupes$projet_groupesArgs<ExtArgs> = {}>(args?: Subset<T, groupes$projet_groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "findMany"> | Null>
    tache_assignations_groupes<T extends groupes$tache_assignations_groupesArgs<ExtArgs> = {}>(args?: Subset<T, groupes$tache_assignations_groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "findMany"> | Null>
    groupesUtilisateurs<T extends groupes$groupesUtilisateursArgs<ExtArgs> = {}>(args?: Subset<T, groupes$groupesUtilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "findMany"> | Null>
    Notification<T extends groupes$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, groupes$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the groupes model
   */ 
  interface groupesFieldRefs {
    readonly id: FieldRef<"groupes", 'Int'>
    readonly nom: FieldRef<"groupes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * groupes findUnique
   */
  export type groupesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * Filter, which groupes to fetch.
     */
    where: groupesWhereUniqueInput
  }

  /**
   * groupes findUniqueOrThrow
   */
  export type groupesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * Filter, which groupes to fetch.
     */
    where: groupesWhereUniqueInput
  }

  /**
   * groupes findFirst
   */
  export type groupesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * Filter, which groupes to fetch.
     */
    where?: groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupes to fetch.
     */
    orderBy?: groupesOrderByWithRelationInput | groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupes.
     */
    cursor?: groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupes.
     */
    distinct?: GroupesScalarFieldEnum | GroupesScalarFieldEnum[]
  }

  /**
   * groupes findFirstOrThrow
   */
  export type groupesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * Filter, which groupes to fetch.
     */
    where?: groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupes to fetch.
     */
    orderBy?: groupesOrderByWithRelationInput | groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupes.
     */
    cursor?: groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupes.
     */
    distinct?: GroupesScalarFieldEnum | GroupesScalarFieldEnum[]
  }

  /**
   * groupes findMany
   */
  export type groupesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * Filter, which groupes to fetch.
     */
    where?: groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupes to fetch.
     */
    orderBy?: groupesOrderByWithRelationInput | groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groupes.
     */
    cursor?: groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupes.
     */
    skip?: number
    distinct?: GroupesScalarFieldEnum | GroupesScalarFieldEnum[]
  }

  /**
   * groupes create
   */
  export type groupesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * The data needed to create a groupes.
     */
    data: XOR<groupesCreateInput, groupesUncheckedCreateInput>
  }

  /**
   * groupes createMany
   */
  export type groupesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groupes.
     */
    data: groupesCreateManyInput | groupesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * groupes update
   */
  export type groupesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * The data needed to update a groupes.
     */
    data: XOR<groupesUpdateInput, groupesUncheckedUpdateInput>
    /**
     * Choose, which groupes to update.
     */
    where: groupesWhereUniqueInput
  }

  /**
   * groupes updateMany
   */
  export type groupesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groupes.
     */
    data: XOR<groupesUpdateManyMutationInput, groupesUncheckedUpdateManyInput>
    /**
     * Filter which groupes to update
     */
    where?: groupesWhereInput
  }

  /**
   * groupes upsert
   */
  export type groupesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * The filter to search for the groupes to update in case it exists.
     */
    where: groupesWhereUniqueInput
    /**
     * In case the groupes found by the `where` argument doesn't exist, create a new groupes with this data.
     */
    create: XOR<groupesCreateInput, groupesUncheckedCreateInput>
    /**
     * In case the groupes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupesUpdateInput, groupesUncheckedUpdateInput>
  }

  /**
   * groupes delete
   */
  export type groupesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    /**
     * Filter which groupes to delete.
     */
    where: groupesWhereUniqueInput
  }

  /**
   * groupes deleteMany
   */
  export type groupesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupes to delete
     */
    where?: groupesWhereInput
  }

  /**
   * groupes.projet_groupes
   */
  export type groupes$projet_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    where?: projet_groupesWhereInput
    orderBy?: projet_groupesOrderByWithRelationInput | projet_groupesOrderByWithRelationInput[]
    cursor?: projet_groupesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_groupesScalarFieldEnum | Projet_groupesScalarFieldEnum[]
  }

  /**
   * groupes.tache_assignations_groupes
   */
  export type groupes$tache_assignations_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    where?: tache_assignations_groupesWhereInput
    orderBy?: tache_assignations_groupesOrderByWithRelationInput | tache_assignations_groupesOrderByWithRelationInput[]
    cursor?: tache_assignations_groupesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tache_assignations_groupesScalarFieldEnum | Tache_assignations_groupesScalarFieldEnum[]
  }

  /**
   * groupes.groupesUtilisateurs
   */
  export type groupes$groupesUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    where?: GroupesUtilisateursWhereInput
    orderBy?: GroupesUtilisateursOrderByWithRelationInput | GroupesUtilisateursOrderByWithRelationInput[]
    cursor?: GroupesUtilisateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupesUtilisateursScalarFieldEnum | GroupesUtilisateursScalarFieldEnum[]
  }

  /**
   * groupes.Notification
   */
  export type groupes$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * groupes without action
   */
  export type groupesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
  }


  /**
   * Model indicateurs
   */

  export type AggregateIndicateurs = {
    _count: IndicateursCountAggregateOutputType | null
    _avg: IndicateursAvgAggregateOutputType | null
    _sum: IndicateursSumAggregateOutputType | null
    _min: IndicateursMinAggregateOutputType | null
    _max: IndicateursMaxAggregateOutputType | null
  }

  export type IndicateursAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
    baseline_value: number | null
    target_value: number | null
    current_value: number | null
    latitude: number | null
    longitude: number | null
  }

  export type IndicateursSumAggregateOutputType = {
    id: number | null
    project_id: number | null
    baseline_value: number | null
    target_value: number | null
    current_value: number | null
    latitude: number | null
    longitude: number | null
  }

  export type IndicateursMinAggregateOutputType = {
    id: number | null
    project_id: number | null
    name: string | null
    description: string | null
    unit: string | null
    baseline_value: number | null
    target_value: number | null
    current_value: number | null
    latitude: number | null
    longitude: number | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type IndicateursMaxAggregateOutputType = {
    id: number | null
    project_id: number | null
    name: string | null
    description: string | null
    unit: string | null
    baseline_value: number | null
    target_value: number | null
    current_value: number | null
    latitude: number | null
    longitude: number | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type IndicateursCountAggregateOutputType = {
    id: number
    project_id: number
    name: number
    description: number
    unit: number
    baseline_value: number
    target_value: number
    current_value: number
    latitude: number
    longitude: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type IndicateursAvgAggregateInputType = {
    id?: true
    project_id?: true
    baseline_value?: true
    target_value?: true
    current_value?: true
    latitude?: true
    longitude?: true
  }

  export type IndicateursSumAggregateInputType = {
    id?: true
    project_id?: true
    baseline_value?: true
    target_value?: true
    current_value?: true
    latitude?: true
    longitude?: true
  }

  export type IndicateursMinAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    description?: true
    unit?: true
    baseline_value?: true
    target_value?: true
    current_value?: true
    latitude?: true
    longitude?: true
    created_date?: true
    last_updated?: true
  }

  export type IndicateursMaxAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    description?: true
    unit?: true
    baseline_value?: true
    target_value?: true
    current_value?: true
    latitude?: true
    longitude?: true
    created_date?: true
    last_updated?: true
  }

  export type IndicateursCountAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    description?: true
    unit?: true
    baseline_value?: true
    target_value?: true
    current_value?: true
    latitude?: true
    longitude?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type IndicateursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which indicateurs to aggregate.
     */
    where?: indicateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicateurs to fetch.
     */
    orderBy?: indicateursOrderByWithRelationInput | indicateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: indicateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned indicateurs
    **/
    _count?: true | IndicateursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicateursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicateursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicateursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicateursMaxAggregateInputType
  }

  export type GetIndicateursAggregateType<T extends IndicateursAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicateurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicateurs[P]>
      : GetScalarType<T[P], AggregateIndicateurs[P]>
  }




  export type indicateursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: indicateursWhereInput
    orderBy?: indicateursOrderByWithAggregationInput | indicateursOrderByWithAggregationInput[]
    by: IndicateursScalarFieldEnum[] | IndicateursScalarFieldEnum
    having?: indicateursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicateursCountAggregateInputType | true
    _avg?: IndicateursAvgAggregateInputType
    _sum?: IndicateursSumAggregateInputType
    _min?: IndicateursMinAggregateInputType
    _max?: IndicateursMaxAggregateInputType
  }

  export type IndicateursGroupByOutputType = {
    id: number
    project_id: number
    name: string
    description: string | null
    unit: string | null
    baseline_value: number | null
    target_value: number | null
    current_value: number | null
    latitude: number | null
    longitude: number | null
    created_date: Date
    last_updated: Date
    _count: IndicateursCountAggregateOutputType | null
    _avg: IndicateursAvgAggregateOutputType | null
    _sum: IndicateursSumAggregateOutputType | null
    _min: IndicateursMinAggregateOutputType | null
    _max: IndicateursMaxAggregateOutputType | null
  }

  type GetIndicateursGroupByPayload<T extends indicateursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicateursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicateursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicateursGroupByOutputType[P]>
            : GetScalarType<T[P], IndicateursGroupByOutputType[P]>
        }
      >
    >


  export type indicateursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    baseline_value?: boolean
    target_value?: boolean
    current_value?: boolean
    latitude?: boolean
    longitude?: boolean
    created_date?: boolean
    last_updated?: boolean
    evaluations?: boolean | indicateurs$evaluationsArgs<ExtArgs>
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    _count?: boolean | IndicateursCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicateurs"]>


  export type indicateursSelectScalar = {
    id?: boolean
    project_id?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    baseline_value?: boolean
    target_value?: boolean
    current_value?: boolean
    latitude?: boolean
    longitude?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type indicateursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | indicateurs$evaluationsArgs<ExtArgs>
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    _count?: boolean | IndicateursCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $indicateursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "indicateurs"
    objects: {
      evaluations: Prisma.$evaluationsPayload<ExtArgs>[]
      projets: Prisma.$projetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      project_id: number
      name: string
      description: string | null
      unit: string | null
      baseline_value: number | null
      target_value: number | null
      current_value: number | null
      latitude: number | null
      longitude: number | null
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["indicateurs"]>
    composites: {}
  }

  type indicateursGetPayload<S extends boolean | null | undefined | indicateursDefaultArgs> = $Result.GetResult<Prisma.$indicateursPayload, S>

  type indicateursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<indicateursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicateursCountAggregateInputType | true
    }

  export interface indicateursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['indicateurs'], meta: { name: 'indicateurs' } }
    /**
     * Find zero or one Indicateurs that matches the filter.
     * @param {indicateursFindUniqueArgs} args - Arguments to find a Indicateurs
     * @example
     * // Get one Indicateurs
     * const indicateurs = await prisma.indicateurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends indicateursFindUniqueArgs>(args: SelectSubset<T, indicateursFindUniqueArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Indicateurs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {indicateursFindUniqueOrThrowArgs} args - Arguments to find a Indicateurs
     * @example
     * // Get one Indicateurs
     * const indicateurs = await prisma.indicateurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends indicateursFindUniqueOrThrowArgs>(args: SelectSubset<T, indicateursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Indicateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicateursFindFirstArgs} args - Arguments to find a Indicateurs
     * @example
     * // Get one Indicateurs
     * const indicateurs = await prisma.indicateurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends indicateursFindFirstArgs>(args?: SelectSubset<T, indicateursFindFirstArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Indicateurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicateursFindFirstOrThrowArgs} args - Arguments to find a Indicateurs
     * @example
     * // Get one Indicateurs
     * const indicateurs = await prisma.indicateurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends indicateursFindFirstOrThrowArgs>(args?: SelectSubset<T, indicateursFindFirstOrThrowArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Indicateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicateursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicateurs
     * const indicateurs = await prisma.indicateurs.findMany()
     * 
     * // Get first 10 Indicateurs
     * const indicateurs = await prisma.indicateurs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicateursWithIdOnly = await prisma.indicateurs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends indicateursFindManyArgs>(args?: SelectSubset<T, indicateursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Indicateurs.
     * @param {indicateursCreateArgs} args - Arguments to create a Indicateurs.
     * @example
     * // Create one Indicateurs
     * const Indicateurs = await prisma.indicateurs.create({
     *   data: {
     *     // ... data to create a Indicateurs
     *   }
     * })
     * 
     */
    create<T extends indicateursCreateArgs>(args: SelectSubset<T, indicateursCreateArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Indicateurs.
     * @param {indicateursCreateManyArgs} args - Arguments to create many Indicateurs.
     * @example
     * // Create many Indicateurs
     * const indicateurs = await prisma.indicateurs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends indicateursCreateManyArgs>(args?: SelectSubset<T, indicateursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Indicateurs.
     * @param {indicateursDeleteArgs} args - Arguments to delete one Indicateurs.
     * @example
     * // Delete one Indicateurs
     * const Indicateurs = await prisma.indicateurs.delete({
     *   where: {
     *     // ... filter to delete one Indicateurs
     *   }
     * })
     * 
     */
    delete<T extends indicateursDeleteArgs>(args: SelectSubset<T, indicateursDeleteArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Indicateurs.
     * @param {indicateursUpdateArgs} args - Arguments to update one Indicateurs.
     * @example
     * // Update one Indicateurs
     * const indicateurs = await prisma.indicateurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends indicateursUpdateArgs>(args: SelectSubset<T, indicateursUpdateArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Indicateurs.
     * @param {indicateursDeleteManyArgs} args - Arguments to filter Indicateurs to delete.
     * @example
     * // Delete a few Indicateurs
     * const { count } = await prisma.indicateurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends indicateursDeleteManyArgs>(args?: SelectSubset<T, indicateursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicateursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicateurs
     * const indicateurs = await prisma.indicateurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends indicateursUpdateManyArgs>(args: SelectSubset<T, indicateursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Indicateurs.
     * @param {indicateursUpsertArgs} args - Arguments to update or create a Indicateurs.
     * @example
     * // Update or create a Indicateurs
     * const indicateurs = await prisma.indicateurs.upsert({
     *   create: {
     *     // ... data to create a Indicateurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicateurs we want to update
     *   }
     * })
     */
    upsert<T extends indicateursUpsertArgs>(args: SelectSubset<T, indicateursUpsertArgs<ExtArgs>>): Prisma__indicateursClient<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Indicateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicateursCountArgs} args - Arguments to filter Indicateurs to count.
     * @example
     * // Count the number of Indicateurs
     * const count = await prisma.indicateurs.count({
     *   where: {
     *     // ... the filter for the Indicateurs we want to count
     *   }
     * })
    **/
    count<T extends indicateursCountArgs>(
      args?: Subset<T, indicateursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicateursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicateursAggregateArgs>(args: Subset<T, IndicateursAggregateArgs>): Prisma.PrismaPromise<GetIndicateursAggregateType<T>>

    /**
     * Group by Indicateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicateursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends indicateursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: indicateursGroupByArgs['orderBy'] }
        : { orderBy?: indicateursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, indicateursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicateursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the indicateurs model
   */
  readonly fields: indicateursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for indicateurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__indicateursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluations<T extends indicateurs$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, indicateurs$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$evaluationsPayload<ExtArgs>, T, "findMany"> | Null>
    projets<T extends projetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetsDefaultArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the indicateurs model
   */ 
  interface indicateursFieldRefs {
    readonly id: FieldRef<"indicateurs", 'Int'>
    readonly project_id: FieldRef<"indicateurs", 'Int'>
    readonly name: FieldRef<"indicateurs", 'String'>
    readonly description: FieldRef<"indicateurs", 'String'>
    readonly unit: FieldRef<"indicateurs", 'String'>
    readonly baseline_value: FieldRef<"indicateurs", 'Float'>
    readonly target_value: FieldRef<"indicateurs", 'Float'>
    readonly current_value: FieldRef<"indicateurs", 'Float'>
    readonly latitude: FieldRef<"indicateurs", 'Float'>
    readonly longitude: FieldRef<"indicateurs", 'Float'>
    readonly created_date: FieldRef<"indicateurs", 'DateTime'>
    readonly last_updated: FieldRef<"indicateurs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * indicateurs findUnique
   */
  export type indicateursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * Filter, which indicateurs to fetch.
     */
    where: indicateursWhereUniqueInput
  }

  /**
   * indicateurs findUniqueOrThrow
   */
  export type indicateursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * Filter, which indicateurs to fetch.
     */
    where: indicateursWhereUniqueInput
  }

  /**
   * indicateurs findFirst
   */
  export type indicateursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * Filter, which indicateurs to fetch.
     */
    where?: indicateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicateurs to fetch.
     */
    orderBy?: indicateursOrderByWithRelationInput | indicateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for indicateurs.
     */
    cursor?: indicateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of indicateurs.
     */
    distinct?: IndicateursScalarFieldEnum | IndicateursScalarFieldEnum[]
  }

  /**
   * indicateurs findFirstOrThrow
   */
  export type indicateursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * Filter, which indicateurs to fetch.
     */
    where?: indicateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicateurs to fetch.
     */
    orderBy?: indicateursOrderByWithRelationInput | indicateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for indicateurs.
     */
    cursor?: indicateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of indicateurs.
     */
    distinct?: IndicateursScalarFieldEnum | IndicateursScalarFieldEnum[]
  }

  /**
   * indicateurs findMany
   */
  export type indicateursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * Filter, which indicateurs to fetch.
     */
    where?: indicateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicateurs to fetch.
     */
    orderBy?: indicateursOrderByWithRelationInput | indicateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing indicateurs.
     */
    cursor?: indicateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicateurs.
     */
    skip?: number
    distinct?: IndicateursScalarFieldEnum | IndicateursScalarFieldEnum[]
  }

  /**
   * indicateurs create
   */
  export type indicateursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * The data needed to create a indicateurs.
     */
    data: XOR<indicateursCreateInput, indicateursUncheckedCreateInput>
  }

  /**
   * indicateurs createMany
   */
  export type indicateursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many indicateurs.
     */
    data: indicateursCreateManyInput | indicateursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * indicateurs update
   */
  export type indicateursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * The data needed to update a indicateurs.
     */
    data: XOR<indicateursUpdateInput, indicateursUncheckedUpdateInput>
    /**
     * Choose, which indicateurs to update.
     */
    where: indicateursWhereUniqueInput
  }

  /**
   * indicateurs updateMany
   */
  export type indicateursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update indicateurs.
     */
    data: XOR<indicateursUpdateManyMutationInput, indicateursUncheckedUpdateManyInput>
    /**
     * Filter which indicateurs to update
     */
    where?: indicateursWhereInput
  }

  /**
   * indicateurs upsert
   */
  export type indicateursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * The filter to search for the indicateurs to update in case it exists.
     */
    where: indicateursWhereUniqueInput
    /**
     * In case the indicateurs found by the `where` argument doesn't exist, create a new indicateurs with this data.
     */
    create: XOR<indicateursCreateInput, indicateursUncheckedCreateInput>
    /**
     * In case the indicateurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<indicateursUpdateInput, indicateursUncheckedUpdateInput>
  }

  /**
   * indicateurs delete
   */
  export type indicateursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    /**
     * Filter which indicateurs to delete.
     */
    where: indicateursWhereUniqueInput
  }

  /**
   * indicateurs deleteMany
   */
  export type indicateursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which indicateurs to delete
     */
    where?: indicateursWhereInput
  }

  /**
   * indicateurs.evaluations
   */
  export type indicateurs$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the evaluations
     */
    select?: evaluationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: evaluationsInclude<ExtArgs> | null
    where?: evaluationsWhereInput
    orderBy?: evaluationsOrderByWithRelationInput | evaluationsOrderByWithRelationInput[]
    cursor?: evaluationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationsScalarFieldEnum | EvaluationsScalarFieldEnum[]
  }

  /**
   * indicateurs without action
   */
  export type indicateursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
  }


  /**
   * Model GroupesUtilisateurs
   */

  export type AggregateGroupesUtilisateurs = {
    _count: GroupesUtilisateursCountAggregateOutputType | null
    _avg: GroupesUtilisateursAvgAggregateOutputType | null
    _sum: GroupesUtilisateursSumAggregateOutputType | null
    _min: GroupesUtilisateursMinAggregateOutputType | null
    _max: GroupesUtilisateursMaxAggregateOutputType | null
  }

  export type GroupesUtilisateursAvgAggregateOutputType = {
    groupe_id: number | null
    utilisateur_id: number | null
  }

  export type GroupesUtilisateursSumAggregateOutputType = {
    groupe_id: number | null
    utilisateur_id: number | null
  }

  export type GroupesUtilisateursMinAggregateOutputType = {
    groupe_id: number | null
    utilisateur_id: number | null
  }

  export type GroupesUtilisateursMaxAggregateOutputType = {
    groupe_id: number | null
    utilisateur_id: number | null
  }

  export type GroupesUtilisateursCountAggregateOutputType = {
    groupe_id: number
    utilisateur_id: number
    _all: number
  }


  export type GroupesUtilisateursAvgAggregateInputType = {
    groupe_id?: true
    utilisateur_id?: true
  }

  export type GroupesUtilisateursSumAggregateInputType = {
    groupe_id?: true
    utilisateur_id?: true
  }

  export type GroupesUtilisateursMinAggregateInputType = {
    groupe_id?: true
    utilisateur_id?: true
  }

  export type GroupesUtilisateursMaxAggregateInputType = {
    groupe_id?: true
    utilisateur_id?: true
  }

  export type GroupesUtilisateursCountAggregateInputType = {
    groupe_id?: true
    utilisateur_id?: true
    _all?: true
  }

  export type GroupesUtilisateursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupesUtilisateurs to aggregate.
     */
    where?: GroupesUtilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupesUtilisateurs to fetch.
     */
    orderBy?: GroupesUtilisateursOrderByWithRelationInput | GroupesUtilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupesUtilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupesUtilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupesUtilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupesUtilisateurs
    **/
    _count?: true | GroupesUtilisateursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupesUtilisateursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupesUtilisateursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupesUtilisateursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupesUtilisateursMaxAggregateInputType
  }

  export type GetGroupesUtilisateursAggregateType<T extends GroupesUtilisateursAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupesUtilisateurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupesUtilisateurs[P]>
      : GetScalarType<T[P], AggregateGroupesUtilisateurs[P]>
  }




  export type GroupesUtilisateursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupesUtilisateursWhereInput
    orderBy?: GroupesUtilisateursOrderByWithAggregationInput | GroupesUtilisateursOrderByWithAggregationInput[]
    by: GroupesUtilisateursScalarFieldEnum[] | GroupesUtilisateursScalarFieldEnum
    having?: GroupesUtilisateursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupesUtilisateursCountAggregateInputType | true
    _avg?: GroupesUtilisateursAvgAggregateInputType
    _sum?: GroupesUtilisateursSumAggregateInputType
    _min?: GroupesUtilisateursMinAggregateInputType
    _max?: GroupesUtilisateursMaxAggregateInputType
  }

  export type GroupesUtilisateursGroupByOutputType = {
    groupe_id: number
    utilisateur_id: number
    _count: GroupesUtilisateursCountAggregateOutputType | null
    _avg: GroupesUtilisateursAvgAggregateOutputType | null
    _sum: GroupesUtilisateursSumAggregateOutputType | null
    _min: GroupesUtilisateursMinAggregateOutputType | null
    _max: GroupesUtilisateursMaxAggregateOutputType | null
  }

  type GetGroupesUtilisateursGroupByPayload<T extends GroupesUtilisateursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupesUtilisateursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupesUtilisateursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupesUtilisateursGroupByOutputType[P]>
            : GetScalarType<T[P], GroupesUtilisateursGroupByOutputType[P]>
        }
      >
    >


  export type GroupesUtilisateursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupe_id?: boolean
    utilisateur_id?: boolean
    groupes?: boolean | groupesDefaultArgs<ExtArgs>
    utilisateurs?: boolean | utilisateursDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupesUtilisateurs"]>


  export type GroupesUtilisateursSelectScalar = {
    groupe_id?: boolean
    utilisateur_id?: boolean
  }

  export type GroupesUtilisateursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupes?: boolean | groupesDefaultArgs<ExtArgs>
    utilisateurs?: boolean | utilisateursDefaultArgs<ExtArgs>
  }

  export type $GroupesUtilisateursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupesUtilisateurs"
    objects: {
      groupes: Prisma.$groupesPayload<ExtArgs>
      utilisateurs: Prisma.$utilisateursPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      groupe_id: number
      utilisateur_id: number
    }, ExtArgs["result"]["groupesUtilisateurs"]>
    composites: {}
  }

  type GroupesUtilisateursGetPayload<S extends boolean | null | undefined | GroupesUtilisateursDefaultArgs> = $Result.GetResult<Prisma.$GroupesUtilisateursPayload, S>

  type GroupesUtilisateursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupesUtilisateursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupesUtilisateursCountAggregateInputType | true
    }

  export interface GroupesUtilisateursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupesUtilisateurs'], meta: { name: 'GroupesUtilisateurs' } }
    /**
     * Find zero or one GroupesUtilisateurs that matches the filter.
     * @param {GroupesUtilisateursFindUniqueArgs} args - Arguments to find a GroupesUtilisateurs
     * @example
     * // Get one GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupesUtilisateursFindUniqueArgs>(args: SelectSubset<T, GroupesUtilisateursFindUniqueArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupesUtilisateurs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupesUtilisateursFindUniqueOrThrowArgs} args - Arguments to find a GroupesUtilisateurs
     * @example
     * // Get one GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupesUtilisateursFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupesUtilisateursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupesUtilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesUtilisateursFindFirstArgs} args - Arguments to find a GroupesUtilisateurs
     * @example
     * // Get one GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupesUtilisateursFindFirstArgs>(args?: SelectSubset<T, GroupesUtilisateursFindFirstArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupesUtilisateurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesUtilisateursFindFirstOrThrowArgs} args - Arguments to find a GroupesUtilisateurs
     * @example
     * // Get one GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupesUtilisateursFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupesUtilisateursFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupesUtilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesUtilisateursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.findMany()
     * 
     * // Get first 10 GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.findMany({ take: 10 })
     * 
     * // Only select the `groupe_id`
     * const groupesUtilisateursWithGroupe_idOnly = await prisma.groupesUtilisateurs.findMany({ select: { groupe_id: true } })
     * 
     */
    findMany<T extends GroupesUtilisateursFindManyArgs>(args?: SelectSubset<T, GroupesUtilisateursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupesUtilisateurs.
     * @param {GroupesUtilisateursCreateArgs} args - Arguments to create a GroupesUtilisateurs.
     * @example
     * // Create one GroupesUtilisateurs
     * const GroupesUtilisateurs = await prisma.groupesUtilisateurs.create({
     *   data: {
     *     // ... data to create a GroupesUtilisateurs
     *   }
     * })
     * 
     */
    create<T extends GroupesUtilisateursCreateArgs>(args: SelectSubset<T, GroupesUtilisateursCreateArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupesUtilisateurs.
     * @param {GroupesUtilisateursCreateManyArgs} args - Arguments to create many GroupesUtilisateurs.
     * @example
     * // Create many GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupesUtilisateursCreateManyArgs>(args?: SelectSubset<T, GroupesUtilisateursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupesUtilisateurs.
     * @param {GroupesUtilisateursDeleteArgs} args - Arguments to delete one GroupesUtilisateurs.
     * @example
     * // Delete one GroupesUtilisateurs
     * const GroupesUtilisateurs = await prisma.groupesUtilisateurs.delete({
     *   where: {
     *     // ... filter to delete one GroupesUtilisateurs
     *   }
     * })
     * 
     */
    delete<T extends GroupesUtilisateursDeleteArgs>(args: SelectSubset<T, GroupesUtilisateursDeleteArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupesUtilisateurs.
     * @param {GroupesUtilisateursUpdateArgs} args - Arguments to update one GroupesUtilisateurs.
     * @example
     * // Update one GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupesUtilisateursUpdateArgs>(args: SelectSubset<T, GroupesUtilisateursUpdateArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupesUtilisateurs.
     * @param {GroupesUtilisateursDeleteManyArgs} args - Arguments to filter GroupesUtilisateurs to delete.
     * @example
     * // Delete a few GroupesUtilisateurs
     * const { count } = await prisma.groupesUtilisateurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupesUtilisateursDeleteManyArgs>(args?: SelectSubset<T, GroupesUtilisateursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupesUtilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesUtilisateursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupesUtilisateursUpdateManyArgs>(args: SelectSubset<T, GroupesUtilisateursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupesUtilisateurs.
     * @param {GroupesUtilisateursUpsertArgs} args - Arguments to update or create a GroupesUtilisateurs.
     * @example
     * // Update or create a GroupesUtilisateurs
     * const groupesUtilisateurs = await prisma.groupesUtilisateurs.upsert({
     *   create: {
     *     // ... data to create a GroupesUtilisateurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupesUtilisateurs we want to update
     *   }
     * })
     */
    upsert<T extends GroupesUtilisateursUpsertArgs>(args: SelectSubset<T, GroupesUtilisateursUpsertArgs<ExtArgs>>): Prisma__GroupesUtilisateursClient<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupesUtilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesUtilisateursCountArgs} args - Arguments to filter GroupesUtilisateurs to count.
     * @example
     * // Count the number of GroupesUtilisateurs
     * const count = await prisma.groupesUtilisateurs.count({
     *   where: {
     *     // ... the filter for the GroupesUtilisateurs we want to count
     *   }
     * })
    **/
    count<T extends GroupesUtilisateursCountArgs>(
      args?: Subset<T, GroupesUtilisateursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupesUtilisateursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupesUtilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesUtilisateursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupesUtilisateursAggregateArgs>(args: Subset<T, GroupesUtilisateursAggregateArgs>): Prisma.PrismaPromise<GetGroupesUtilisateursAggregateType<T>>

    /**
     * Group by GroupesUtilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupesUtilisateursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupesUtilisateursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupesUtilisateursGroupByArgs['orderBy'] }
        : { orderBy?: GroupesUtilisateursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupesUtilisateursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupesUtilisateursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupesUtilisateurs model
   */
  readonly fields: GroupesUtilisateursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupesUtilisateurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupesUtilisateursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupes<T extends groupesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupesDefaultArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    utilisateurs<T extends utilisateursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, utilisateursDefaultArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupesUtilisateurs model
   */ 
  interface GroupesUtilisateursFieldRefs {
    readonly groupe_id: FieldRef<"GroupesUtilisateurs", 'Int'>
    readonly utilisateur_id: FieldRef<"GroupesUtilisateurs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GroupesUtilisateurs findUnique
   */
  export type GroupesUtilisateursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * Filter, which GroupesUtilisateurs to fetch.
     */
    where: GroupesUtilisateursWhereUniqueInput
  }

  /**
   * GroupesUtilisateurs findUniqueOrThrow
   */
  export type GroupesUtilisateursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * Filter, which GroupesUtilisateurs to fetch.
     */
    where: GroupesUtilisateursWhereUniqueInput
  }

  /**
   * GroupesUtilisateurs findFirst
   */
  export type GroupesUtilisateursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * Filter, which GroupesUtilisateurs to fetch.
     */
    where?: GroupesUtilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupesUtilisateurs to fetch.
     */
    orderBy?: GroupesUtilisateursOrderByWithRelationInput | GroupesUtilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupesUtilisateurs.
     */
    cursor?: GroupesUtilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupesUtilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupesUtilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupesUtilisateurs.
     */
    distinct?: GroupesUtilisateursScalarFieldEnum | GroupesUtilisateursScalarFieldEnum[]
  }

  /**
   * GroupesUtilisateurs findFirstOrThrow
   */
  export type GroupesUtilisateursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * Filter, which GroupesUtilisateurs to fetch.
     */
    where?: GroupesUtilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupesUtilisateurs to fetch.
     */
    orderBy?: GroupesUtilisateursOrderByWithRelationInput | GroupesUtilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupesUtilisateurs.
     */
    cursor?: GroupesUtilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupesUtilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupesUtilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupesUtilisateurs.
     */
    distinct?: GroupesUtilisateursScalarFieldEnum | GroupesUtilisateursScalarFieldEnum[]
  }

  /**
   * GroupesUtilisateurs findMany
   */
  export type GroupesUtilisateursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * Filter, which GroupesUtilisateurs to fetch.
     */
    where?: GroupesUtilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupesUtilisateurs to fetch.
     */
    orderBy?: GroupesUtilisateursOrderByWithRelationInput | GroupesUtilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupesUtilisateurs.
     */
    cursor?: GroupesUtilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupesUtilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupesUtilisateurs.
     */
    skip?: number
    distinct?: GroupesUtilisateursScalarFieldEnum | GroupesUtilisateursScalarFieldEnum[]
  }

  /**
   * GroupesUtilisateurs create
   */
  export type GroupesUtilisateursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupesUtilisateurs.
     */
    data: XOR<GroupesUtilisateursCreateInput, GroupesUtilisateursUncheckedCreateInput>
  }

  /**
   * GroupesUtilisateurs createMany
   */
  export type GroupesUtilisateursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupesUtilisateurs.
     */
    data: GroupesUtilisateursCreateManyInput | GroupesUtilisateursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupesUtilisateurs update
   */
  export type GroupesUtilisateursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupesUtilisateurs.
     */
    data: XOR<GroupesUtilisateursUpdateInput, GroupesUtilisateursUncheckedUpdateInput>
    /**
     * Choose, which GroupesUtilisateurs to update.
     */
    where: GroupesUtilisateursWhereUniqueInput
  }

  /**
   * GroupesUtilisateurs updateMany
   */
  export type GroupesUtilisateursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupesUtilisateurs.
     */
    data: XOR<GroupesUtilisateursUpdateManyMutationInput, GroupesUtilisateursUncheckedUpdateManyInput>
    /**
     * Filter which GroupesUtilisateurs to update
     */
    where?: GroupesUtilisateursWhereInput
  }

  /**
   * GroupesUtilisateurs upsert
   */
  export type GroupesUtilisateursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupesUtilisateurs to update in case it exists.
     */
    where: GroupesUtilisateursWhereUniqueInput
    /**
     * In case the GroupesUtilisateurs found by the `where` argument doesn't exist, create a new GroupesUtilisateurs with this data.
     */
    create: XOR<GroupesUtilisateursCreateInput, GroupesUtilisateursUncheckedCreateInput>
    /**
     * In case the GroupesUtilisateurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupesUtilisateursUpdateInput, GroupesUtilisateursUncheckedUpdateInput>
  }

  /**
   * GroupesUtilisateurs delete
   */
  export type GroupesUtilisateursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    /**
     * Filter which GroupesUtilisateurs to delete.
     */
    where: GroupesUtilisateursWhereUniqueInput
  }

  /**
   * GroupesUtilisateurs deleteMany
   */
  export type GroupesUtilisateursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupesUtilisateurs to delete
     */
    where?: GroupesUtilisateursWhereInput
  }

  /**
   * GroupesUtilisateurs without action
   */
  export type GroupesUtilisateursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
  }


  /**
   * Model newsletter
   */

  export type AggregateNewsletter = {
    _count: NewsletterCountAggregateOutputType | null
    _avg: NewsletterAvgAggregateOutputType | null
    _sum: NewsletterSumAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  export type NewsletterAvgAggregateOutputType = {
    id: number | null
    posted_by: number | null
  }

  export type NewsletterSumAggregateOutputType = {
    id: number | null
    posted_by: number | null
  }

  export type NewsletterMinAggregateOutputType = {
    id: number | null
    title: string | null
    body: string | null
    posted_by: number | null
    created_date: Date | null
    last_updated: Date | null
    newsletter_statut: string | null
  }

  export type NewsletterMaxAggregateOutputType = {
    id: number | null
    title: string | null
    body: string | null
    posted_by: number | null
    created_date: Date | null
    last_updated: Date | null
    newsletter_statut: string | null
  }

  export type NewsletterCountAggregateOutputType = {
    id: number
    title: number
    body: number
    posted_by: number
    created_date: number
    last_updated: number
    newsletter_statut: number
    _all: number
  }


  export type NewsletterAvgAggregateInputType = {
    id?: true
    posted_by?: true
  }

  export type NewsletterSumAggregateInputType = {
    id?: true
    posted_by?: true
  }

  export type NewsletterMinAggregateInputType = {
    id?: true
    title?: true
    body?: true
    posted_by?: true
    created_date?: true
    last_updated?: true
    newsletter_statut?: true
  }

  export type NewsletterMaxAggregateInputType = {
    id?: true
    title?: true
    body?: true
    posted_by?: true
    created_date?: true
    last_updated?: true
    newsletter_statut?: true
  }

  export type NewsletterCountAggregateInputType = {
    id?: true
    title?: true
    body?: true
    posted_by?: true
    created_date?: true
    last_updated?: true
    newsletter_statut?: true
    _all?: true
  }

  export type NewsletterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter to aggregate.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned newsletters
    **/
    _count?: true | NewsletterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsletterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsletterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterMaxAggregateInputType
  }

  export type GetNewsletterAggregateType<T extends NewsletterAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter[P]>
      : GetScalarType<T[P], AggregateNewsletter[P]>
  }




  export type newsletterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletterWhereInput
    orderBy?: newsletterOrderByWithAggregationInput | newsletterOrderByWithAggregationInput[]
    by: NewsletterScalarFieldEnum[] | NewsletterScalarFieldEnum
    having?: newsletterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterCountAggregateInputType | true
    _avg?: NewsletterAvgAggregateInputType
    _sum?: NewsletterSumAggregateInputType
    _min?: NewsletterMinAggregateInputType
    _max?: NewsletterMaxAggregateInputType
  }

  export type NewsletterGroupByOutputType = {
    id: number
    title: string | null
    body: string
    posted_by: number
    created_date: Date
    last_updated: Date
    newsletter_statut: string
    _count: NewsletterCountAggregateOutputType | null
    _avg: NewsletterAvgAggregateOutputType | null
    _sum: NewsletterSumAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  type GetNewsletterGroupByPayload<T extends newsletterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
        }
      >
    >


  export type newsletterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    posted_by?: boolean
    created_date?: boolean
    last_updated?: boolean
    newsletter_statut?: boolean
  }, ExtArgs["result"]["newsletter"]>


  export type newsletterSelectScalar = {
    id?: boolean
    title?: boolean
    body?: boolean
    posted_by?: boolean
    created_date?: boolean
    last_updated?: boolean
    newsletter_statut?: boolean
  }


  export type $newsletterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "newsletter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      body: string
      posted_by: number
      created_date: Date
      last_updated: Date
      newsletter_statut: string
    }, ExtArgs["result"]["newsletter"]>
    composites: {}
  }

  type newsletterGetPayload<S extends boolean | null | undefined | newsletterDefaultArgs> = $Result.GetResult<Prisma.$newsletterPayload, S>

  type newsletterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<newsletterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsletterCountAggregateInputType | true
    }

  export interface newsletterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['newsletter'], meta: { name: 'newsletter' } }
    /**
     * Find zero or one Newsletter that matches the filter.
     * @param {newsletterFindUniqueArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsletterFindUniqueArgs>(args: SelectSubset<T, newsletterFindUniqueArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Newsletter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {newsletterFindUniqueOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsletterFindUniqueOrThrowArgs>(args: SelectSubset<T, newsletterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Newsletter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterFindFirstArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsletterFindFirstArgs>(args?: SelectSubset<T, newsletterFindFirstArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Newsletter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterFindFirstOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsletterFindFirstOrThrowArgs>(args?: SelectSubset<T, newsletterFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Newsletters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletters
     * const newsletters = await prisma.newsletter.findMany()
     * 
     * // Get first 10 Newsletters
     * const newsletters = await prisma.newsletter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterWithIdOnly = await prisma.newsletter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends newsletterFindManyArgs>(args?: SelectSubset<T, newsletterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Newsletter.
     * @param {newsletterCreateArgs} args - Arguments to create a Newsletter.
     * @example
     * // Create one Newsletter
     * const Newsletter = await prisma.newsletter.create({
     *   data: {
     *     // ... data to create a Newsletter
     *   }
     * })
     * 
     */
    create<T extends newsletterCreateArgs>(args: SelectSubset<T, newsletterCreateArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Newsletters.
     * @param {newsletterCreateManyArgs} args - Arguments to create many Newsletters.
     * @example
     * // Create many Newsletters
     * const newsletter = await prisma.newsletter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsletterCreateManyArgs>(args?: SelectSubset<T, newsletterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Newsletter.
     * @param {newsletterDeleteArgs} args - Arguments to delete one Newsletter.
     * @example
     * // Delete one Newsletter
     * const Newsletter = await prisma.newsletter.delete({
     *   where: {
     *     // ... filter to delete one Newsletter
     *   }
     * })
     * 
     */
    delete<T extends newsletterDeleteArgs>(args: SelectSubset<T, newsletterDeleteArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Newsletter.
     * @param {newsletterUpdateArgs} args - Arguments to update one Newsletter.
     * @example
     * // Update one Newsletter
     * const newsletter = await prisma.newsletter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsletterUpdateArgs>(args: SelectSubset<T, newsletterUpdateArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Newsletters.
     * @param {newsletterDeleteManyArgs} args - Arguments to filter Newsletters to delete.
     * @example
     * // Delete a few Newsletters
     * const { count } = await prisma.newsletter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsletterDeleteManyArgs>(args?: SelectSubset<T, newsletterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletters
     * const newsletter = await prisma.newsletter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsletterUpdateManyArgs>(args: SelectSubset<T, newsletterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsletter.
     * @param {newsletterUpsertArgs} args - Arguments to update or create a Newsletter.
     * @example
     * // Update or create a Newsletter
     * const newsletter = await prisma.newsletter.upsert({
     *   create: {
     *     // ... data to create a Newsletter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter we want to update
     *   }
     * })
     */
    upsert<T extends newsletterUpsertArgs>(args: SelectSubset<T, newsletterUpsertArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterCountArgs} args - Arguments to filter Newsletters to count.
     * @example
     * // Count the number of Newsletters
     * const count = await prisma.newsletter.count({
     *   where: {
     *     // ... the filter for the Newsletters we want to count
     *   }
     * })
    **/
    count<T extends newsletterCountArgs>(
      args?: Subset<T, newsletterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterAggregateArgs>(args: Subset<T, NewsletterAggregateArgs>): Prisma.PrismaPromise<GetNewsletterAggregateType<T>>

    /**
     * Group by Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsletterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsletterGroupByArgs['orderBy'] }
        : { orderBy?: newsletterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsletterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the newsletter model
   */
  readonly fields: newsletterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for newsletter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsletterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the newsletter model
   */ 
  interface newsletterFieldRefs {
    readonly id: FieldRef<"newsletter", 'Int'>
    readonly title: FieldRef<"newsletter", 'String'>
    readonly body: FieldRef<"newsletter", 'String'>
    readonly posted_by: FieldRef<"newsletter", 'Int'>
    readonly created_date: FieldRef<"newsletter", 'DateTime'>
    readonly last_updated: FieldRef<"newsletter", 'DateTime'>
    readonly newsletter_statut: FieldRef<"newsletter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * newsletter findUnique
   */
  export type newsletterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter findUniqueOrThrow
   */
  export type newsletterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter findFirst
   */
  export type newsletterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletters.
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * newsletter findFirstOrThrow
   */
  export type newsletterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletters.
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * newsletter findMany
   */
  export type newsletterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Filter, which newsletters to fetch.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing newsletters.
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * newsletter create
   */
  export type newsletterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * The data needed to create a newsletter.
     */
    data: XOR<newsletterCreateInput, newsletterUncheckedCreateInput>
  }

  /**
   * newsletter createMany
   */
  export type newsletterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many newsletters.
     */
    data: newsletterCreateManyInput | newsletterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * newsletter update
   */
  export type newsletterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * The data needed to update a newsletter.
     */
    data: XOR<newsletterUpdateInput, newsletterUncheckedUpdateInput>
    /**
     * Choose, which newsletter to update.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter updateMany
   */
  export type newsletterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update newsletters.
     */
    data: XOR<newsletterUpdateManyMutationInput, newsletterUncheckedUpdateManyInput>
    /**
     * Filter which newsletters to update
     */
    where?: newsletterWhereInput
  }

  /**
   * newsletter upsert
   */
  export type newsletterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * The filter to search for the newsletter to update in case it exists.
     */
    where: newsletterWhereUniqueInput
    /**
     * In case the newsletter found by the `where` argument doesn't exist, create a new newsletter with this data.
     */
    create: XOR<newsletterCreateInput, newsletterUncheckedCreateInput>
    /**
     * In case the newsletter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsletterUpdateInput, newsletterUncheckedUpdateInput>
  }

  /**
   * newsletter delete
   */
  export type newsletterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Filter which newsletter to delete.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter deleteMany
   */
  export type newsletterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletters to delete
     */
    where?: newsletterWhereInput
  }

  /**
   * newsletter without action
   */
  export type newsletterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
  }


  /**
   * Model permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionsSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type PermissionsAvgAggregateInputType = {
    id?: true
  }

  export type PermissionsSumAggregateInputType = {
    id?: true
  }

  export type PermissionsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    last_updated?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    last_updated?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to aggregate.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionsWhereInput
    orderBy?: permissionsOrderByWithAggregationInput | permissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _avg?: PermissionsAvgAggregateInputType
    _sum?: PermissionsSumAggregateInputType
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: number
    name: string
    description: string | null
    created_date: Date
    last_updated: Date
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_date?: boolean
    last_updated?: boolean
    role_permissions?: boolean | permissions$role_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>


  export type permissionsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role_permissions?: boolean | permissions$role_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissions"
    objects: {
      role_permissions: Prisma.$role_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type permissionsGetPayload<S extends boolean | null | undefined | permissionsDefaultArgs> = $Result.GetResult<Prisma.$permissionsPayload, S>

  type permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissions'], meta: { name: 'permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {permissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionsFindUniqueArgs>(args: SelectSubset<T, permissionsFindUniqueArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {permissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionsFindFirstArgs>(args?: SelectSubset<T, permissionsFindFirstArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionsFindManyArgs>(args?: SelectSubset<T, permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permissions.
     * @param {permissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends permissionsCreateArgs>(args: SelectSubset<T, permissionsCreateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {permissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionsCreateManyArgs>(args?: SelectSubset<T, permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissions.
     * @param {permissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends permissionsDeleteArgs>(args: SelectSubset<T, permissionsDeleteArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permissions.
     * @param {permissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionsUpdateArgs>(args: SelectSubset<T, permissionsUpdateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {permissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionsDeleteManyArgs>(args?: SelectSubset<T, permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionsUpdateManyArgs>(args: SelectSubset<T, permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {permissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends permissionsUpsertArgs>(args: SelectSubset<T, permissionsUpsertArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionsCountArgs>(
      args?: Subset<T, permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionsGroupByArgs['orderBy'] }
        : { orderBy?: permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissions model
   */
  readonly fields: permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role_permissions<T extends permissions$role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissions model
   */ 
  interface permissionsFieldRefs {
    readonly id: FieldRef<"permissions", 'Int'>
    readonly name: FieldRef<"permissions", 'String'>
    readonly description: FieldRef<"permissions", 'String'>
    readonly created_date: FieldRef<"permissions", 'DateTime'>
    readonly last_updated: FieldRef<"permissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * permissions findUnique
   */
  export type permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findUniqueOrThrow
   */
  export type permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findFirst
   */
  export type permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findFirstOrThrow
   */
  export type permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findMany
   */
  export type permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions create
   */
  export type permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a permissions.
     */
    data: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
  }

  /**
   * permissions createMany
   */
  export type permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions update
   */
  export type permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a permissions.
     */
    data: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
    /**
     * Choose, which permissions to update.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions updateMany
   */
  export type permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
  }

  /**
   * permissions upsert
   */
  export type permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the permissions to update in case it exists.
     */
    where: permissionsWhereUniqueInput
    /**
     * In case the permissions found by the `where` argument doesn't exist, create a new permissions with this data.
     */
    create: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
    /**
     * In case the permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
  }

  /**
   * permissions delete
   */
  export type permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter which permissions to delete.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions deleteMany
   */
  export type permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionsWhereInput
  }

  /**
   * permissions.role_permissions
   */
  export type permissions$role_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    cursor?: role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * permissions without action
   */
  export type permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
  }


  /**
   * Model plans_action
   */

  export type AggregatePlans_action = {
    _count: Plans_actionCountAggregateOutputType | null
    _avg: Plans_actionAvgAggregateOutputType | null
    _sum: Plans_actionSumAggregateOutputType | null
    _min: Plans_actionMinAggregateOutputType | null
    _max: Plans_actionMaxAggregateOutputType | null
  }

  export type Plans_actionAvgAggregateOutputType = {
    id: number | null
  }

  export type Plans_actionSumAggregateOutputType = {
    id: number | null
  }

  export type Plans_actionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    objectif: string | null
    start_date: Date | null
    end_date: Date | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type Plans_actionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    objectif: string | null
    start_date: Date | null
    end_date: Date | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type Plans_actionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    objectif: number
    start_date: number
    end_date: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type Plans_actionAvgAggregateInputType = {
    id?: true
  }

  export type Plans_actionSumAggregateInputType = {
    id?: true
  }

  export type Plans_actionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objectif?: true
    start_date?: true
    end_date?: true
    created_date?: true
    last_updated?: true
  }

  export type Plans_actionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objectif?: true
    start_date?: true
    end_date?: true
    created_date?: true
    last_updated?: true
  }

  export type Plans_actionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objectif?: true
    start_date?: true
    end_date?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type Plans_actionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plans_action to aggregate.
     */
    where?: plans_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans_actions to fetch.
     */
    orderBy?: plans_actionOrderByWithRelationInput | plans_actionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plans_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plans_actions
    **/
    _count?: true | Plans_actionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plans_actionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plans_actionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plans_actionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plans_actionMaxAggregateInputType
  }

  export type GetPlans_actionAggregateType<T extends Plans_actionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlans_action]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlans_action[P]>
      : GetScalarType<T[P], AggregatePlans_action[P]>
  }




  export type plans_actionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plans_actionWhereInput
    orderBy?: plans_actionOrderByWithAggregationInput | plans_actionOrderByWithAggregationInput[]
    by: Plans_actionScalarFieldEnum[] | Plans_actionScalarFieldEnum
    having?: plans_actionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plans_actionCountAggregateInputType | true
    _avg?: Plans_actionAvgAggregateInputType
    _sum?: Plans_actionSumAggregateInputType
    _min?: Plans_actionMinAggregateInputType
    _max?: Plans_actionMaxAggregateInputType
  }

  export type Plans_actionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    objectif: string | null
    start_date: Date | null
    end_date: Date | null
    created_date: Date
    last_updated: Date
    _count: Plans_actionCountAggregateOutputType | null
    _avg: Plans_actionAvgAggregateOutputType | null
    _sum: Plans_actionSumAggregateOutputType | null
    _min: Plans_actionMinAggregateOutputType | null
    _max: Plans_actionMaxAggregateOutputType | null
  }

  type GetPlans_actionGroupByPayload<T extends plans_actionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plans_actionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plans_actionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plans_actionGroupByOutputType[P]>
            : GetScalarType<T[P], Plans_actionGroupByOutputType[P]>
        }
      >
    >


  export type plans_actionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    objectif?: boolean
    start_date?: boolean
    end_date?: boolean
    created_date?: boolean
    last_updated?: boolean
    axes?: boolean | plans_action$axesArgs<ExtArgs>
    _count?: boolean | Plans_actionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plans_action"]>


  export type plans_actionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    objectif?: boolean
    start_date?: boolean
    end_date?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type plans_actionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    axes?: boolean | plans_action$axesArgs<ExtArgs>
    _count?: boolean | Plans_actionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $plans_actionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plans_action"
    objects: {
      axes: Prisma.$axesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      objectif: string | null
      start_date: Date | null
      end_date: Date | null
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["plans_action"]>
    composites: {}
  }

  type plans_actionGetPayload<S extends boolean | null | undefined | plans_actionDefaultArgs> = $Result.GetResult<Prisma.$plans_actionPayload, S>

  type plans_actionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<plans_actionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Plans_actionCountAggregateInputType | true
    }

  export interface plans_actionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plans_action'], meta: { name: 'plans_action' } }
    /**
     * Find zero or one Plans_action that matches the filter.
     * @param {plans_actionFindUniqueArgs} args - Arguments to find a Plans_action
     * @example
     * // Get one Plans_action
     * const plans_action = await prisma.plans_action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plans_actionFindUniqueArgs>(args: SelectSubset<T, plans_actionFindUniqueArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plans_action that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {plans_actionFindUniqueOrThrowArgs} args - Arguments to find a Plans_action
     * @example
     * // Get one Plans_action
     * const plans_action = await prisma.plans_action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plans_actionFindUniqueOrThrowArgs>(args: SelectSubset<T, plans_actionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plans_action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plans_actionFindFirstArgs} args - Arguments to find a Plans_action
     * @example
     * // Get one Plans_action
     * const plans_action = await prisma.plans_action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plans_actionFindFirstArgs>(args?: SelectSubset<T, plans_actionFindFirstArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plans_action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plans_actionFindFirstOrThrowArgs} args - Arguments to find a Plans_action
     * @example
     * // Get one Plans_action
     * const plans_action = await prisma.plans_action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plans_actionFindFirstOrThrowArgs>(args?: SelectSubset<T, plans_actionFindFirstOrThrowArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plans_actionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans_actions
     * const plans_actions = await prisma.plans_action.findMany()
     * 
     * // Get first 10 Plans_actions
     * const plans_actions = await prisma.plans_action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plans_actionWithIdOnly = await prisma.plans_action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plans_actionFindManyArgs>(args?: SelectSubset<T, plans_actionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plans_action.
     * @param {plans_actionCreateArgs} args - Arguments to create a Plans_action.
     * @example
     * // Create one Plans_action
     * const Plans_action = await prisma.plans_action.create({
     *   data: {
     *     // ... data to create a Plans_action
     *   }
     * })
     * 
     */
    create<T extends plans_actionCreateArgs>(args: SelectSubset<T, plans_actionCreateArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans_actions.
     * @param {plans_actionCreateManyArgs} args - Arguments to create many Plans_actions.
     * @example
     * // Create many Plans_actions
     * const plans_action = await prisma.plans_action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plans_actionCreateManyArgs>(args?: SelectSubset<T, plans_actionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plans_action.
     * @param {plans_actionDeleteArgs} args - Arguments to delete one Plans_action.
     * @example
     * // Delete one Plans_action
     * const Plans_action = await prisma.plans_action.delete({
     *   where: {
     *     // ... filter to delete one Plans_action
     *   }
     * })
     * 
     */
    delete<T extends plans_actionDeleteArgs>(args: SelectSubset<T, plans_actionDeleteArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plans_action.
     * @param {plans_actionUpdateArgs} args - Arguments to update one Plans_action.
     * @example
     * // Update one Plans_action
     * const plans_action = await prisma.plans_action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plans_actionUpdateArgs>(args: SelectSubset<T, plans_actionUpdateArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans_actions.
     * @param {plans_actionDeleteManyArgs} args - Arguments to filter Plans_actions to delete.
     * @example
     * // Delete a few Plans_actions
     * const { count } = await prisma.plans_action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plans_actionDeleteManyArgs>(args?: SelectSubset<T, plans_actionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plans_actionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans_actions
     * const plans_action = await prisma.plans_action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plans_actionUpdateManyArgs>(args: SelectSubset<T, plans_actionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plans_action.
     * @param {plans_actionUpsertArgs} args - Arguments to update or create a Plans_action.
     * @example
     * // Update or create a Plans_action
     * const plans_action = await prisma.plans_action.upsert({
     *   create: {
     *     // ... data to create a Plans_action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plans_action we want to update
     *   }
     * })
     */
    upsert<T extends plans_actionUpsertArgs>(args: SelectSubset<T, plans_actionUpsertArgs<ExtArgs>>): Prisma__plans_actionClient<$Result.GetResult<Prisma.$plans_actionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plans_actionCountArgs} args - Arguments to filter Plans_actions to count.
     * @example
     * // Count the number of Plans_actions
     * const count = await prisma.plans_action.count({
     *   where: {
     *     // ... the filter for the Plans_actions we want to count
     *   }
     * })
    **/
    count<T extends plans_actionCountArgs>(
      args?: Subset<T, plans_actionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plans_actionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plans_action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plans_actionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plans_actionAggregateArgs>(args: Subset<T, Plans_actionAggregateArgs>): Prisma.PrismaPromise<GetPlans_actionAggregateType<T>>

    /**
     * Group by Plans_action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plans_actionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plans_actionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plans_actionGroupByArgs['orderBy'] }
        : { orderBy?: plans_actionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plans_actionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlans_actionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plans_action model
   */
  readonly fields: plans_actionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plans_action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plans_actionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    axes<T extends plans_action$axesArgs<ExtArgs> = {}>(args?: Subset<T, plans_action$axesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plans_action model
   */ 
  interface plans_actionFieldRefs {
    readonly id: FieldRef<"plans_action", 'Int'>
    readonly name: FieldRef<"plans_action", 'String'>
    readonly description: FieldRef<"plans_action", 'String'>
    readonly objectif: FieldRef<"plans_action", 'String'>
    readonly start_date: FieldRef<"plans_action", 'DateTime'>
    readonly end_date: FieldRef<"plans_action", 'DateTime'>
    readonly created_date: FieldRef<"plans_action", 'DateTime'>
    readonly last_updated: FieldRef<"plans_action", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * plans_action findUnique
   */
  export type plans_actionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * Filter, which plans_action to fetch.
     */
    where: plans_actionWhereUniqueInput
  }

  /**
   * plans_action findUniqueOrThrow
   */
  export type plans_actionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * Filter, which plans_action to fetch.
     */
    where: plans_actionWhereUniqueInput
  }

  /**
   * plans_action findFirst
   */
  export type plans_actionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * Filter, which plans_action to fetch.
     */
    where?: plans_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans_actions to fetch.
     */
    orderBy?: plans_actionOrderByWithRelationInput | plans_actionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans_actions.
     */
    cursor?: plans_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans_actions.
     */
    distinct?: Plans_actionScalarFieldEnum | Plans_actionScalarFieldEnum[]
  }

  /**
   * plans_action findFirstOrThrow
   */
  export type plans_actionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * Filter, which plans_action to fetch.
     */
    where?: plans_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans_actions to fetch.
     */
    orderBy?: plans_actionOrderByWithRelationInput | plans_actionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans_actions.
     */
    cursor?: plans_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans_actions.
     */
    distinct?: Plans_actionScalarFieldEnum | Plans_actionScalarFieldEnum[]
  }

  /**
   * plans_action findMany
   */
  export type plans_actionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * Filter, which plans_actions to fetch.
     */
    where?: plans_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans_actions to fetch.
     */
    orderBy?: plans_actionOrderByWithRelationInput | plans_actionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plans_actions.
     */
    cursor?: plans_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans_actions.
     */
    skip?: number
    distinct?: Plans_actionScalarFieldEnum | Plans_actionScalarFieldEnum[]
  }

  /**
   * plans_action create
   */
  export type plans_actionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * The data needed to create a plans_action.
     */
    data: XOR<plans_actionCreateInput, plans_actionUncheckedCreateInput>
  }

  /**
   * plans_action createMany
   */
  export type plans_actionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plans_actions.
     */
    data: plans_actionCreateManyInput | plans_actionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plans_action update
   */
  export type plans_actionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * The data needed to update a plans_action.
     */
    data: XOR<plans_actionUpdateInput, plans_actionUncheckedUpdateInput>
    /**
     * Choose, which plans_action to update.
     */
    where: plans_actionWhereUniqueInput
  }

  /**
   * plans_action updateMany
   */
  export type plans_actionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plans_actions.
     */
    data: XOR<plans_actionUpdateManyMutationInput, plans_actionUncheckedUpdateManyInput>
    /**
     * Filter which plans_actions to update
     */
    where?: plans_actionWhereInput
  }

  /**
   * plans_action upsert
   */
  export type plans_actionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * The filter to search for the plans_action to update in case it exists.
     */
    where: plans_actionWhereUniqueInput
    /**
     * In case the plans_action found by the `where` argument doesn't exist, create a new plans_action with this data.
     */
    create: XOR<plans_actionCreateInput, plans_actionUncheckedCreateInput>
    /**
     * In case the plans_action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plans_actionUpdateInput, plans_actionUncheckedUpdateInput>
  }

  /**
   * plans_action delete
   */
  export type plans_actionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
    /**
     * Filter which plans_action to delete.
     */
    where: plans_actionWhereUniqueInput
  }

  /**
   * plans_action deleteMany
   */
  export type plans_actionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plans_actions to delete
     */
    where?: plans_actionWhereInput
  }

  /**
   * plans_action.axes
   */
  export type plans_action$axesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the axes
     */
    select?: axesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: axesInclude<ExtArgs> | null
    where?: axesWhereInput
    orderBy?: axesOrderByWithRelationInput | axesOrderByWithRelationInput[]
    cursor?: axesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AxesScalarFieldEnum | AxesScalarFieldEnum[]
  }

  /**
   * plans_action without action
   */
  export type plans_actionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans_action
     */
    select?: plans_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plans_actionInclude<ExtArgs> | null
  }


  /**
   * Model priority
   */

  export type AggregatePriority = {
    _count: PriorityCountAggregateOutputType | null
    _avg: PriorityAvgAggregateOutputType | null
    _sum: PrioritySumAggregateOutputType | null
    _min: PriorityMinAggregateOutputType | null
    _max: PriorityMaxAggregateOutputType | null
  }

  export type PriorityAvgAggregateOutputType = {
    id: number | null
  }

  export type PrioritySumAggregateOutputType = {
    id: number | null
  }

  export type PriorityMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type PriorityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type PriorityCountAggregateOutputType = {
    id: number
    name: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type PriorityAvgAggregateInputType = {
    id?: true
  }

  export type PrioritySumAggregateInputType = {
    id?: true
  }

  export type PriorityMinAggregateInputType = {
    id?: true
    name?: true
    created_date?: true
    last_updated?: true
  }

  export type PriorityMaxAggregateInputType = {
    id?: true
    name?: true
    created_date?: true
    last_updated?: true
  }

  export type PriorityCountAggregateInputType = {
    id?: true
    name?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type PriorityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which priority to aggregate.
     */
    where?: priorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priorities to fetch.
     */
    orderBy?: priorityOrderByWithRelationInput | priorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: priorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned priorities
    **/
    _count?: true | PriorityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriorityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrioritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriorityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriorityMaxAggregateInputType
  }

  export type GetPriorityAggregateType<T extends PriorityAggregateArgs> = {
        [P in keyof T & keyof AggregatePriority]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriority[P]>
      : GetScalarType<T[P], AggregatePriority[P]>
  }




  export type priorityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: priorityWhereInput
    orderBy?: priorityOrderByWithAggregationInput | priorityOrderByWithAggregationInput[]
    by: PriorityScalarFieldEnum[] | PriorityScalarFieldEnum
    having?: priorityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriorityCountAggregateInputType | true
    _avg?: PriorityAvgAggregateInputType
    _sum?: PrioritySumAggregateInputType
    _min?: PriorityMinAggregateInputType
    _max?: PriorityMaxAggregateInputType
  }

  export type PriorityGroupByOutputType = {
    id: number
    name: string
    created_date: Date
    last_updated: Date
    _count: PriorityCountAggregateOutputType | null
    _avg: PriorityAvgAggregateOutputType | null
    _sum: PrioritySumAggregateOutputType | null
    _min: PriorityMinAggregateOutputType | null
    _max: PriorityMaxAggregateOutputType | null
  }

  type GetPriorityGroupByPayload<T extends priorityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriorityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriorityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriorityGroupByOutputType[P]>
            : GetScalarType<T[P], PriorityGroupByOutputType[P]>
        }
      >
    >


  export type prioritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_date?: boolean
    last_updated?: boolean
    projets?: boolean | priority$projetsArgs<ExtArgs>
    _count?: boolean | PriorityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priority"]>


  export type prioritySelectScalar = {
    id?: boolean
    name?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type priorityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | priority$projetsArgs<ExtArgs>
    _count?: boolean | PriorityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $priorityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "priority"
    objects: {
      projets: Prisma.$projetsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["priority"]>
    composites: {}
  }

  type priorityGetPayload<S extends boolean | null | undefined | priorityDefaultArgs> = $Result.GetResult<Prisma.$priorityPayload, S>

  type priorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<priorityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriorityCountAggregateInputType | true
    }

  export interface priorityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['priority'], meta: { name: 'priority' } }
    /**
     * Find zero or one Priority that matches the filter.
     * @param {priorityFindUniqueArgs} args - Arguments to find a Priority
     * @example
     * // Get one Priority
     * const priority = await prisma.priority.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends priorityFindUniqueArgs>(args: SelectSubset<T, priorityFindUniqueArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Priority that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {priorityFindUniqueOrThrowArgs} args - Arguments to find a Priority
     * @example
     * // Get one Priority
     * const priority = await prisma.priority.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends priorityFindUniqueOrThrowArgs>(args: SelectSubset<T, priorityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Priority that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priorityFindFirstArgs} args - Arguments to find a Priority
     * @example
     * // Get one Priority
     * const priority = await prisma.priority.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends priorityFindFirstArgs>(args?: SelectSubset<T, priorityFindFirstArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Priority that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priorityFindFirstOrThrowArgs} args - Arguments to find a Priority
     * @example
     * // Get one Priority
     * const priority = await prisma.priority.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends priorityFindFirstOrThrowArgs>(args?: SelectSubset<T, priorityFindFirstOrThrowArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Priorities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priorityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Priorities
     * const priorities = await prisma.priority.findMany()
     * 
     * // Get first 10 Priorities
     * const priorities = await prisma.priority.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priorityWithIdOnly = await prisma.priority.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends priorityFindManyArgs>(args?: SelectSubset<T, priorityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Priority.
     * @param {priorityCreateArgs} args - Arguments to create a Priority.
     * @example
     * // Create one Priority
     * const Priority = await prisma.priority.create({
     *   data: {
     *     // ... data to create a Priority
     *   }
     * })
     * 
     */
    create<T extends priorityCreateArgs>(args: SelectSubset<T, priorityCreateArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Priorities.
     * @param {priorityCreateManyArgs} args - Arguments to create many Priorities.
     * @example
     * // Create many Priorities
     * const priority = await prisma.priority.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends priorityCreateManyArgs>(args?: SelectSubset<T, priorityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Priority.
     * @param {priorityDeleteArgs} args - Arguments to delete one Priority.
     * @example
     * // Delete one Priority
     * const Priority = await prisma.priority.delete({
     *   where: {
     *     // ... filter to delete one Priority
     *   }
     * })
     * 
     */
    delete<T extends priorityDeleteArgs>(args: SelectSubset<T, priorityDeleteArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Priority.
     * @param {priorityUpdateArgs} args - Arguments to update one Priority.
     * @example
     * // Update one Priority
     * const priority = await prisma.priority.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends priorityUpdateArgs>(args: SelectSubset<T, priorityUpdateArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Priorities.
     * @param {priorityDeleteManyArgs} args - Arguments to filter Priorities to delete.
     * @example
     * // Delete a few Priorities
     * const { count } = await prisma.priority.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends priorityDeleteManyArgs>(args?: SelectSubset<T, priorityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Priorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priorityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Priorities
     * const priority = await prisma.priority.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends priorityUpdateManyArgs>(args: SelectSubset<T, priorityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Priority.
     * @param {priorityUpsertArgs} args - Arguments to update or create a Priority.
     * @example
     * // Update or create a Priority
     * const priority = await prisma.priority.upsert({
     *   create: {
     *     // ... data to create a Priority
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Priority we want to update
     *   }
     * })
     */
    upsert<T extends priorityUpsertArgs>(args: SelectSubset<T, priorityUpsertArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Priorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priorityCountArgs} args - Arguments to filter Priorities to count.
     * @example
     * // Count the number of Priorities
     * const count = await prisma.priority.count({
     *   where: {
     *     // ... the filter for the Priorities we want to count
     *   }
     * })
    **/
    count<T extends priorityCountArgs>(
      args?: Subset<T, priorityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriorityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Priority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriorityAggregateArgs>(args: Subset<T, PriorityAggregateArgs>): Prisma.PrismaPromise<GetPriorityAggregateType<T>>

    /**
     * Group by Priority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priorityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends priorityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: priorityGroupByArgs['orderBy'] }
        : { orderBy?: priorityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, priorityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriorityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the priority model
   */
  readonly fields: priorityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for priority.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__priorityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projets<T extends priority$projetsArgs<ExtArgs> = {}>(args?: Subset<T, priority$projetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the priority model
   */ 
  interface priorityFieldRefs {
    readonly id: FieldRef<"priority", 'Int'>
    readonly name: FieldRef<"priority", 'String'>
    readonly created_date: FieldRef<"priority", 'DateTime'>
    readonly last_updated: FieldRef<"priority", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * priority findUnique
   */
  export type priorityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * Filter, which priority to fetch.
     */
    where: priorityWhereUniqueInput
  }

  /**
   * priority findUniqueOrThrow
   */
  export type priorityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * Filter, which priority to fetch.
     */
    where: priorityWhereUniqueInput
  }

  /**
   * priority findFirst
   */
  export type priorityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * Filter, which priority to fetch.
     */
    where?: priorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priorities to fetch.
     */
    orderBy?: priorityOrderByWithRelationInput | priorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for priorities.
     */
    cursor?: priorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of priorities.
     */
    distinct?: PriorityScalarFieldEnum | PriorityScalarFieldEnum[]
  }

  /**
   * priority findFirstOrThrow
   */
  export type priorityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * Filter, which priority to fetch.
     */
    where?: priorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priorities to fetch.
     */
    orderBy?: priorityOrderByWithRelationInput | priorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for priorities.
     */
    cursor?: priorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of priorities.
     */
    distinct?: PriorityScalarFieldEnum | PriorityScalarFieldEnum[]
  }

  /**
   * priority findMany
   */
  export type priorityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * Filter, which priorities to fetch.
     */
    where?: priorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priorities to fetch.
     */
    orderBy?: priorityOrderByWithRelationInput | priorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing priorities.
     */
    cursor?: priorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priorities.
     */
    skip?: number
    distinct?: PriorityScalarFieldEnum | PriorityScalarFieldEnum[]
  }

  /**
   * priority create
   */
  export type priorityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * The data needed to create a priority.
     */
    data: XOR<priorityCreateInput, priorityUncheckedCreateInput>
  }

  /**
   * priority createMany
   */
  export type priorityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many priorities.
     */
    data: priorityCreateManyInput | priorityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * priority update
   */
  export type priorityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * The data needed to update a priority.
     */
    data: XOR<priorityUpdateInput, priorityUncheckedUpdateInput>
    /**
     * Choose, which priority to update.
     */
    where: priorityWhereUniqueInput
  }

  /**
   * priority updateMany
   */
  export type priorityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update priorities.
     */
    data: XOR<priorityUpdateManyMutationInput, priorityUncheckedUpdateManyInput>
    /**
     * Filter which priorities to update
     */
    where?: priorityWhereInput
  }

  /**
   * priority upsert
   */
  export type priorityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * The filter to search for the priority to update in case it exists.
     */
    where: priorityWhereUniqueInput
    /**
     * In case the priority found by the `where` argument doesn't exist, create a new priority with this data.
     */
    create: XOR<priorityCreateInput, priorityUncheckedCreateInput>
    /**
     * In case the priority was found with the provided `where` argument, update it with this data.
     */
    update: XOR<priorityUpdateInput, priorityUncheckedUpdateInput>
  }

  /**
   * priority delete
   */
  export type priorityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    /**
     * Filter which priority to delete.
     */
    where: priorityWhereUniqueInput
  }

  /**
   * priority deleteMany
   */
  export type priorityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which priorities to delete
     */
    where?: priorityWhereInput
  }

  /**
   * priority.projets
   */
  export type priority$projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    where?: projetsWhereInput
    orderBy?: projetsOrderByWithRelationInput | projetsOrderByWithRelationInput[]
    cursor?: projetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetsScalarFieldEnum | ProjetsScalarFieldEnum[]
  }

  /**
   * priority without action
   */
  export type priorityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
  }


  /**
   * Model projet_groupes
   */

  export type AggregateProjet_groupes = {
    _count: Projet_groupesCountAggregateOutputType | null
    _avg: Projet_groupesAvgAggregateOutputType | null
    _sum: Projet_groupesSumAggregateOutputType | null
    _min: Projet_groupesMinAggregateOutputType | null
    _max: Projet_groupesMaxAggregateOutputType | null
  }

  export type Projet_groupesAvgAggregateOutputType = {
    projet_id: number | null
    groupe_id: number | null
  }

  export type Projet_groupesSumAggregateOutputType = {
    projet_id: number | null
    groupe_id: number | null
  }

  export type Projet_groupesMinAggregateOutputType = {
    projet_id: number | null
    groupe_id: number | null
  }

  export type Projet_groupesMaxAggregateOutputType = {
    projet_id: number | null
    groupe_id: number | null
  }

  export type Projet_groupesCountAggregateOutputType = {
    projet_id: number
    groupe_id: number
    _all: number
  }


  export type Projet_groupesAvgAggregateInputType = {
    projet_id?: true
    groupe_id?: true
  }

  export type Projet_groupesSumAggregateInputType = {
    projet_id?: true
    groupe_id?: true
  }

  export type Projet_groupesMinAggregateInputType = {
    projet_id?: true
    groupe_id?: true
  }

  export type Projet_groupesMaxAggregateInputType = {
    projet_id?: true
    groupe_id?: true
  }

  export type Projet_groupesCountAggregateInputType = {
    projet_id?: true
    groupe_id?: true
    _all?: true
  }

  export type Projet_groupesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_groupes to aggregate.
     */
    where?: projet_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_groupes to fetch.
     */
    orderBy?: projet_groupesOrderByWithRelationInput | projet_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projet_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projet_groupes
    **/
    _count?: true | Projet_groupesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Projet_groupesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Projet_groupesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Projet_groupesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Projet_groupesMaxAggregateInputType
  }

  export type GetProjet_groupesAggregateType<T extends Projet_groupesAggregateArgs> = {
        [P in keyof T & keyof AggregateProjet_groupes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjet_groupes[P]>
      : GetScalarType<T[P], AggregateProjet_groupes[P]>
  }




  export type projet_groupesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_groupesWhereInput
    orderBy?: projet_groupesOrderByWithAggregationInput | projet_groupesOrderByWithAggregationInput[]
    by: Projet_groupesScalarFieldEnum[] | Projet_groupesScalarFieldEnum
    having?: projet_groupesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Projet_groupesCountAggregateInputType | true
    _avg?: Projet_groupesAvgAggregateInputType
    _sum?: Projet_groupesSumAggregateInputType
    _min?: Projet_groupesMinAggregateInputType
    _max?: Projet_groupesMaxAggregateInputType
  }

  export type Projet_groupesGroupByOutputType = {
    projet_id: number
    groupe_id: number
    _count: Projet_groupesCountAggregateOutputType | null
    _avg: Projet_groupesAvgAggregateOutputType | null
    _sum: Projet_groupesSumAggregateOutputType | null
    _min: Projet_groupesMinAggregateOutputType | null
    _max: Projet_groupesMaxAggregateOutputType | null
  }

  type GetProjet_groupesGroupByPayload<T extends projet_groupesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Projet_groupesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Projet_groupesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Projet_groupesGroupByOutputType[P]>
            : GetScalarType<T[P], Projet_groupesGroupByOutputType[P]>
        }
      >
    >


  export type projet_groupesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projet_id?: boolean
    groupe_id?: boolean
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    groupes?: boolean | groupesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_groupes"]>


  export type projet_groupesSelectScalar = {
    projet_id?: boolean
    groupe_id?: boolean
  }

  export type projet_groupesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    groupes?: boolean | groupesDefaultArgs<ExtArgs>
  }

  export type $projet_groupesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projet_groupes"
    objects: {
      projets: Prisma.$projetsPayload<ExtArgs>
      groupes: Prisma.$groupesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projet_id: number
      groupe_id: number
    }, ExtArgs["result"]["projet_groupes"]>
    composites: {}
  }

  type projet_groupesGetPayload<S extends boolean | null | undefined | projet_groupesDefaultArgs> = $Result.GetResult<Prisma.$projet_groupesPayload, S>

  type projet_groupesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projet_groupesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Projet_groupesCountAggregateInputType | true
    }

  export interface projet_groupesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projet_groupes'], meta: { name: 'projet_groupes' } }
    /**
     * Find zero or one Projet_groupes that matches the filter.
     * @param {projet_groupesFindUniqueArgs} args - Arguments to find a Projet_groupes
     * @example
     * // Get one Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projet_groupesFindUniqueArgs>(args: SelectSubset<T, projet_groupesFindUniqueArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Projet_groupes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projet_groupesFindUniqueOrThrowArgs} args - Arguments to find a Projet_groupes
     * @example
     * // Get one Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projet_groupesFindUniqueOrThrowArgs>(args: SelectSubset<T, projet_groupesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Projet_groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_groupesFindFirstArgs} args - Arguments to find a Projet_groupes
     * @example
     * // Get one Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projet_groupesFindFirstArgs>(args?: SelectSubset<T, projet_groupesFindFirstArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Projet_groupes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_groupesFindFirstOrThrowArgs} args - Arguments to find a Projet_groupes
     * @example
     * // Get one Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projet_groupesFindFirstOrThrowArgs>(args?: SelectSubset<T, projet_groupesFindFirstOrThrowArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projet_groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_groupesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.findMany()
     * 
     * // Get first 10 Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.findMany({ take: 10 })
     * 
     * // Only select the `projet_id`
     * const projet_groupesWithProjet_idOnly = await prisma.projet_groupes.findMany({ select: { projet_id: true } })
     * 
     */
    findMany<T extends projet_groupesFindManyArgs>(args?: SelectSubset<T, projet_groupesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Projet_groupes.
     * @param {projet_groupesCreateArgs} args - Arguments to create a Projet_groupes.
     * @example
     * // Create one Projet_groupes
     * const Projet_groupes = await prisma.projet_groupes.create({
     *   data: {
     *     // ... data to create a Projet_groupes
     *   }
     * })
     * 
     */
    create<T extends projet_groupesCreateArgs>(args: SelectSubset<T, projet_groupesCreateArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projet_groupes.
     * @param {projet_groupesCreateManyArgs} args - Arguments to create many Projet_groupes.
     * @example
     * // Create many Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projet_groupesCreateManyArgs>(args?: SelectSubset<T, projet_groupesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Projet_groupes.
     * @param {projet_groupesDeleteArgs} args - Arguments to delete one Projet_groupes.
     * @example
     * // Delete one Projet_groupes
     * const Projet_groupes = await prisma.projet_groupes.delete({
     *   where: {
     *     // ... filter to delete one Projet_groupes
     *   }
     * })
     * 
     */
    delete<T extends projet_groupesDeleteArgs>(args: SelectSubset<T, projet_groupesDeleteArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Projet_groupes.
     * @param {projet_groupesUpdateArgs} args - Arguments to update one Projet_groupes.
     * @example
     * // Update one Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projet_groupesUpdateArgs>(args: SelectSubset<T, projet_groupesUpdateArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projet_groupes.
     * @param {projet_groupesDeleteManyArgs} args - Arguments to filter Projet_groupes to delete.
     * @example
     * // Delete a few Projet_groupes
     * const { count } = await prisma.projet_groupes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projet_groupesDeleteManyArgs>(args?: SelectSubset<T, projet_groupesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projet_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_groupesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projet_groupesUpdateManyArgs>(args: SelectSubset<T, projet_groupesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projet_groupes.
     * @param {projet_groupesUpsertArgs} args - Arguments to update or create a Projet_groupes.
     * @example
     * // Update or create a Projet_groupes
     * const projet_groupes = await prisma.projet_groupes.upsert({
     *   create: {
     *     // ... data to create a Projet_groupes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projet_groupes we want to update
     *   }
     * })
     */
    upsert<T extends projet_groupesUpsertArgs>(args: SelectSubset<T, projet_groupesUpsertArgs<ExtArgs>>): Prisma__projet_groupesClient<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projet_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_groupesCountArgs} args - Arguments to filter Projet_groupes to count.
     * @example
     * // Count the number of Projet_groupes
     * const count = await prisma.projet_groupes.count({
     *   where: {
     *     // ... the filter for the Projet_groupes we want to count
     *   }
     * })
    **/
    count<T extends projet_groupesCountArgs>(
      args?: Subset<T, projet_groupesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Projet_groupesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projet_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Projet_groupesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Projet_groupesAggregateArgs>(args: Subset<T, Projet_groupesAggregateArgs>): Prisma.PrismaPromise<GetProjet_groupesAggregateType<T>>

    /**
     * Group by Projet_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_groupesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projet_groupesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projet_groupesGroupByArgs['orderBy'] }
        : { orderBy?: projet_groupesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projet_groupesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjet_groupesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projet_groupes model
   */
  readonly fields: projet_groupesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projet_groupes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projet_groupesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projets<T extends projetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetsDefaultArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    groupes<T extends groupesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupesDefaultArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projet_groupes model
   */ 
  interface projet_groupesFieldRefs {
    readonly projet_id: FieldRef<"projet_groupes", 'Int'>
    readonly groupe_id: FieldRef<"projet_groupes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * projet_groupes findUnique
   */
  export type projet_groupesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * Filter, which projet_groupes to fetch.
     */
    where: projet_groupesWhereUniqueInput
  }

  /**
   * projet_groupes findUniqueOrThrow
   */
  export type projet_groupesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * Filter, which projet_groupes to fetch.
     */
    where: projet_groupesWhereUniqueInput
  }

  /**
   * projet_groupes findFirst
   */
  export type projet_groupesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * Filter, which projet_groupes to fetch.
     */
    where?: projet_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_groupes to fetch.
     */
    orderBy?: projet_groupesOrderByWithRelationInput | projet_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_groupes.
     */
    cursor?: projet_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_groupes.
     */
    distinct?: Projet_groupesScalarFieldEnum | Projet_groupesScalarFieldEnum[]
  }

  /**
   * projet_groupes findFirstOrThrow
   */
  export type projet_groupesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * Filter, which projet_groupes to fetch.
     */
    where?: projet_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_groupes to fetch.
     */
    orderBy?: projet_groupesOrderByWithRelationInput | projet_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_groupes.
     */
    cursor?: projet_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_groupes.
     */
    distinct?: Projet_groupesScalarFieldEnum | Projet_groupesScalarFieldEnum[]
  }

  /**
   * projet_groupes findMany
   */
  export type projet_groupesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * Filter, which projet_groupes to fetch.
     */
    where?: projet_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_groupes to fetch.
     */
    orderBy?: projet_groupesOrderByWithRelationInput | projet_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projet_groupes.
     */
    cursor?: projet_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_groupes.
     */
    skip?: number
    distinct?: Projet_groupesScalarFieldEnum | Projet_groupesScalarFieldEnum[]
  }

  /**
   * projet_groupes create
   */
  export type projet_groupesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * The data needed to create a projet_groupes.
     */
    data: XOR<projet_groupesCreateInput, projet_groupesUncheckedCreateInput>
  }

  /**
   * projet_groupes createMany
   */
  export type projet_groupesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projet_groupes.
     */
    data: projet_groupesCreateManyInput | projet_groupesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projet_groupes update
   */
  export type projet_groupesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * The data needed to update a projet_groupes.
     */
    data: XOR<projet_groupesUpdateInput, projet_groupesUncheckedUpdateInput>
    /**
     * Choose, which projet_groupes to update.
     */
    where: projet_groupesWhereUniqueInput
  }

  /**
   * projet_groupes updateMany
   */
  export type projet_groupesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projet_groupes.
     */
    data: XOR<projet_groupesUpdateManyMutationInput, projet_groupesUncheckedUpdateManyInput>
    /**
     * Filter which projet_groupes to update
     */
    where?: projet_groupesWhereInput
  }

  /**
   * projet_groupes upsert
   */
  export type projet_groupesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * The filter to search for the projet_groupes to update in case it exists.
     */
    where: projet_groupesWhereUniqueInput
    /**
     * In case the projet_groupes found by the `where` argument doesn't exist, create a new projet_groupes with this data.
     */
    create: XOR<projet_groupesCreateInput, projet_groupesUncheckedCreateInput>
    /**
     * In case the projet_groupes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projet_groupesUpdateInput, projet_groupesUncheckedUpdateInput>
  }

  /**
   * projet_groupes delete
   */
  export type projet_groupesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    /**
     * Filter which projet_groupes to delete.
     */
    where: projet_groupesWhereUniqueInput
  }

  /**
   * projet_groupes deleteMany
   */
  export type projet_groupesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_groupes to delete
     */
    where?: projet_groupesWhereInput
  }

  /**
   * projet_groupes without action
   */
  export type projet_groupesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
  }


  /**
   * Model projet_utilisateurs
   */

  export type AggregateProjet_utilisateurs = {
    _count: Projet_utilisateursCountAggregateOutputType | null
    _avg: Projet_utilisateursAvgAggregateOutputType | null
    _sum: Projet_utilisateursSumAggregateOutputType | null
    _min: Projet_utilisateursMinAggregateOutputType | null
    _max: Projet_utilisateursMaxAggregateOutputType | null
  }

  export type Projet_utilisateursAvgAggregateOutputType = {
    projet_id: number | null
    utilisateur_id: number | null
  }

  export type Projet_utilisateursSumAggregateOutputType = {
    projet_id: number | null
    utilisateur_id: number | null
  }

  export type Projet_utilisateursMinAggregateOutputType = {
    projet_id: number | null
    utilisateur_id: number | null
  }

  export type Projet_utilisateursMaxAggregateOutputType = {
    projet_id: number | null
    utilisateur_id: number | null
  }

  export type Projet_utilisateursCountAggregateOutputType = {
    projet_id: number
    utilisateur_id: number
    _all: number
  }


  export type Projet_utilisateursAvgAggregateInputType = {
    projet_id?: true
    utilisateur_id?: true
  }

  export type Projet_utilisateursSumAggregateInputType = {
    projet_id?: true
    utilisateur_id?: true
  }

  export type Projet_utilisateursMinAggregateInputType = {
    projet_id?: true
    utilisateur_id?: true
  }

  export type Projet_utilisateursMaxAggregateInputType = {
    projet_id?: true
    utilisateur_id?: true
  }

  export type Projet_utilisateursCountAggregateInputType = {
    projet_id?: true
    utilisateur_id?: true
    _all?: true
  }

  export type Projet_utilisateursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_utilisateurs to aggregate.
     */
    where?: projet_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_utilisateurs to fetch.
     */
    orderBy?: projet_utilisateursOrderByWithRelationInput | projet_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projet_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projet_utilisateurs
    **/
    _count?: true | Projet_utilisateursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Projet_utilisateursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Projet_utilisateursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Projet_utilisateursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Projet_utilisateursMaxAggregateInputType
  }

  export type GetProjet_utilisateursAggregateType<T extends Projet_utilisateursAggregateArgs> = {
        [P in keyof T & keyof AggregateProjet_utilisateurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjet_utilisateurs[P]>
      : GetScalarType<T[P], AggregateProjet_utilisateurs[P]>
  }




  export type projet_utilisateursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_utilisateursWhereInput
    orderBy?: projet_utilisateursOrderByWithAggregationInput | projet_utilisateursOrderByWithAggregationInput[]
    by: Projet_utilisateursScalarFieldEnum[] | Projet_utilisateursScalarFieldEnum
    having?: projet_utilisateursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Projet_utilisateursCountAggregateInputType | true
    _avg?: Projet_utilisateursAvgAggregateInputType
    _sum?: Projet_utilisateursSumAggregateInputType
    _min?: Projet_utilisateursMinAggregateInputType
    _max?: Projet_utilisateursMaxAggregateInputType
  }

  export type Projet_utilisateursGroupByOutputType = {
    projet_id: number
    utilisateur_id: number
    _count: Projet_utilisateursCountAggregateOutputType | null
    _avg: Projet_utilisateursAvgAggregateOutputType | null
    _sum: Projet_utilisateursSumAggregateOutputType | null
    _min: Projet_utilisateursMinAggregateOutputType | null
    _max: Projet_utilisateursMaxAggregateOutputType | null
  }

  type GetProjet_utilisateursGroupByPayload<T extends projet_utilisateursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Projet_utilisateursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Projet_utilisateursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Projet_utilisateursGroupByOutputType[P]>
            : GetScalarType<T[P], Projet_utilisateursGroupByOutputType[P]>
        }
      >
    >


  export type projet_utilisateursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projet_id?: boolean
    utilisateur_id?: boolean
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    utilisateurs?: boolean | utilisateursDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_utilisateurs"]>


  export type projet_utilisateursSelectScalar = {
    projet_id?: boolean
    utilisateur_id?: boolean
  }

  export type projet_utilisateursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | projetsDefaultArgs<ExtArgs>
    utilisateurs?: boolean | utilisateursDefaultArgs<ExtArgs>
  }

  export type $projet_utilisateursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projet_utilisateurs"
    objects: {
      projets: Prisma.$projetsPayload<ExtArgs>
      utilisateurs: Prisma.$utilisateursPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projet_id: number
      utilisateur_id: number
    }, ExtArgs["result"]["projet_utilisateurs"]>
    composites: {}
  }

  type projet_utilisateursGetPayload<S extends boolean | null | undefined | projet_utilisateursDefaultArgs> = $Result.GetResult<Prisma.$projet_utilisateursPayload, S>

  type projet_utilisateursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projet_utilisateursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Projet_utilisateursCountAggregateInputType | true
    }

  export interface projet_utilisateursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projet_utilisateurs'], meta: { name: 'projet_utilisateurs' } }
    /**
     * Find zero or one Projet_utilisateurs that matches the filter.
     * @param {projet_utilisateursFindUniqueArgs} args - Arguments to find a Projet_utilisateurs
     * @example
     * // Get one Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projet_utilisateursFindUniqueArgs>(args: SelectSubset<T, projet_utilisateursFindUniqueArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Projet_utilisateurs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projet_utilisateursFindUniqueOrThrowArgs} args - Arguments to find a Projet_utilisateurs
     * @example
     * // Get one Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projet_utilisateursFindUniqueOrThrowArgs>(args: SelectSubset<T, projet_utilisateursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Projet_utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_utilisateursFindFirstArgs} args - Arguments to find a Projet_utilisateurs
     * @example
     * // Get one Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projet_utilisateursFindFirstArgs>(args?: SelectSubset<T, projet_utilisateursFindFirstArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Projet_utilisateurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_utilisateursFindFirstOrThrowArgs} args - Arguments to find a Projet_utilisateurs
     * @example
     * // Get one Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projet_utilisateursFindFirstOrThrowArgs>(args?: SelectSubset<T, projet_utilisateursFindFirstOrThrowArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projet_utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_utilisateursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.findMany()
     * 
     * // Get first 10 Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.findMany({ take: 10 })
     * 
     * // Only select the `projet_id`
     * const projet_utilisateursWithProjet_idOnly = await prisma.projet_utilisateurs.findMany({ select: { projet_id: true } })
     * 
     */
    findMany<T extends projet_utilisateursFindManyArgs>(args?: SelectSubset<T, projet_utilisateursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Projet_utilisateurs.
     * @param {projet_utilisateursCreateArgs} args - Arguments to create a Projet_utilisateurs.
     * @example
     * // Create one Projet_utilisateurs
     * const Projet_utilisateurs = await prisma.projet_utilisateurs.create({
     *   data: {
     *     // ... data to create a Projet_utilisateurs
     *   }
     * })
     * 
     */
    create<T extends projet_utilisateursCreateArgs>(args: SelectSubset<T, projet_utilisateursCreateArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projet_utilisateurs.
     * @param {projet_utilisateursCreateManyArgs} args - Arguments to create many Projet_utilisateurs.
     * @example
     * // Create many Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projet_utilisateursCreateManyArgs>(args?: SelectSubset<T, projet_utilisateursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Projet_utilisateurs.
     * @param {projet_utilisateursDeleteArgs} args - Arguments to delete one Projet_utilisateurs.
     * @example
     * // Delete one Projet_utilisateurs
     * const Projet_utilisateurs = await prisma.projet_utilisateurs.delete({
     *   where: {
     *     // ... filter to delete one Projet_utilisateurs
     *   }
     * })
     * 
     */
    delete<T extends projet_utilisateursDeleteArgs>(args: SelectSubset<T, projet_utilisateursDeleteArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Projet_utilisateurs.
     * @param {projet_utilisateursUpdateArgs} args - Arguments to update one Projet_utilisateurs.
     * @example
     * // Update one Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projet_utilisateursUpdateArgs>(args: SelectSubset<T, projet_utilisateursUpdateArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projet_utilisateurs.
     * @param {projet_utilisateursDeleteManyArgs} args - Arguments to filter Projet_utilisateurs to delete.
     * @example
     * // Delete a few Projet_utilisateurs
     * const { count } = await prisma.projet_utilisateurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projet_utilisateursDeleteManyArgs>(args?: SelectSubset<T, projet_utilisateursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projet_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_utilisateursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projet_utilisateursUpdateManyArgs>(args: SelectSubset<T, projet_utilisateursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projet_utilisateurs.
     * @param {projet_utilisateursUpsertArgs} args - Arguments to update or create a Projet_utilisateurs.
     * @example
     * // Update or create a Projet_utilisateurs
     * const projet_utilisateurs = await prisma.projet_utilisateurs.upsert({
     *   create: {
     *     // ... data to create a Projet_utilisateurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projet_utilisateurs we want to update
     *   }
     * })
     */
    upsert<T extends projet_utilisateursUpsertArgs>(args: SelectSubset<T, projet_utilisateursUpsertArgs<ExtArgs>>): Prisma__projet_utilisateursClient<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projet_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_utilisateursCountArgs} args - Arguments to filter Projet_utilisateurs to count.
     * @example
     * // Count the number of Projet_utilisateurs
     * const count = await prisma.projet_utilisateurs.count({
     *   where: {
     *     // ... the filter for the Projet_utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends projet_utilisateursCountArgs>(
      args?: Subset<T, projet_utilisateursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Projet_utilisateursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projet_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Projet_utilisateursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Projet_utilisateursAggregateArgs>(args: Subset<T, Projet_utilisateursAggregateArgs>): Prisma.PrismaPromise<GetProjet_utilisateursAggregateType<T>>

    /**
     * Group by Projet_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_utilisateursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projet_utilisateursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projet_utilisateursGroupByArgs['orderBy'] }
        : { orderBy?: projet_utilisateursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projet_utilisateursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjet_utilisateursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projet_utilisateurs model
   */
  readonly fields: projet_utilisateursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projet_utilisateurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projet_utilisateursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projets<T extends projetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetsDefaultArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    utilisateurs<T extends utilisateursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, utilisateursDefaultArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projet_utilisateurs model
   */ 
  interface projet_utilisateursFieldRefs {
    readonly projet_id: FieldRef<"projet_utilisateurs", 'Int'>
    readonly utilisateur_id: FieldRef<"projet_utilisateurs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * projet_utilisateurs findUnique
   */
  export type projet_utilisateursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which projet_utilisateurs to fetch.
     */
    where: projet_utilisateursWhereUniqueInput
  }

  /**
   * projet_utilisateurs findUniqueOrThrow
   */
  export type projet_utilisateursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which projet_utilisateurs to fetch.
     */
    where: projet_utilisateursWhereUniqueInput
  }

  /**
   * projet_utilisateurs findFirst
   */
  export type projet_utilisateursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which projet_utilisateurs to fetch.
     */
    where?: projet_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_utilisateurs to fetch.
     */
    orderBy?: projet_utilisateursOrderByWithRelationInput | projet_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_utilisateurs.
     */
    cursor?: projet_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_utilisateurs.
     */
    distinct?: Projet_utilisateursScalarFieldEnum | Projet_utilisateursScalarFieldEnum[]
  }

  /**
   * projet_utilisateurs findFirstOrThrow
   */
  export type projet_utilisateursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which projet_utilisateurs to fetch.
     */
    where?: projet_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_utilisateurs to fetch.
     */
    orderBy?: projet_utilisateursOrderByWithRelationInput | projet_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_utilisateurs.
     */
    cursor?: projet_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_utilisateurs.
     */
    distinct?: Projet_utilisateursScalarFieldEnum | Projet_utilisateursScalarFieldEnum[]
  }

  /**
   * projet_utilisateurs findMany
   */
  export type projet_utilisateursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which projet_utilisateurs to fetch.
     */
    where?: projet_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_utilisateurs to fetch.
     */
    orderBy?: projet_utilisateursOrderByWithRelationInput | projet_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projet_utilisateurs.
     */
    cursor?: projet_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_utilisateurs.
     */
    skip?: number
    distinct?: Projet_utilisateursScalarFieldEnum | Projet_utilisateursScalarFieldEnum[]
  }

  /**
   * projet_utilisateurs create
   */
  export type projet_utilisateursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * The data needed to create a projet_utilisateurs.
     */
    data: XOR<projet_utilisateursCreateInput, projet_utilisateursUncheckedCreateInput>
  }

  /**
   * projet_utilisateurs createMany
   */
  export type projet_utilisateursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projet_utilisateurs.
     */
    data: projet_utilisateursCreateManyInput | projet_utilisateursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projet_utilisateurs update
   */
  export type projet_utilisateursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * The data needed to update a projet_utilisateurs.
     */
    data: XOR<projet_utilisateursUpdateInput, projet_utilisateursUncheckedUpdateInput>
    /**
     * Choose, which projet_utilisateurs to update.
     */
    where: projet_utilisateursWhereUniqueInput
  }

  /**
   * projet_utilisateurs updateMany
   */
  export type projet_utilisateursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projet_utilisateurs.
     */
    data: XOR<projet_utilisateursUpdateManyMutationInput, projet_utilisateursUncheckedUpdateManyInput>
    /**
     * Filter which projet_utilisateurs to update
     */
    where?: projet_utilisateursWhereInput
  }

  /**
   * projet_utilisateurs upsert
   */
  export type projet_utilisateursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * The filter to search for the projet_utilisateurs to update in case it exists.
     */
    where: projet_utilisateursWhereUniqueInput
    /**
     * In case the projet_utilisateurs found by the `where` argument doesn't exist, create a new projet_utilisateurs with this data.
     */
    create: XOR<projet_utilisateursCreateInput, projet_utilisateursUncheckedCreateInput>
    /**
     * In case the projet_utilisateurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projet_utilisateursUpdateInput, projet_utilisateursUncheckedUpdateInput>
  }

  /**
   * projet_utilisateurs delete
   */
  export type projet_utilisateursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    /**
     * Filter which projet_utilisateurs to delete.
     */
    where: projet_utilisateursWhereUniqueInput
  }

  /**
   * projet_utilisateurs deleteMany
   */
  export type projet_utilisateursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_utilisateurs to delete
     */
    where?: projet_utilisateursWhereInput
  }

  /**
   * projet_utilisateurs without action
   */
  export type projet_utilisateursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
  }


  /**
   * Model projets
   */

  export type AggregateProjets = {
    _count: ProjetsCountAggregateOutputType | null
    _avg: ProjetsAvgAggregateOutputType | null
    _sum: ProjetsSumAggregateOutputType | null
    _min: ProjetsMinAggregateOutputType | null
    _max: ProjetsMaxAggregateOutputType | null
  }

  export type ProjetsAvgAggregateOutputType = {
    id: number | null
    axe_id: number | null
    priority_id: number | null
    manager: number | null
    budget: number | null
    target_value: number | null
    current_value: number | null
  }

  export type ProjetsSumAggregateOutputType = {
    id: number | null
    axe_id: number | null
    priority_id: number | null
    manager: number | null
    budget: number | null
    target_value: number | null
    current_value: number | null
  }

  export type ProjetsMinAggregateOutputType = {
    id: number | null
    axe_id: number | null
    priority_id: number | null
    manager: number | null
    name: string | null
    description: string | null
    objectif: string | null
    statut: string | null
    budget: number | null
    start_date: Date | null
    end_date: Date | null
    created_date: Date | null
    last_updated: Date | null
    target_value: number | null
    current_value: number | null
  }

  export type ProjetsMaxAggregateOutputType = {
    id: number | null
    axe_id: number | null
    priority_id: number | null
    manager: number | null
    name: string | null
    description: string | null
    objectif: string | null
    statut: string | null
    budget: number | null
    start_date: Date | null
    end_date: Date | null
    created_date: Date | null
    last_updated: Date | null
    target_value: number | null
    current_value: number | null
  }

  export type ProjetsCountAggregateOutputType = {
    id: number
    axe_id: number
    priority_id: number
    manager: number
    name: number
    description: number
    objectif: number
    statut: number
    budget: number
    start_date: number
    end_date: number
    created_date: number
    last_updated: number
    target_value: number
    current_value: number
    _all: number
  }


  export type ProjetsAvgAggregateInputType = {
    id?: true
    axe_id?: true
    priority_id?: true
    manager?: true
    budget?: true
    target_value?: true
    current_value?: true
  }

  export type ProjetsSumAggregateInputType = {
    id?: true
    axe_id?: true
    priority_id?: true
    manager?: true
    budget?: true
    target_value?: true
    current_value?: true
  }

  export type ProjetsMinAggregateInputType = {
    id?: true
    axe_id?: true
    priority_id?: true
    manager?: true
    name?: true
    description?: true
    objectif?: true
    statut?: true
    budget?: true
    start_date?: true
    end_date?: true
    created_date?: true
    last_updated?: true
    target_value?: true
    current_value?: true
  }

  export type ProjetsMaxAggregateInputType = {
    id?: true
    axe_id?: true
    priority_id?: true
    manager?: true
    name?: true
    description?: true
    objectif?: true
    statut?: true
    budget?: true
    start_date?: true
    end_date?: true
    created_date?: true
    last_updated?: true
    target_value?: true
    current_value?: true
  }

  export type ProjetsCountAggregateInputType = {
    id?: true
    axe_id?: true
    priority_id?: true
    manager?: true
    name?: true
    description?: true
    objectif?: true
    statut?: true
    budget?: true
    start_date?: true
    end_date?: true
    created_date?: true
    last_updated?: true
    target_value?: true
    current_value?: true
    _all?: true
  }

  export type ProjetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projets to aggregate.
     */
    where?: projetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetsOrderByWithRelationInput | projetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projets
    **/
    _count?: true | ProjetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjetsMaxAggregateInputType
  }

  export type GetProjetsAggregateType<T extends ProjetsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjets[P]>
      : GetScalarType<T[P], AggregateProjets[P]>
  }




  export type projetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetsWhereInput
    orderBy?: projetsOrderByWithAggregationInput | projetsOrderByWithAggregationInput[]
    by: ProjetsScalarFieldEnum[] | ProjetsScalarFieldEnum
    having?: projetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjetsCountAggregateInputType | true
    _avg?: ProjetsAvgAggregateInputType
    _sum?: ProjetsSumAggregateInputType
    _min?: ProjetsMinAggregateInputType
    _max?: ProjetsMaxAggregateInputType
  }

  export type ProjetsGroupByOutputType = {
    id: number
    axe_id: number
    priority_id: number | null
    manager: number | null
    name: string
    description: string | null
    objectif: string | null
    statut: string | null
    budget: number | null
    start_date: Date | null
    end_date: Date | null
    created_date: Date
    last_updated: Date
    target_value: number | null
    current_value: number | null
    _count: ProjetsCountAggregateOutputType | null
    _avg: ProjetsAvgAggregateOutputType | null
    _sum: ProjetsSumAggregateOutputType | null
    _min: ProjetsMinAggregateOutputType | null
    _max: ProjetsMaxAggregateOutputType | null
  }

  type GetProjetsGroupByPayload<T extends projetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetsGroupByOutputType[P]>
        }
      >
    >


  export type projetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    axe_id?: boolean
    priority_id?: boolean
    manager?: boolean
    name?: boolean
    description?: boolean
    objectif?: boolean
    statut?: boolean
    budget?: boolean
    start_date?: boolean
    end_date?: boolean
    created_date?: boolean
    last_updated?: boolean
    target_value?: boolean
    current_value?: boolean
    commentaires?: boolean | projets$commentairesArgs<ExtArgs>
    documents?: boolean | projets$documentsArgs<ExtArgs>
    indicateurs?: boolean | projets$indicateursArgs<ExtArgs>
    projet_groupes?: boolean | projets$projet_groupesArgs<ExtArgs>
    projet_utilisateurs?: boolean | projets$projet_utilisateursArgs<ExtArgs>
    utilisateurs?: boolean | projets$utilisateursArgs<ExtArgs>
    axes?: boolean | axesDefaultArgs<ExtArgs>
    priority?: boolean | projets$priorityArgs<ExtArgs>
    ressources?: boolean | projets$ressourcesArgs<ExtArgs>
    suggestions?: boolean | projets$suggestionsArgs<ExtArgs>
    taches?: boolean | projets$tachesArgs<ExtArgs>
    _count?: boolean | ProjetsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projets"]>


  export type projetsSelectScalar = {
    id?: boolean
    axe_id?: boolean
    priority_id?: boolean
    manager?: boolean
    name?: boolean
    description?: boolean
    objectif?: boolean
    statut?: boolean
    budget?: boolean
    start_date?: boolean
    end_date?: boolean
    created_date?: boolean
    last_updated?: boolean
    target_value?: boolean
    current_value?: boolean
  }

  export type projetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commentaires?: boolean | projets$commentairesArgs<ExtArgs>
    documents?: boolean | projets$documentsArgs<ExtArgs>
    indicateurs?: boolean | projets$indicateursArgs<ExtArgs>
    projet_groupes?: boolean | projets$projet_groupesArgs<ExtArgs>
    projet_utilisateurs?: boolean | projets$projet_utilisateursArgs<ExtArgs>
    utilisateurs?: boolean | projets$utilisateursArgs<ExtArgs>
    axes?: boolean | axesDefaultArgs<ExtArgs>
    priority?: boolean | projets$priorityArgs<ExtArgs>
    ressources?: boolean | projets$ressourcesArgs<ExtArgs>
    suggestions?: boolean | projets$suggestionsArgs<ExtArgs>
    taches?: boolean | projets$tachesArgs<ExtArgs>
    _count?: boolean | ProjetsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $projetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projets"
    objects: {
      commentaires: Prisma.$commentairesPayload<ExtArgs>[]
      documents: Prisma.$documentsPayload<ExtArgs>[]
      indicateurs: Prisma.$indicateursPayload<ExtArgs>[]
      projet_groupes: Prisma.$projet_groupesPayload<ExtArgs>[]
      projet_utilisateurs: Prisma.$projet_utilisateursPayload<ExtArgs>[]
      utilisateurs: Prisma.$utilisateursPayload<ExtArgs> | null
      axes: Prisma.$axesPayload<ExtArgs>
      priority: Prisma.$priorityPayload<ExtArgs> | null
      ressources: Prisma.$ressourcesPayload<ExtArgs>[]
      suggestions: Prisma.$suggestionsPayload<ExtArgs>[]
      taches: Prisma.$tachesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      axe_id: number
      priority_id: number | null
      manager: number | null
      name: string
      description: string | null
      objectif: string | null
      statut: string | null
      budget: number | null
      start_date: Date | null
      end_date: Date | null
      created_date: Date
      last_updated: Date
      target_value: number | null
      current_value: number | null
    }, ExtArgs["result"]["projets"]>
    composites: {}
  }

  type projetsGetPayload<S extends boolean | null | undefined | projetsDefaultArgs> = $Result.GetResult<Prisma.$projetsPayload, S>

  type projetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projetsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjetsCountAggregateInputType | true
    }

  export interface projetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projets'], meta: { name: 'projets' } }
    /**
     * Find zero or one Projets that matches the filter.
     * @param {projetsFindUniqueArgs} args - Arguments to find a Projets
     * @example
     * // Get one Projets
     * const projets = await prisma.projets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projetsFindUniqueArgs>(args: SelectSubset<T, projetsFindUniqueArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Projets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projetsFindUniqueOrThrowArgs} args - Arguments to find a Projets
     * @example
     * // Get one Projets
     * const projets = await prisma.projets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projetsFindUniqueOrThrowArgs>(args: SelectSubset<T, projetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Projets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetsFindFirstArgs} args - Arguments to find a Projets
     * @example
     * // Get one Projets
     * const projets = await prisma.projets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projetsFindFirstArgs>(args?: SelectSubset<T, projetsFindFirstArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Projets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetsFindFirstOrThrowArgs} args - Arguments to find a Projets
     * @example
     * // Get one Projets
     * const projets = await prisma.projets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projetsFindFirstOrThrowArgs>(args?: SelectSubset<T, projetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projets
     * const projets = await prisma.projets.findMany()
     * 
     * // Get first 10 Projets
     * const projets = await prisma.projets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projetsWithIdOnly = await prisma.projets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projetsFindManyArgs>(args?: SelectSubset<T, projetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Projets.
     * @param {projetsCreateArgs} args - Arguments to create a Projets.
     * @example
     * // Create one Projets
     * const Projets = await prisma.projets.create({
     *   data: {
     *     // ... data to create a Projets
     *   }
     * })
     * 
     */
    create<T extends projetsCreateArgs>(args: SelectSubset<T, projetsCreateArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projets.
     * @param {projetsCreateManyArgs} args - Arguments to create many Projets.
     * @example
     * // Create many Projets
     * const projets = await prisma.projets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projetsCreateManyArgs>(args?: SelectSubset<T, projetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Projets.
     * @param {projetsDeleteArgs} args - Arguments to delete one Projets.
     * @example
     * // Delete one Projets
     * const Projets = await prisma.projets.delete({
     *   where: {
     *     // ... filter to delete one Projets
     *   }
     * })
     * 
     */
    delete<T extends projetsDeleteArgs>(args: SelectSubset<T, projetsDeleteArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Projets.
     * @param {projetsUpdateArgs} args - Arguments to update one Projets.
     * @example
     * // Update one Projets
     * const projets = await prisma.projets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projetsUpdateArgs>(args: SelectSubset<T, projetsUpdateArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projets.
     * @param {projetsDeleteManyArgs} args - Arguments to filter Projets to delete.
     * @example
     * // Delete a few Projets
     * const { count } = await prisma.projets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projetsDeleteManyArgs>(args?: SelectSubset<T, projetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projets
     * const projets = await prisma.projets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projetsUpdateManyArgs>(args: SelectSubset<T, projetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projets.
     * @param {projetsUpsertArgs} args - Arguments to update or create a Projets.
     * @example
     * // Update or create a Projets
     * const projets = await prisma.projets.upsert({
     *   create: {
     *     // ... data to create a Projets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projets we want to update
     *   }
     * })
     */
    upsert<T extends projetsUpsertArgs>(args: SelectSubset<T, projetsUpsertArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetsCountArgs} args - Arguments to filter Projets to count.
     * @example
     * // Count the number of Projets
     * const count = await prisma.projets.count({
     *   where: {
     *     // ... the filter for the Projets we want to count
     *   }
     * })
    **/
    count<T extends projetsCountArgs>(
      args?: Subset<T, projetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjetsAggregateArgs>(args: Subset<T, ProjetsAggregateArgs>): Prisma.PrismaPromise<GetProjetsAggregateType<T>>

    /**
     * Group by Projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projetsGroupByArgs['orderBy'] }
        : { orderBy?: projetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projets model
   */
  readonly fields: projetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commentaires<T extends projets$commentairesArgs<ExtArgs> = {}>(args?: Subset<T, projets$commentairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentairesPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends projets$documentsArgs<ExtArgs> = {}>(args?: Subset<T, projets$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany"> | Null>
    indicateurs<T extends projets$indicateursArgs<ExtArgs> = {}>(args?: Subset<T, projets$indicateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$indicateursPayload<ExtArgs>, T, "findMany"> | Null>
    projet_groupes<T extends projets$projet_groupesArgs<ExtArgs> = {}>(args?: Subset<T, projets$projet_groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_groupesPayload<ExtArgs>, T, "findMany"> | Null>
    projet_utilisateurs<T extends projets$projet_utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, projets$projet_utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "findMany"> | Null>
    utilisateurs<T extends projets$utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, projets$utilisateursArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    axes<T extends axesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, axesDefaultArgs<ExtArgs>>): Prisma__axesClient<$Result.GetResult<Prisma.$axesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    priority<T extends projets$priorityArgs<ExtArgs> = {}>(args?: Subset<T, projets$priorityArgs<ExtArgs>>): Prisma__priorityClient<$Result.GetResult<Prisma.$priorityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ressources<T extends projets$ressourcesArgs<ExtArgs> = {}>(args?: Subset<T, projets$ressourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "findMany"> | Null>
    suggestions<T extends projets$suggestionsArgs<ExtArgs> = {}>(args?: Subset<T, projets$suggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findMany"> | Null>
    taches<T extends projets$tachesArgs<ExtArgs> = {}>(args?: Subset<T, projets$tachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projets model
   */ 
  interface projetsFieldRefs {
    readonly id: FieldRef<"projets", 'Int'>
    readonly axe_id: FieldRef<"projets", 'Int'>
    readonly priority_id: FieldRef<"projets", 'Int'>
    readonly manager: FieldRef<"projets", 'Int'>
    readonly name: FieldRef<"projets", 'String'>
    readonly description: FieldRef<"projets", 'String'>
    readonly objectif: FieldRef<"projets", 'String'>
    readonly statut: FieldRef<"projets", 'String'>
    readonly budget: FieldRef<"projets", 'Int'>
    readonly start_date: FieldRef<"projets", 'DateTime'>
    readonly end_date: FieldRef<"projets", 'DateTime'>
    readonly created_date: FieldRef<"projets", 'DateTime'>
    readonly last_updated: FieldRef<"projets", 'DateTime'>
    readonly target_value: FieldRef<"projets", 'Float'>
    readonly current_value: FieldRef<"projets", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * projets findUnique
   */
  export type projetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * Filter, which projets to fetch.
     */
    where: projetsWhereUniqueInput
  }

  /**
   * projets findUniqueOrThrow
   */
  export type projetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * Filter, which projets to fetch.
     */
    where: projetsWhereUniqueInput
  }

  /**
   * projets findFirst
   */
  export type projetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * Filter, which projets to fetch.
     */
    where?: projetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetsOrderByWithRelationInput | projetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projets.
     */
    cursor?: projetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projets.
     */
    distinct?: ProjetsScalarFieldEnum | ProjetsScalarFieldEnum[]
  }

  /**
   * projets findFirstOrThrow
   */
  export type projetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * Filter, which projets to fetch.
     */
    where?: projetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetsOrderByWithRelationInput | projetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projets.
     */
    cursor?: projetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projets.
     */
    distinct?: ProjetsScalarFieldEnum | ProjetsScalarFieldEnum[]
  }

  /**
   * projets findMany
   */
  export type projetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * Filter, which projets to fetch.
     */
    where?: projetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetsOrderByWithRelationInput | projetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projets.
     */
    cursor?: projetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    distinct?: ProjetsScalarFieldEnum | ProjetsScalarFieldEnum[]
  }

  /**
   * projets create
   */
  export type projetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * The data needed to create a projets.
     */
    data: XOR<projetsCreateInput, projetsUncheckedCreateInput>
  }

  /**
   * projets createMany
   */
  export type projetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projets.
     */
    data: projetsCreateManyInput | projetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projets update
   */
  export type projetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * The data needed to update a projets.
     */
    data: XOR<projetsUpdateInput, projetsUncheckedUpdateInput>
    /**
     * Choose, which projets to update.
     */
    where: projetsWhereUniqueInput
  }

  /**
   * projets updateMany
   */
  export type projetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projets.
     */
    data: XOR<projetsUpdateManyMutationInput, projetsUncheckedUpdateManyInput>
    /**
     * Filter which projets to update
     */
    where?: projetsWhereInput
  }

  /**
   * projets upsert
   */
  export type projetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * The filter to search for the projets to update in case it exists.
     */
    where: projetsWhereUniqueInput
    /**
     * In case the projets found by the `where` argument doesn't exist, create a new projets with this data.
     */
    create: XOR<projetsCreateInput, projetsUncheckedCreateInput>
    /**
     * In case the projets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projetsUpdateInput, projetsUncheckedUpdateInput>
  }

  /**
   * projets delete
   */
  export type projetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    /**
     * Filter which projets to delete.
     */
    where: projetsWhereUniqueInput
  }

  /**
   * projets deleteMany
   */
  export type projetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projets to delete
     */
    where?: projetsWhereInput
  }

  /**
   * projets.commentaires
   */
  export type projets$commentairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commentaires
     */
    select?: commentairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentairesInclude<ExtArgs> | null
    where?: commentairesWhereInput
    orderBy?: commentairesOrderByWithRelationInput | commentairesOrderByWithRelationInput[]
    cursor?: commentairesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentairesScalarFieldEnum | CommentairesScalarFieldEnum[]
  }

  /**
   * projets.documents
   */
  export type projets$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    cursor?: documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * projets.indicateurs
   */
  export type projets$indicateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicateurs
     */
    select?: indicateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicateursInclude<ExtArgs> | null
    where?: indicateursWhereInput
    orderBy?: indicateursOrderByWithRelationInput | indicateursOrderByWithRelationInput[]
    cursor?: indicateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicateursScalarFieldEnum | IndicateursScalarFieldEnum[]
  }

  /**
   * projets.projet_groupes
   */
  export type projets$projet_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_groupes
     */
    select?: projet_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_groupesInclude<ExtArgs> | null
    where?: projet_groupesWhereInput
    orderBy?: projet_groupesOrderByWithRelationInput | projet_groupesOrderByWithRelationInput[]
    cursor?: projet_groupesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_groupesScalarFieldEnum | Projet_groupesScalarFieldEnum[]
  }

  /**
   * projets.projet_utilisateurs
   */
  export type projets$projet_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    where?: projet_utilisateursWhereInput
    orderBy?: projet_utilisateursOrderByWithRelationInput | projet_utilisateursOrderByWithRelationInput[]
    cursor?: projet_utilisateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_utilisateursScalarFieldEnum | Projet_utilisateursScalarFieldEnum[]
  }

  /**
   * projets.utilisateurs
   */
  export type projets$utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    where?: utilisateursWhereInput
  }

  /**
   * projets.priority
   */
  export type projets$priorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priority
     */
    select?: prioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: priorityInclude<ExtArgs> | null
    where?: priorityWhereInput
  }

  /**
   * projets.ressources
   */
  export type projets$ressourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    where?: ressourcesWhereInput
    orderBy?: ressourcesOrderByWithRelationInput | ressourcesOrderByWithRelationInput[]
    cursor?: ressourcesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RessourcesScalarFieldEnum | RessourcesScalarFieldEnum[]
  }

  /**
   * projets.suggestions
   */
  export type projets$suggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    where?: suggestionsWhereInput
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    cursor?: suggestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * projets.taches
   */
  export type projets$tachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    where?: tachesWhereInput
    orderBy?: tachesOrderByWithRelationInput | tachesOrderByWithRelationInput[]
    cursor?: tachesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TachesScalarFieldEnum | TachesScalarFieldEnum[]
  }

  /**
   * projets without action
   */
  export type projetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
  }


  /**
   * Model ressources
   */

  export type AggregateRessources = {
    _count: RessourcesCountAggregateOutputType | null
    _avg: RessourcesAvgAggregateOutputType | null
    _sum: RessourcesSumAggregateOutputType | null
    _min: RessourcesMinAggregateOutputType | null
    _max: RessourcesMaxAggregateOutputType | null
  }

  export type RessourcesAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
    quantity: number | null
    cost: Decimal | null
  }

  export type RessourcesSumAggregateOutputType = {
    id: number | null
    project_id: number | null
    quantity: number | null
    cost: Decimal | null
  }

  export type RessourcesMinAggregateOutputType = {
    id: number | null
    project_id: number | null
    name: string | null
    description: string | null
    quantity: number | null
    unit: string | null
    cost: Decimal | null
  }

  export type RessourcesMaxAggregateOutputType = {
    id: number | null
    project_id: number | null
    name: string | null
    description: string | null
    quantity: number | null
    unit: string | null
    cost: Decimal | null
  }

  export type RessourcesCountAggregateOutputType = {
    id: number
    project_id: number
    name: number
    description: number
    quantity: number
    unit: number
    cost: number
    _all: number
  }


  export type RessourcesAvgAggregateInputType = {
    id?: true
    project_id?: true
    quantity?: true
    cost?: true
  }

  export type RessourcesSumAggregateInputType = {
    id?: true
    project_id?: true
    quantity?: true
    cost?: true
  }

  export type RessourcesMinAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    description?: true
    quantity?: true
    unit?: true
    cost?: true
  }

  export type RessourcesMaxAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    description?: true
    quantity?: true
    unit?: true
    cost?: true
  }

  export type RessourcesCountAggregateInputType = {
    id?: true
    project_id?: true
    name?: true
    description?: true
    quantity?: true
    unit?: true
    cost?: true
    _all?: true
  }

  export type RessourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ressources to aggregate.
     */
    where?: ressourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources to fetch.
     */
    orderBy?: ressourcesOrderByWithRelationInput | ressourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ressourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ressources
    **/
    _count?: true | RessourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RessourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RessourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RessourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RessourcesMaxAggregateInputType
  }

  export type GetRessourcesAggregateType<T extends RessourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateRessources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRessources[P]>
      : GetScalarType<T[P], AggregateRessources[P]>
  }




  export type ressourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ressourcesWhereInput
    orderBy?: ressourcesOrderByWithAggregationInput | ressourcesOrderByWithAggregationInput[]
    by: RessourcesScalarFieldEnum[] | RessourcesScalarFieldEnum
    having?: ressourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RessourcesCountAggregateInputType | true
    _avg?: RessourcesAvgAggregateInputType
    _sum?: RessourcesSumAggregateInputType
    _min?: RessourcesMinAggregateInputType
    _max?: RessourcesMaxAggregateInputType
  }

  export type RessourcesGroupByOutputType = {
    id: number
    project_id: number
    name: string
    description: string | null
    quantity: number | null
    unit: string | null
    cost: Decimal | null
    _count: RessourcesCountAggregateOutputType | null
    _avg: RessourcesAvgAggregateOutputType | null
    _sum: RessourcesSumAggregateOutputType | null
    _min: RessourcesMinAggregateOutputType | null
    _max: RessourcesMaxAggregateOutputType | null
  }

  type GetRessourcesGroupByPayload<T extends ressourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RessourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RessourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RessourcesGroupByOutputType[P]>
            : GetScalarType<T[P], RessourcesGroupByOutputType[P]>
        }
      >
    >


  export type ressourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    cost?: boolean
    projets?: boolean | projetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ressources"]>


  export type ressourcesSelectScalar = {
    id?: boolean
    project_id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    cost?: boolean
  }

  export type ressourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projets?: boolean | projetsDefaultArgs<ExtArgs>
  }

  export type $ressourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ressources"
    objects: {
      projets: Prisma.$projetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      project_id: number
      name: string
      description: string | null
      quantity: number | null
      unit: string | null
      cost: Prisma.Decimal | null
    }, ExtArgs["result"]["ressources"]>
    composites: {}
  }

  type ressourcesGetPayload<S extends boolean | null | undefined | ressourcesDefaultArgs> = $Result.GetResult<Prisma.$ressourcesPayload, S>

  type ressourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ressourcesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RessourcesCountAggregateInputType | true
    }

  export interface ressourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ressources'], meta: { name: 'ressources' } }
    /**
     * Find zero or one Ressources that matches the filter.
     * @param {ressourcesFindUniqueArgs} args - Arguments to find a Ressources
     * @example
     * // Get one Ressources
     * const ressources = await prisma.ressources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ressourcesFindUniqueArgs>(args: SelectSubset<T, ressourcesFindUniqueArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ressources that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ressourcesFindUniqueOrThrowArgs} args - Arguments to find a Ressources
     * @example
     * // Get one Ressources
     * const ressources = await prisma.ressources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ressourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, ressourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ressources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressourcesFindFirstArgs} args - Arguments to find a Ressources
     * @example
     * // Get one Ressources
     * const ressources = await prisma.ressources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ressourcesFindFirstArgs>(args?: SelectSubset<T, ressourcesFindFirstArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ressources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressourcesFindFirstOrThrowArgs} args - Arguments to find a Ressources
     * @example
     * // Get one Ressources
     * const ressources = await prisma.ressources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ressourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, ressourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ressources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ressources
     * const ressources = await prisma.ressources.findMany()
     * 
     * // Get first 10 Ressources
     * const ressources = await prisma.ressources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ressourcesWithIdOnly = await prisma.ressources.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ressourcesFindManyArgs>(args?: SelectSubset<T, ressourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ressources.
     * @param {ressourcesCreateArgs} args - Arguments to create a Ressources.
     * @example
     * // Create one Ressources
     * const Ressources = await prisma.ressources.create({
     *   data: {
     *     // ... data to create a Ressources
     *   }
     * })
     * 
     */
    create<T extends ressourcesCreateArgs>(args: SelectSubset<T, ressourcesCreateArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ressources.
     * @param {ressourcesCreateManyArgs} args - Arguments to create many Ressources.
     * @example
     * // Create many Ressources
     * const ressources = await prisma.ressources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ressourcesCreateManyArgs>(args?: SelectSubset<T, ressourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ressources.
     * @param {ressourcesDeleteArgs} args - Arguments to delete one Ressources.
     * @example
     * // Delete one Ressources
     * const Ressources = await prisma.ressources.delete({
     *   where: {
     *     // ... filter to delete one Ressources
     *   }
     * })
     * 
     */
    delete<T extends ressourcesDeleteArgs>(args: SelectSubset<T, ressourcesDeleteArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ressources.
     * @param {ressourcesUpdateArgs} args - Arguments to update one Ressources.
     * @example
     * // Update one Ressources
     * const ressources = await prisma.ressources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ressourcesUpdateArgs>(args: SelectSubset<T, ressourcesUpdateArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ressources.
     * @param {ressourcesDeleteManyArgs} args - Arguments to filter Ressources to delete.
     * @example
     * // Delete a few Ressources
     * const { count } = await prisma.ressources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ressourcesDeleteManyArgs>(args?: SelectSubset<T, ressourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ressources
     * const ressources = await prisma.ressources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ressourcesUpdateManyArgs>(args: SelectSubset<T, ressourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ressources.
     * @param {ressourcesUpsertArgs} args - Arguments to update or create a Ressources.
     * @example
     * // Update or create a Ressources
     * const ressources = await prisma.ressources.upsert({
     *   create: {
     *     // ... data to create a Ressources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ressources we want to update
     *   }
     * })
     */
    upsert<T extends ressourcesUpsertArgs>(args: SelectSubset<T, ressourcesUpsertArgs<ExtArgs>>): Prisma__ressourcesClient<$Result.GetResult<Prisma.$ressourcesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressourcesCountArgs} args - Arguments to filter Ressources to count.
     * @example
     * // Count the number of Ressources
     * const count = await prisma.ressources.count({
     *   where: {
     *     // ... the filter for the Ressources we want to count
     *   }
     * })
    **/
    count<T extends ressourcesCountArgs>(
      args?: Subset<T, ressourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RessourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RessourcesAggregateArgs>(args: Subset<T, RessourcesAggregateArgs>): Prisma.PrismaPromise<GetRessourcesAggregateType<T>>

    /**
     * Group by Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ressourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ressourcesGroupByArgs['orderBy'] }
        : { orderBy?: ressourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ressourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRessourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ressources model
   */
  readonly fields: ressourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ressources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ressourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projets<T extends projetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetsDefaultArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ressources model
   */ 
  interface ressourcesFieldRefs {
    readonly id: FieldRef<"ressources", 'Int'>
    readonly project_id: FieldRef<"ressources", 'Int'>
    readonly name: FieldRef<"ressources", 'String'>
    readonly description: FieldRef<"ressources", 'String'>
    readonly quantity: FieldRef<"ressources", 'Float'>
    readonly unit: FieldRef<"ressources", 'String'>
    readonly cost: FieldRef<"ressources", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ressources findUnique
   */
  export type ressourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * Filter, which ressources to fetch.
     */
    where: ressourcesWhereUniqueInput
  }

  /**
   * ressources findUniqueOrThrow
   */
  export type ressourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * Filter, which ressources to fetch.
     */
    where: ressourcesWhereUniqueInput
  }

  /**
   * ressources findFirst
   */
  export type ressourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * Filter, which ressources to fetch.
     */
    where?: ressourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources to fetch.
     */
    orderBy?: ressourcesOrderByWithRelationInput | ressourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ressources.
     */
    cursor?: ressourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ressources.
     */
    distinct?: RessourcesScalarFieldEnum | RessourcesScalarFieldEnum[]
  }

  /**
   * ressources findFirstOrThrow
   */
  export type ressourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * Filter, which ressources to fetch.
     */
    where?: ressourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources to fetch.
     */
    orderBy?: ressourcesOrderByWithRelationInput | ressourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ressources.
     */
    cursor?: ressourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ressources.
     */
    distinct?: RessourcesScalarFieldEnum | RessourcesScalarFieldEnum[]
  }

  /**
   * ressources findMany
   */
  export type ressourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * Filter, which ressources to fetch.
     */
    where?: ressourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources to fetch.
     */
    orderBy?: ressourcesOrderByWithRelationInput | ressourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ressources.
     */
    cursor?: ressourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources.
     */
    skip?: number
    distinct?: RessourcesScalarFieldEnum | RessourcesScalarFieldEnum[]
  }

  /**
   * ressources create
   */
  export type ressourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a ressources.
     */
    data: XOR<ressourcesCreateInput, ressourcesUncheckedCreateInput>
  }

  /**
   * ressources createMany
   */
  export type ressourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ressources.
     */
    data: ressourcesCreateManyInput | ressourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ressources update
   */
  export type ressourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a ressources.
     */
    data: XOR<ressourcesUpdateInput, ressourcesUncheckedUpdateInput>
    /**
     * Choose, which ressources to update.
     */
    where: ressourcesWhereUniqueInput
  }

  /**
   * ressources updateMany
   */
  export type ressourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ressources.
     */
    data: XOR<ressourcesUpdateManyMutationInput, ressourcesUncheckedUpdateManyInput>
    /**
     * Filter which ressources to update
     */
    where?: ressourcesWhereInput
  }

  /**
   * ressources upsert
   */
  export type ressourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the ressources to update in case it exists.
     */
    where: ressourcesWhereUniqueInput
    /**
     * In case the ressources found by the `where` argument doesn't exist, create a new ressources with this data.
     */
    create: XOR<ressourcesCreateInput, ressourcesUncheckedCreateInput>
    /**
     * In case the ressources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ressourcesUpdateInput, ressourcesUncheckedUpdateInput>
  }

  /**
   * ressources delete
   */
  export type ressourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
    /**
     * Filter which ressources to delete.
     */
    where: ressourcesWhereUniqueInput
  }

  /**
   * ressources deleteMany
   */
  export type ressourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ressources to delete
     */
    where?: ressourcesWhereInput
  }

  /**
   * ressources without action
   */
  export type ressourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources
     */
    select?: ressourcesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ressourcesInclude<ExtArgs> | null
  }


  /**
   * Model role_permissions
   */

  export type AggregateRole_permissions = {
    _count: Role_permissionsCountAggregateOutputType | null
    _avg: Role_permissionsAvgAggregateOutputType | null
    _sum: Role_permissionsSumAggregateOutputType | null
    _min: Role_permissionsMinAggregateOutputType | null
    _max: Role_permissionsMaxAggregateOutputType | null
  }

  export type Role_permissionsAvgAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
  }

  export type Role_permissionsSumAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
  }

  export type Role_permissionsMinAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
  }

  export type Role_permissionsMaxAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
  }

  export type Role_permissionsCountAggregateOutputType = {
    role_id: number
    permission_id: number
    _all: number
  }


  export type Role_permissionsAvgAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type Role_permissionsSumAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type Role_permissionsMinAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type Role_permissionsMaxAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type Role_permissionsCountAggregateInputType = {
    role_id?: true
    permission_id?: true
    _all?: true
  }

  export type Role_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permissions to aggregate.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_permissions
    **/
    _count?: true | Role_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Role_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Role_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_permissionsMaxAggregateInputType
  }

  export type GetRole_permissionsAggregateType<T extends Role_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_permissions[P]>
      : GetScalarType<T[P], AggregateRole_permissions[P]>
  }




  export type role_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithAggregationInput | role_permissionsOrderByWithAggregationInput[]
    by: Role_permissionsScalarFieldEnum[] | Role_permissionsScalarFieldEnum
    having?: role_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_permissionsCountAggregateInputType | true
    _avg?: Role_permissionsAvgAggregateInputType
    _sum?: Role_permissionsSumAggregateInputType
    _min?: Role_permissionsMinAggregateInputType
    _max?: Role_permissionsMaxAggregateInputType
  }

  export type Role_permissionsGroupByOutputType = {
    role_id: number
    permission_id: number
    _count: Role_permissionsCountAggregateOutputType | null
    _avg: Role_permissionsAvgAggregateOutputType | null
    _sum: Role_permissionsSumAggregateOutputType | null
    _min: Role_permissionsMinAggregateOutputType | null
    _max: Role_permissionsMaxAggregateOutputType | null
  }

  type GetRole_permissionsGroupByPayload<T extends role_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Role_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Role_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type role_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    permission_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_permissions"]>


  export type role_permissionsSelectScalar = {
    role_id?: boolean
    permission_id?: boolean
  }

  export type role_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }

  export type $role_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role_permissions"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
      permissions: Prisma.$permissionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      permission_id: number
    }, ExtArgs["result"]["role_permissions"]>
    composites: {}
  }

  type role_permissionsGetPayload<S extends boolean | null | undefined | role_permissionsDefaultArgs> = $Result.GetResult<Prisma.$role_permissionsPayload, S>

  type role_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<role_permissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Role_permissionsCountAggregateInputType | true
    }

  export interface role_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role_permissions'], meta: { name: 'role_permissions' } }
    /**
     * Find zero or one Role_permissions that matches the filter.
     * @param {role_permissionsFindUniqueArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends role_permissionsFindUniqueArgs>(args: SelectSubset<T, role_permissionsFindUniqueArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role_permissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {role_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends role_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, role_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindFirstArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends role_permissionsFindFirstArgs>(args?: SelectSubset<T, role_permissionsFindFirstArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindFirstOrThrowArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends role_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, role_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_permissions
     * const role_permissions = await prisma.role_permissions.findMany()
     * 
     * // Get first 10 Role_permissions
     * const role_permissions = await prisma.role_permissions.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const role_permissionsWithRole_idOnly = await prisma.role_permissions.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends role_permissionsFindManyArgs>(args?: SelectSubset<T, role_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role_permissions.
     * @param {role_permissionsCreateArgs} args - Arguments to create a Role_permissions.
     * @example
     * // Create one Role_permissions
     * const Role_permissions = await prisma.role_permissions.create({
     *   data: {
     *     // ... data to create a Role_permissions
     *   }
     * })
     * 
     */
    create<T extends role_permissionsCreateArgs>(args: SelectSubset<T, role_permissionsCreateArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Role_permissions.
     * @param {role_permissionsCreateManyArgs} args - Arguments to create many Role_permissions.
     * @example
     * // Create many Role_permissions
     * const role_permissions = await prisma.role_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends role_permissionsCreateManyArgs>(args?: SelectSubset<T, role_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role_permissions.
     * @param {role_permissionsDeleteArgs} args - Arguments to delete one Role_permissions.
     * @example
     * // Delete one Role_permissions
     * const Role_permissions = await prisma.role_permissions.delete({
     *   where: {
     *     // ... filter to delete one Role_permissions
     *   }
     * })
     * 
     */
    delete<T extends role_permissionsDeleteArgs>(args: SelectSubset<T, role_permissionsDeleteArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role_permissions.
     * @param {role_permissionsUpdateArgs} args - Arguments to update one Role_permissions.
     * @example
     * // Update one Role_permissions
     * const role_permissions = await prisma.role_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends role_permissionsUpdateArgs>(args: SelectSubset<T, role_permissionsUpdateArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Role_permissions.
     * @param {role_permissionsDeleteManyArgs} args - Arguments to filter Role_permissions to delete.
     * @example
     * // Delete a few Role_permissions
     * const { count } = await prisma.role_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends role_permissionsDeleteManyArgs>(args?: SelectSubset<T, role_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_permissions
     * const role_permissions = await prisma.role_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends role_permissionsUpdateManyArgs>(args: SelectSubset<T, role_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role_permissions.
     * @param {role_permissionsUpsertArgs} args - Arguments to update or create a Role_permissions.
     * @example
     * // Update or create a Role_permissions
     * const role_permissions = await prisma.role_permissions.upsert({
     *   create: {
     *     // ... data to create a Role_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_permissions we want to update
     *   }
     * })
     */
    upsert<T extends role_permissionsUpsertArgs>(args: SelectSubset<T, role_permissionsUpsertArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsCountArgs} args - Arguments to filter Role_permissions to count.
     * @example
     * // Count the number of Role_permissions
     * const count = await prisma.role_permissions.count({
     *   where: {
     *     // ... the filter for the Role_permissions we want to count
     *   }
     * })
    **/
    count<T extends role_permissionsCountArgs>(
      args?: Subset<T, role_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_permissionsAggregateArgs>(args: Subset<T, Role_permissionsAggregateArgs>): Prisma.PrismaPromise<GetRole_permissionsAggregateType<T>>

    /**
     * Group by Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends role_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: role_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: role_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, role_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role_permissions model
   */
  readonly fields: role_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__role_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permissions<T extends permissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionsDefaultArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role_permissions model
   */ 
  interface role_permissionsFieldRefs {
    readonly role_id: FieldRef<"role_permissions", 'Int'>
    readonly permission_id: FieldRef<"role_permissions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * role_permissions findUnique
   */
  export type role_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions findUniqueOrThrow
   */
  export type role_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions findFirst
   */
  export type role_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions findFirstOrThrow
   */
  export type role_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions findMany
   */
  export type role_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions create
   */
  export type role_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a role_permissions.
     */
    data: XOR<role_permissionsCreateInput, role_permissionsUncheckedCreateInput>
  }

  /**
   * role_permissions createMany
   */
  export type role_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many role_permissions.
     */
    data: role_permissionsCreateManyInput | role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_permissions update
   */
  export type role_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a role_permissions.
     */
    data: XOR<role_permissionsUpdateInput, role_permissionsUncheckedUpdateInput>
    /**
     * Choose, which role_permissions to update.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions updateMany
   */
  export type role_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update role_permissions.
     */
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which role_permissions to update
     */
    where?: role_permissionsWhereInput
  }

  /**
   * role_permissions upsert
   */
  export type role_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the role_permissions to update in case it exists.
     */
    where: role_permissionsWhereUniqueInput
    /**
     * In case the role_permissions found by the `where` argument doesn't exist, create a new role_permissions with this data.
     */
    create: XOR<role_permissionsCreateInput, role_permissionsUncheckedCreateInput>
    /**
     * In case the role_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_permissionsUpdateInput, role_permissionsUncheckedUpdateInput>
  }

  /**
   * role_permissions delete
   */
  export type role_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter which role_permissions to delete.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions deleteMany
   */
  export type role_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permissions to delete
     */
    where?: role_permissionsWhereInput
  }

  /**
   * role_permissions without action
   */
  export type role_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    nom: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    created_date: Date | null
    last_updated: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    nom: number
    created_date: number
    last_updated: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    nom?: true
    created_date?: true
    last_updated?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    nom?: true
    created_date?: true
    last_updated?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    nom?: true
    created_date?: true
    last_updated?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    nom: string
    created_date: Date
    last_updated: Date
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    created_date?: boolean
    last_updated?: boolean
    comptes?: boolean | roles$comptesArgs<ExtArgs>
    role_permissions?: boolean | roles$role_permissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>


  export type rolesSelectScalar = {
    id?: boolean
    nom?: boolean
    created_date?: boolean
    last_updated?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comptes?: boolean | roles$comptesArgs<ExtArgs>
    role_permissions?: boolean | roles$role_permissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      comptes: Prisma.$comptesPayload<ExtArgs>[]
      role_permissions: Prisma.$role_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      created_date: Date
      last_updated: Date
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comptes<T extends roles$comptesArgs<ExtArgs> = {}>(args?: Subset<T, roles$comptesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findMany"> | Null>
    role_permissions<T extends roles$role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, roles$role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly nom: FieldRef<"roles", 'String'>
    readonly created_date: FieldRef<"roles", 'DateTime'>
    readonly last_updated: FieldRef<"roles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.comptes
   */
  export type roles$comptesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    where?: comptesWhereInput
    orderBy?: comptesOrderByWithRelationInput | comptesOrderByWithRelationInput[]
    cursor?: comptesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComptesScalarFieldEnum | ComptesScalarFieldEnum[]
  }

  /**
   * roles.role_permissions
   */
  export type roles$role_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    cursor?: role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model suggestions
   */

  export type AggregateSuggestions = {
    _count: SuggestionsCountAggregateOutputType | null
    _avg: SuggestionsAvgAggregateOutputType | null
    _sum: SuggestionsSumAggregateOutputType | null
    _min: SuggestionsMinAggregateOutputType | null
    _max: SuggestionsMaxAggregateOutputType | null
  }

  export type SuggestionsAvgAggregateOutputType = {
    id: number | null
    compte_id: number | null
    project_id: number | null
  }

  export type SuggestionsSumAggregateOutputType = {
    id: number | null
    compte_id: number | null
    project_id: number | null
  }

  export type SuggestionsMinAggregateOutputType = {
    id: number | null
    compte_id: number | null
    project_id: number | null
    suggestion_content: string | null
    submitted_at: Date | null
  }

  export type SuggestionsMaxAggregateOutputType = {
    id: number | null
    compte_id: number | null
    project_id: number | null
    suggestion_content: string | null
    submitted_at: Date | null
  }

  export type SuggestionsCountAggregateOutputType = {
    id: number
    compte_id: number
    project_id: number
    suggestion_content: number
    submitted_at: number
    _all: number
  }


  export type SuggestionsAvgAggregateInputType = {
    id?: true
    compte_id?: true
    project_id?: true
  }

  export type SuggestionsSumAggregateInputType = {
    id?: true
    compte_id?: true
    project_id?: true
  }

  export type SuggestionsMinAggregateInputType = {
    id?: true
    compte_id?: true
    project_id?: true
    suggestion_content?: true
    submitted_at?: true
  }

  export type SuggestionsMaxAggregateInputType = {
    id?: true
    compte_id?: true
    project_id?: true
    suggestion_content?: true
    submitted_at?: true
  }

  export type SuggestionsCountAggregateInputType = {
    id?: true
    compte_id?: true
    project_id?: true
    suggestion_content?: true
    submitted_at?: true
    _all?: true
  }

  export type SuggestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suggestions to aggregate.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suggestions
    **/
    _count?: true | SuggestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuggestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuggestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestionsMaxAggregateInputType
  }

  export type GetSuggestionsAggregateType<T extends SuggestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestions[P]>
      : GetScalarType<T[P], AggregateSuggestions[P]>
  }




  export type suggestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suggestionsWhereInput
    orderBy?: suggestionsOrderByWithAggregationInput | suggestionsOrderByWithAggregationInput[]
    by: SuggestionsScalarFieldEnum[] | SuggestionsScalarFieldEnum
    having?: suggestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestionsCountAggregateInputType | true
    _avg?: SuggestionsAvgAggregateInputType
    _sum?: SuggestionsSumAggregateInputType
    _min?: SuggestionsMinAggregateInputType
    _max?: SuggestionsMaxAggregateInputType
  }

  export type SuggestionsGroupByOutputType = {
    id: number
    compte_id: number
    project_id: number
    suggestion_content: string
    submitted_at: Date
    _count: SuggestionsCountAggregateOutputType | null
    _avg: SuggestionsAvgAggregateOutputType | null
    _sum: SuggestionsSumAggregateOutputType | null
    _min: SuggestionsMinAggregateOutputType | null
    _max: SuggestionsMaxAggregateOutputType | null
  }

  type GetSuggestionsGroupByPayload<T extends suggestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestionsGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestionsGroupByOutputType[P]>
        }
      >
    >


  export type suggestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    compte_id?: boolean
    project_id?: boolean
    suggestion_content?: boolean
    submitted_at?: boolean
    comptes?: boolean | comptesDefaultArgs<ExtArgs>
    projets?: boolean | projetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestions"]>


  export type suggestionsSelectScalar = {
    id?: boolean
    compte_id?: boolean
    project_id?: boolean
    suggestion_content?: boolean
    submitted_at?: boolean
  }

  export type suggestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comptes?: boolean | comptesDefaultArgs<ExtArgs>
    projets?: boolean | projetsDefaultArgs<ExtArgs>
  }

  export type $suggestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "suggestions"
    objects: {
      comptes: Prisma.$comptesPayload<ExtArgs>
      projets: Prisma.$projetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      compte_id: number
      project_id: number
      suggestion_content: string
      submitted_at: Date
    }, ExtArgs["result"]["suggestions"]>
    composites: {}
  }

  type suggestionsGetPayload<S extends boolean | null | undefined | suggestionsDefaultArgs> = $Result.GetResult<Prisma.$suggestionsPayload, S>

  type suggestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<suggestionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SuggestionsCountAggregateInputType | true
    }

  export interface suggestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['suggestions'], meta: { name: 'suggestions' } }
    /**
     * Find zero or one Suggestions that matches the filter.
     * @param {suggestionsFindUniqueArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends suggestionsFindUniqueArgs>(args: SelectSubset<T, suggestionsFindUniqueArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Suggestions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {suggestionsFindUniqueOrThrowArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends suggestionsFindUniqueOrThrowArgs>(args: SelectSubset<T, suggestionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindFirstArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends suggestionsFindFirstArgs>(args?: SelectSubset<T, suggestionsFindFirstArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Suggestions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindFirstOrThrowArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends suggestionsFindFirstOrThrowArgs>(args?: SelectSubset<T, suggestionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suggestions
     * const suggestions = await prisma.suggestions.findMany()
     * 
     * // Get first 10 Suggestions
     * const suggestions = await prisma.suggestions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestionsWithIdOnly = await prisma.suggestions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends suggestionsFindManyArgs>(args?: SelectSubset<T, suggestionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Suggestions.
     * @param {suggestionsCreateArgs} args - Arguments to create a Suggestions.
     * @example
     * // Create one Suggestions
     * const Suggestions = await prisma.suggestions.create({
     *   data: {
     *     // ... data to create a Suggestions
     *   }
     * })
     * 
     */
    create<T extends suggestionsCreateArgs>(args: SelectSubset<T, suggestionsCreateArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suggestions.
     * @param {suggestionsCreateManyArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestions = await prisma.suggestions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends suggestionsCreateManyArgs>(args?: SelectSubset<T, suggestionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Suggestions.
     * @param {suggestionsDeleteArgs} args - Arguments to delete one Suggestions.
     * @example
     * // Delete one Suggestions
     * const Suggestions = await prisma.suggestions.delete({
     *   where: {
     *     // ... filter to delete one Suggestions
     *   }
     * })
     * 
     */
    delete<T extends suggestionsDeleteArgs>(args: SelectSubset<T, suggestionsDeleteArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Suggestions.
     * @param {suggestionsUpdateArgs} args - Arguments to update one Suggestions.
     * @example
     * // Update one Suggestions
     * const suggestions = await prisma.suggestions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends suggestionsUpdateArgs>(args: SelectSubset<T, suggestionsUpdateArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suggestions.
     * @param {suggestionsDeleteManyArgs} args - Arguments to filter Suggestions to delete.
     * @example
     * // Delete a few Suggestions
     * const { count } = await prisma.suggestions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends suggestionsDeleteManyArgs>(args?: SelectSubset<T, suggestionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suggestions
     * const suggestions = await prisma.suggestions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends suggestionsUpdateManyArgs>(args: SelectSubset<T, suggestionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Suggestions.
     * @param {suggestionsUpsertArgs} args - Arguments to update or create a Suggestions.
     * @example
     * // Update or create a Suggestions
     * const suggestions = await prisma.suggestions.upsert({
     *   create: {
     *     // ... data to create a Suggestions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suggestions we want to update
     *   }
     * })
     */
    upsert<T extends suggestionsUpsertArgs>(args: SelectSubset<T, suggestionsUpsertArgs<ExtArgs>>): Prisma__suggestionsClient<$Result.GetResult<Prisma.$suggestionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsCountArgs} args - Arguments to filter Suggestions to count.
     * @example
     * // Count the number of Suggestions
     * const count = await prisma.suggestions.count({
     *   where: {
     *     // ... the filter for the Suggestions we want to count
     *   }
     * })
    **/
    count<T extends suggestionsCountArgs>(
      args?: Subset<T, suggestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestionsAggregateArgs>(args: Subset<T, SuggestionsAggregateArgs>): Prisma.PrismaPromise<GetSuggestionsAggregateType<T>>

    /**
     * Group by Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends suggestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: suggestionsGroupByArgs['orderBy'] }
        : { orderBy?: suggestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, suggestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the suggestions model
   */
  readonly fields: suggestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for suggestions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__suggestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comptes<T extends comptesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, comptesDefaultArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projets<T extends projetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetsDefaultArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the suggestions model
   */ 
  interface suggestionsFieldRefs {
    readonly id: FieldRef<"suggestions", 'Int'>
    readonly compte_id: FieldRef<"suggestions", 'Int'>
    readonly project_id: FieldRef<"suggestions", 'Int'>
    readonly suggestion_content: FieldRef<"suggestions", 'String'>
    readonly submitted_at: FieldRef<"suggestions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * suggestions findUnique
   */
  export type suggestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions findUniqueOrThrow
   */
  export type suggestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions findFirst
   */
  export type suggestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suggestions.
     */
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * suggestions findFirstOrThrow
   */
  export type suggestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suggestions.
     */
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * suggestions findMany
   */
  export type suggestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: suggestionsOrderByWithRelationInput | suggestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    distinct?: SuggestionsScalarFieldEnum | SuggestionsScalarFieldEnum[]
  }

  /**
   * suggestions create
   */
  export type suggestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a suggestions.
     */
    data: XOR<suggestionsCreateInput, suggestionsUncheckedCreateInput>
  }

  /**
   * suggestions createMany
   */
  export type suggestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suggestions.
     */
    data: suggestionsCreateManyInput | suggestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * suggestions update
   */
  export type suggestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a suggestions.
     */
    data: XOR<suggestionsUpdateInput, suggestionsUncheckedUpdateInput>
    /**
     * Choose, which suggestions to update.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions updateMany
   */
  export type suggestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suggestions.
     */
    data: XOR<suggestionsUpdateManyMutationInput, suggestionsUncheckedUpdateManyInput>
    /**
     * Filter which suggestions to update
     */
    where?: suggestionsWhereInput
  }

  /**
   * suggestions upsert
   */
  export type suggestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the suggestions to update in case it exists.
     */
    where: suggestionsWhereUniqueInput
    /**
     * In case the suggestions found by the `where` argument doesn't exist, create a new suggestions with this data.
     */
    create: XOR<suggestionsCreateInput, suggestionsUncheckedCreateInput>
    /**
     * In case the suggestions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<suggestionsUpdateInput, suggestionsUncheckedUpdateInput>
  }

  /**
   * suggestions delete
   */
  export type suggestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
    /**
     * Filter which suggestions to delete.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions deleteMany
   */
  export type suggestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suggestions to delete
     */
    where?: suggestionsWhereInput
  }

  /**
   * suggestions without action
   */
  export type suggestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suggestionsInclude<ExtArgs> | null
  }


  /**
   * Model tache_assignations_groupes
   */

  export type AggregateTache_assignations_groupes = {
    _count: Tache_assignations_groupesCountAggregateOutputType | null
    _avg: Tache_assignations_groupesAvgAggregateOutputType | null
    _sum: Tache_assignations_groupesSumAggregateOutputType | null
    _min: Tache_assignations_groupesMinAggregateOutputType | null
    _max: Tache_assignations_groupesMaxAggregateOutputType | null
  }

  export type Tache_assignations_groupesAvgAggregateOutputType = {
    tache_id: number | null
    groupe_id: number | null
  }

  export type Tache_assignations_groupesSumAggregateOutputType = {
    tache_id: number | null
    groupe_id: number | null
  }

  export type Tache_assignations_groupesMinAggregateOutputType = {
    tache_id: number | null
    groupe_id: number | null
  }

  export type Tache_assignations_groupesMaxAggregateOutputType = {
    tache_id: number | null
    groupe_id: number | null
  }

  export type Tache_assignations_groupesCountAggregateOutputType = {
    tache_id: number
    groupe_id: number
    _all: number
  }


  export type Tache_assignations_groupesAvgAggregateInputType = {
    tache_id?: true
    groupe_id?: true
  }

  export type Tache_assignations_groupesSumAggregateInputType = {
    tache_id?: true
    groupe_id?: true
  }

  export type Tache_assignations_groupesMinAggregateInputType = {
    tache_id?: true
    groupe_id?: true
  }

  export type Tache_assignations_groupesMaxAggregateInputType = {
    tache_id?: true
    groupe_id?: true
  }

  export type Tache_assignations_groupesCountAggregateInputType = {
    tache_id?: true
    groupe_id?: true
    _all?: true
  }

  export type Tache_assignations_groupesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tache_assignations_groupes to aggregate.
     */
    where?: tache_assignations_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_groupes to fetch.
     */
    orderBy?: tache_assignations_groupesOrderByWithRelationInput | tache_assignations_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tache_assignations_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tache_assignations_groupes
    **/
    _count?: true | Tache_assignations_groupesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tache_assignations_groupesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tache_assignations_groupesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tache_assignations_groupesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tache_assignations_groupesMaxAggregateInputType
  }

  export type GetTache_assignations_groupesAggregateType<T extends Tache_assignations_groupesAggregateArgs> = {
        [P in keyof T & keyof AggregateTache_assignations_groupes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTache_assignations_groupes[P]>
      : GetScalarType<T[P], AggregateTache_assignations_groupes[P]>
  }




  export type tache_assignations_groupesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tache_assignations_groupesWhereInput
    orderBy?: tache_assignations_groupesOrderByWithAggregationInput | tache_assignations_groupesOrderByWithAggregationInput[]
    by: Tache_assignations_groupesScalarFieldEnum[] | Tache_assignations_groupesScalarFieldEnum
    having?: tache_assignations_groupesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tache_assignations_groupesCountAggregateInputType | true
    _avg?: Tache_assignations_groupesAvgAggregateInputType
    _sum?: Tache_assignations_groupesSumAggregateInputType
    _min?: Tache_assignations_groupesMinAggregateInputType
    _max?: Tache_assignations_groupesMaxAggregateInputType
  }

  export type Tache_assignations_groupesGroupByOutputType = {
    tache_id: number
    groupe_id: number
    _count: Tache_assignations_groupesCountAggregateOutputType | null
    _avg: Tache_assignations_groupesAvgAggregateOutputType | null
    _sum: Tache_assignations_groupesSumAggregateOutputType | null
    _min: Tache_assignations_groupesMinAggregateOutputType | null
    _max: Tache_assignations_groupesMaxAggregateOutputType | null
  }

  type GetTache_assignations_groupesGroupByPayload<T extends tache_assignations_groupesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tache_assignations_groupesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tache_assignations_groupesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tache_assignations_groupesGroupByOutputType[P]>
            : GetScalarType<T[P], Tache_assignations_groupesGroupByOutputType[P]>
        }
      >
    >


  export type tache_assignations_groupesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tache_id?: boolean
    groupe_id?: boolean
    taches?: boolean | tachesDefaultArgs<ExtArgs>
    groupes?: boolean | groupesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tache_assignations_groupes"]>


  export type tache_assignations_groupesSelectScalar = {
    tache_id?: boolean
    groupe_id?: boolean
  }

  export type tache_assignations_groupesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taches?: boolean | tachesDefaultArgs<ExtArgs>
    groupes?: boolean | groupesDefaultArgs<ExtArgs>
  }

  export type $tache_assignations_groupesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tache_assignations_groupes"
    objects: {
      taches: Prisma.$tachesPayload<ExtArgs>
      groupes: Prisma.$groupesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tache_id: number
      groupe_id: number
    }, ExtArgs["result"]["tache_assignations_groupes"]>
    composites: {}
  }

  type tache_assignations_groupesGetPayload<S extends boolean | null | undefined | tache_assignations_groupesDefaultArgs> = $Result.GetResult<Prisma.$tache_assignations_groupesPayload, S>

  type tache_assignations_groupesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tache_assignations_groupesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tache_assignations_groupesCountAggregateInputType | true
    }

  export interface tache_assignations_groupesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tache_assignations_groupes'], meta: { name: 'tache_assignations_groupes' } }
    /**
     * Find zero or one Tache_assignations_groupes that matches the filter.
     * @param {tache_assignations_groupesFindUniqueArgs} args - Arguments to find a Tache_assignations_groupes
     * @example
     * // Get one Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tache_assignations_groupesFindUniqueArgs>(args: SelectSubset<T, tache_assignations_groupesFindUniqueArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tache_assignations_groupes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tache_assignations_groupesFindUniqueOrThrowArgs} args - Arguments to find a Tache_assignations_groupes
     * @example
     * // Get one Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tache_assignations_groupesFindUniqueOrThrowArgs>(args: SelectSubset<T, tache_assignations_groupesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tache_assignations_groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_groupesFindFirstArgs} args - Arguments to find a Tache_assignations_groupes
     * @example
     * // Get one Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tache_assignations_groupesFindFirstArgs>(args?: SelectSubset<T, tache_assignations_groupesFindFirstArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tache_assignations_groupes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_groupesFindFirstOrThrowArgs} args - Arguments to find a Tache_assignations_groupes
     * @example
     * // Get one Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tache_assignations_groupesFindFirstOrThrowArgs>(args?: SelectSubset<T, tache_assignations_groupesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tache_assignations_groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_groupesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.findMany()
     * 
     * // Get first 10 Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.findMany({ take: 10 })
     * 
     * // Only select the `tache_id`
     * const tache_assignations_groupesWithTache_idOnly = await prisma.tache_assignations_groupes.findMany({ select: { tache_id: true } })
     * 
     */
    findMany<T extends tache_assignations_groupesFindManyArgs>(args?: SelectSubset<T, tache_assignations_groupesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tache_assignations_groupes.
     * @param {tache_assignations_groupesCreateArgs} args - Arguments to create a Tache_assignations_groupes.
     * @example
     * // Create one Tache_assignations_groupes
     * const Tache_assignations_groupes = await prisma.tache_assignations_groupes.create({
     *   data: {
     *     // ... data to create a Tache_assignations_groupes
     *   }
     * })
     * 
     */
    create<T extends tache_assignations_groupesCreateArgs>(args: SelectSubset<T, tache_assignations_groupesCreateArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tache_assignations_groupes.
     * @param {tache_assignations_groupesCreateManyArgs} args - Arguments to create many Tache_assignations_groupes.
     * @example
     * // Create many Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tache_assignations_groupesCreateManyArgs>(args?: SelectSubset<T, tache_assignations_groupesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tache_assignations_groupes.
     * @param {tache_assignations_groupesDeleteArgs} args - Arguments to delete one Tache_assignations_groupes.
     * @example
     * // Delete one Tache_assignations_groupes
     * const Tache_assignations_groupes = await prisma.tache_assignations_groupes.delete({
     *   where: {
     *     // ... filter to delete one Tache_assignations_groupes
     *   }
     * })
     * 
     */
    delete<T extends tache_assignations_groupesDeleteArgs>(args: SelectSubset<T, tache_assignations_groupesDeleteArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tache_assignations_groupes.
     * @param {tache_assignations_groupesUpdateArgs} args - Arguments to update one Tache_assignations_groupes.
     * @example
     * // Update one Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tache_assignations_groupesUpdateArgs>(args: SelectSubset<T, tache_assignations_groupesUpdateArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tache_assignations_groupes.
     * @param {tache_assignations_groupesDeleteManyArgs} args - Arguments to filter Tache_assignations_groupes to delete.
     * @example
     * // Delete a few Tache_assignations_groupes
     * const { count } = await prisma.tache_assignations_groupes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tache_assignations_groupesDeleteManyArgs>(args?: SelectSubset<T, tache_assignations_groupesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tache_assignations_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_groupesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tache_assignations_groupesUpdateManyArgs>(args: SelectSubset<T, tache_assignations_groupesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tache_assignations_groupes.
     * @param {tache_assignations_groupesUpsertArgs} args - Arguments to update or create a Tache_assignations_groupes.
     * @example
     * // Update or create a Tache_assignations_groupes
     * const tache_assignations_groupes = await prisma.tache_assignations_groupes.upsert({
     *   create: {
     *     // ... data to create a Tache_assignations_groupes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tache_assignations_groupes we want to update
     *   }
     * })
     */
    upsert<T extends tache_assignations_groupesUpsertArgs>(args: SelectSubset<T, tache_assignations_groupesUpsertArgs<ExtArgs>>): Prisma__tache_assignations_groupesClient<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tache_assignations_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_groupesCountArgs} args - Arguments to filter Tache_assignations_groupes to count.
     * @example
     * // Count the number of Tache_assignations_groupes
     * const count = await prisma.tache_assignations_groupes.count({
     *   where: {
     *     // ... the filter for the Tache_assignations_groupes we want to count
     *   }
     * })
    **/
    count<T extends tache_assignations_groupesCountArgs>(
      args?: Subset<T, tache_assignations_groupesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tache_assignations_groupesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tache_assignations_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tache_assignations_groupesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tache_assignations_groupesAggregateArgs>(args: Subset<T, Tache_assignations_groupesAggregateArgs>): Prisma.PrismaPromise<GetTache_assignations_groupesAggregateType<T>>

    /**
     * Group by Tache_assignations_groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_groupesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tache_assignations_groupesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tache_assignations_groupesGroupByArgs['orderBy'] }
        : { orderBy?: tache_assignations_groupesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tache_assignations_groupesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTache_assignations_groupesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tache_assignations_groupes model
   */
  readonly fields: tache_assignations_groupesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tache_assignations_groupes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tache_assignations_groupesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taches<T extends tachesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tachesDefaultArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    groupes<T extends groupesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupesDefaultArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tache_assignations_groupes model
   */ 
  interface tache_assignations_groupesFieldRefs {
    readonly tache_id: FieldRef<"tache_assignations_groupes", 'Int'>
    readonly groupe_id: FieldRef<"tache_assignations_groupes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tache_assignations_groupes findUnique
   */
  export type tache_assignations_groupesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_groupes to fetch.
     */
    where: tache_assignations_groupesWhereUniqueInput
  }

  /**
   * tache_assignations_groupes findUniqueOrThrow
   */
  export type tache_assignations_groupesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_groupes to fetch.
     */
    where: tache_assignations_groupesWhereUniqueInput
  }

  /**
   * tache_assignations_groupes findFirst
   */
  export type tache_assignations_groupesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_groupes to fetch.
     */
    where?: tache_assignations_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_groupes to fetch.
     */
    orderBy?: tache_assignations_groupesOrderByWithRelationInput | tache_assignations_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tache_assignations_groupes.
     */
    cursor?: tache_assignations_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tache_assignations_groupes.
     */
    distinct?: Tache_assignations_groupesScalarFieldEnum | Tache_assignations_groupesScalarFieldEnum[]
  }

  /**
   * tache_assignations_groupes findFirstOrThrow
   */
  export type tache_assignations_groupesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_groupes to fetch.
     */
    where?: tache_assignations_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_groupes to fetch.
     */
    orderBy?: tache_assignations_groupesOrderByWithRelationInput | tache_assignations_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tache_assignations_groupes.
     */
    cursor?: tache_assignations_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tache_assignations_groupes.
     */
    distinct?: Tache_assignations_groupesScalarFieldEnum | Tache_assignations_groupesScalarFieldEnum[]
  }

  /**
   * tache_assignations_groupes findMany
   */
  export type tache_assignations_groupesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_groupes to fetch.
     */
    where?: tache_assignations_groupesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_groupes to fetch.
     */
    orderBy?: tache_assignations_groupesOrderByWithRelationInput | tache_assignations_groupesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tache_assignations_groupes.
     */
    cursor?: tache_assignations_groupesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_groupes.
     */
    skip?: number
    distinct?: Tache_assignations_groupesScalarFieldEnum | Tache_assignations_groupesScalarFieldEnum[]
  }

  /**
   * tache_assignations_groupes create
   */
  export type tache_assignations_groupesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * The data needed to create a tache_assignations_groupes.
     */
    data: XOR<tache_assignations_groupesCreateInput, tache_assignations_groupesUncheckedCreateInput>
  }

  /**
   * tache_assignations_groupes createMany
   */
  export type tache_assignations_groupesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tache_assignations_groupes.
     */
    data: tache_assignations_groupesCreateManyInput | tache_assignations_groupesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tache_assignations_groupes update
   */
  export type tache_assignations_groupesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * The data needed to update a tache_assignations_groupes.
     */
    data: XOR<tache_assignations_groupesUpdateInput, tache_assignations_groupesUncheckedUpdateInput>
    /**
     * Choose, which tache_assignations_groupes to update.
     */
    where: tache_assignations_groupesWhereUniqueInput
  }

  /**
   * tache_assignations_groupes updateMany
   */
  export type tache_assignations_groupesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tache_assignations_groupes.
     */
    data: XOR<tache_assignations_groupesUpdateManyMutationInput, tache_assignations_groupesUncheckedUpdateManyInput>
    /**
     * Filter which tache_assignations_groupes to update
     */
    where?: tache_assignations_groupesWhereInput
  }

  /**
   * tache_assignations_groupes upsert
   */
  export type tache_assignations_groupesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * The filter to search for the tache_assignations_groupes to update in case it exists.
     */
    where: tache_assignations_groupesWhereUniqueInput
    /**
     * In case the tache_assignations_groupes found by the `where` argument doesn't exist, create a new tache_assignations_groupes with this data.
     */
    create: XOR<tache_assignations_groupesCreateInput, tache_assignations_groupesUncheckedCreateInput>
    /**
     * In case the tache_assignations_groupes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tache_assignations_groupesUpdateInput, tache_assignations_groupesUncheckedUpdateInput>
  }

  /**
   * tache_assignations_groupes delete
   */
  export type tache_assignations_groupesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    /**
     * Filter which tache_assignations_groupes to delete.
     */
    where: tache_assignations_groupesWhereUniqueInput
  }

  /**
   * tache_assignations_groupes deleteMany
   */
  export type tache_assignations_groupesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tache_assignations_groupes to delete
     */
    where?: tache_assignations_groupesWhereInput
  }

  /**
   * tache_assignations_groupes without action
   */
  export type tache_assignations_groupesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
  }


  /**
   * Model tache_assignations_utilisateurs
   */

  export type AggregateTache_assignations_utilisateurs = {
    _count: Tache_assignations_utilisateursCountAggregateOutputType | null
    _avg: Tache_assignations_utilisateursAvgAggregateOutputType | null
    _sum: Tache_assignations_utilisateursSumAggregateOutputType | null
    _min: Tache_assignations_utilisateursMinAggregateOutputType | null
    _max: Tache_assignations_utilisateursMaxAggregateOutputType | null
  }

  export type Tache_assignations_utilisateursAvgAggregateOutputType = {
    tache_id: number | null
    utilisateur_id: number | null
  }

  export type Tache_assignations_utilisateursSumAggregateOutputType = {
    tache_id: number | null
    utilisateur_id: number | null
  }

  export type Tache_assignations_utilisateursMinAggregateOutputType = {
    tache_id: number | null
    utilisateur_id: number | null
  }

  export type Tache_assignations_utilisateursMaxAggregateOutputType = {
    tache_id: number | null
    utilisateur_id: number | null
  }

  export type Tache_assignations_utilisateursCountAggregateOutputType = {
    tache_id: number
    utilisateur_id: number
    _all: number
  }


  export type Tache_assignations_utilisateursAvgAggregateInputType = {
    tache_id?: true
    utilisateur_id?: true
  }

  export type Tache_assignations_utilisateursSumAggregateInputType = {
    tache_id?: true
    utilisateur_id?: true
  }

  export type Tache_assignations_utilisateursMinAggregateInputType = {
    tache_id?: true
    utilisateur_id?: true
  }

  export type Tache_assignations_utilisateursMaxAggregateInputType = {
    tache_id?: true
    utilisateur_id?: true
  }

  export type Tache_assignations_utilisateursCountAggregateInputType = {
    tache_id?: true
    utilisateur_id?: true
    _all?: true
  }

  export type Tache_assignations_utilisateursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tache_assignations_utilisateurs to aggregate.
     */
    where?: tache_assignations_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_utilisateurs to fetch.
     */
    orderBy?: tache_assignations_utilisateursOrderByWithRelationInput | tache_assignations_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tache_assignations_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tache_assignations_utilisateurs
    **/
    _count?: true | Tache_assignations_utilisateursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tache_assignations_utilisateursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tache_assignations_utilisateursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tache_assignations_utilisateursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tache_assignations_utilisateursMaxAggregateInputType
  }

  export type GetTache_assignations_utilisateursAggregateType<T extends Tache_assignations_utilisateursAggregateArgs> = {
        [P in keyof T & keyof AggregateTache_assignations_utilisateurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTache_assignations_utilisateurs[P]>
      : GetScalarType<T[P], AggregateTache_assignations_utilisateurs[P]>
  }




  export type tache_assignations_utilisateursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tache_assignations_utilisateursWhereInput
    orderBy?: tache_assignations_utilisateursOrderByWithAggregationInput | tache_assignations_utilisateursOrderByWithAggregationInput[]
    by: Tache_assignations_utilisateursScalarFieldEnum[] | Tache_assignations_utilisateursScalarFieldEnum
    having?: tache_assignations_utilisateursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tache_assignations_utilisateursCountAggregateInputType | true
    _avg?: Tache_assignations_utilisateursAvgAggregateInputType
    _sum?: Tache_assignations_utilisateursSumAggregateInputType
    _min?: Tache_assignations_utilisateursMinAggregateInputType
    _max?: Tache_assignations_utilisateursMaxAggregateInputType
  }

  export type Tache_assignations_utilisateursGroupByOutputType = {
    tache_id: number
    utilisateur_id: number
    _count: Tache_assignations_utilisateursCountAggregateOutputType | null
    _avg: Tache_assignations_utilisateursAvgAggregateOutputType | null
    _sum: Tache_assignations_utilisateursSumAggregateOutputType | null
    _min: Tache_assignations_utilisateursMinAggregateOutputType | null
    _max: Tache_assignations_utilisateursMaxAggregateOutputType | null
  }

  type GetTache_assignations_utilisateursGroupByPayload<T extends tache_assignations_utilisateursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tache_assignations_utilisateursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tache_assignations_utilisateursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tache_assignations_utilisateursGroupByOutputType[P]>
            : GetScalarType<T[P], Tache_assignations_utilisateursGroupByOutputType[P]>
        }
      >
    >


  export type tache_assignations_utilisateursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tache_id?: boolean
    utilisateur_id?: boolean
    taches?: boolean | tachesDefaultArgs<ExtArgs>
    utilisateurs?: boolean | utilisateursDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tache_assignations_utilisateurs"]>


  export type tache_assignations_utilisateursSelectScalar = {
    tache_id?: boolean
    utilisateur_id?: boolean
  }

  export type tache_assignations_utilisateursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taches?: boolean | tachesDefaultArgs<ExtArgs>
    utilisateurs?: boolean | utilisateursDefaultArgs<ExtArgs>
  }

  export type $tache_assignations_utilisateursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tache_assignations_utilisateurs"
    objects: {
      taches: Prisma.$tachesPayload<ExtArgs>
      utilisateurs: Prisma.$utilisateursPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tache_id: number
      utilisateur_id: number
    }, ExtArgs["result"]["tache_assignations_utilisateurs"]>
    composites: {}
  }

  type tache_assignations_utilisateursGetPayload<S extends boolean | null | undefined | tache_assignations_utilisateursDefaultArgs> = $Result.GetResult<Prisma.$tache_assignations_utilisateursPayload, S>

  type tache_assignations_utilisateursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tache_assignations_utilisateursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tache_assignations_utilisateursCountAggregateInputType | true
    }

  export interface tache_assignations_utilisateursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tache_assignations_utilisateurs'], meta: { name: 'tache_assignations_utilisateurs' } }
    /**
     * Find zero or one Tache_assignations_utilisateurs that matches the filter.
     * @param {tache_assignations_utilisateursFindUniqueArgs} args - Arguments to find a Tache_assignations_utilisateurs
     * @example
     * // Get one Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tache_assignations_utilisateursFindUniqueArgs>(args: SelectSubset<T, tache_assignations_utilisateursFindUniqueArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tache_assignations_utilisateurs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tache_assignations_utilisateursFindUniqueOrThrowArgs} args - Arguments to find a Tache_assignations_utilisateurs
     * @example
     * // Get one Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tache_assignations_utilisateursFindUniqueOrThrowArgs>(args: SelectSubset<T, tache_assignations_utilisateursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tache_assignations_utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_utilisateursFindFirstArgs} args - Arguments to find a Tache_assignations_utilisateurs
     * @example
     * // Get one Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tache_assignations_utilisateursFindFirstArgs>(args?: SelectSubset<T, tache_assignations_utilisateursFindFirstArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tache_assignations_utilisateurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_utilisateursFindFirstOrThrowArgs} args - Arguments to find a Tache_assignations_utilisateurs
     * @example
     * // Get one Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tache_assignations_utilisateursFindFirstOrThrowArgs>(args?: SelectSubset<T, tache_assignations_utilisateursFindFirstOrThrowArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tache_assignations_utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_utilisateursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.findMany()
     * 
     * // Get first 10 Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.findMany({ take: 10 })
     * 
     * // Only select the `tache_id`
     * const tache_assignations_utilisateursWithTache_idOnly = await prisma.tache_assignations_utilisateurs.findMany({ select: { tache_id: true } })
     * 
     */
    findMany<T extends tache_assignations_utilisateursFindManyArgs>(args?: SelectSubset<T, tache_assignations_utilisateursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tache_assignations_utilisateurs.
     * @param {tache_assignations_utilisateursCreateArgs} args - Arguments to create a Tache_assignations_utilisateurs.
     * @example
     * // Create one Tache_assignations_utilisateurs
     * const Tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.create({
     *   data: {
     *     // ... data to create a Tache_assignations_utilisateurs
     *   }
     * })
     * 
     */
    create<T extends tache_assignations_utilisateursCreateArgs>(args: SelectSubset<T, tache_assignations_utilisateursCreateArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tache_assignations_utilisateurs.
     * @param {tache_assignations_utilisateursCreateManyArgs} args - Arguments to create many Tache_assignations_utilisateurs.
     * @example
     * // Create many Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tache_assignations_utilisateursCreateManyArgs>(args?: SelectSubset<T, tache_assignations_utilisateursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tache_assignations_utilisateurs.
     * @param {tache_assignations_utilisateursDeleteArgs} args - Arguments to delete one Tache_assignations_utilisateurs.
     * @example
     * // Delete one Tache_assignations_utilisateurs
     * const Tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.delete({
     *   where: {
     *     // ... filter to delete one Tache_assignations_utilisateurs
     *   }
     * })
     * 
     */
    delete<T extends tache_assignations_utilisateursDeleteArgs>(args: SelectSubset<T, tache_assignations_utilisateursDeleteArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tache_assignations_utilisateurs.
     * @param {tache_assignations_utilisateursUpdateArgs} args - Arguments to update one Tache_assignations_utilisateurs.
     * @example
     * // Update one Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tache_assignations_utilisateursUpdateArgs>(args: SelectSubset<T, tache_assignations_utilisateursUpdateArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tache_assignations_utilisateurs.
     * @param {tache_assignations_utilisateursDeleteManyArgs} args - Arguments to filter Tache_assignations_utilisateurs to delete.
     * @example
     * // Delete a few Tache_assignations_utilisateurs
     * const { count } = await prisma.tache_assignations_utilisateurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tache_assignations_utilisateursDeleteManyArgs>(args?: SelectSubset<T, tache_assignations_utilisateursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tache_assignations_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_utilisateursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tache_assignations_utilisateursUpdateManyArgs>(args: SelectSubset<T, tache_assignations_utilisateursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tache_assignations_utilisateurs.
     * @param {tache_assignations_utilisateursUpsertArgs} args - Arguments to update or create a Tache_assignations_utilisateurs.
     * @example
     * // Update or create a Tache_assignations_utilisateurs
     * const tache_assignations_utilisateurs = await prisma.tache_assignations_utilisateurs.upsert({
     *   create: {
     *     // ... data to create a Tache_assignations_utilisateurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tache_assignations_utilisateurs we want to update
     *   }
     * })
     */
    upsert<T extends tache_assignations_utilisateursUpsertArgs>(args: SelectSubset<T, tache_assignations_utilisateursUpsertArgs<ExtArgs>>): Prisma__tache_assignations_utilisateursClient<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tache_assignations_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_utilisateursCountArgs} args - Arguments to filter Tache_assignations_utilisateurs to count.
     * @example
     * // Count the number of Tache_assignations_utilisateurs
     * const count = await prisma.tache_assignations_utilisateurs.count({
     *   where: {
     *     // ... the filter for the Tache_assignations_utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends tache_assignations_utilisateursCountArgs>(
      args?: Subset<T, tache_assignations_utilisateursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tache_assignations_utilisateursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tache_assignations_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tache_assignations_utilisateursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tache_assignations_utilisateursAggregateArgs>(args: Subset<T, Tache_assignations_utilisateursAggregateArgs>): Prisma.PrismaPromise<GetTache_assignations_utilisateursAggregateType<T>>

    /**
     * Group by Tache_assignations_utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tache_assignations_utilisateursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tache_assignations_utilisateursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tache_assignations_utilisateursGroupByArgs['orderBy'] }
        : { orderBy?: tache_assignations_utilisateursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tache_assignations_utilisateursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTache_assignations_utilisateursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tache_assignations_utilisateurs model
   */
  readonly fields: tache_assignations_utilisateursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tache_assignations_utilisateurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tache_assignations_utilisateursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taches<T extends tachesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tachesDefaultArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    utilisateurs<T extends utilisateursDefaultArgs<ExtArgs> = {}>(args?: Subset<T, utilisateursDefaultArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tache_assignations_utilisateurs model
   */ 
  interface tache_assignations_utilisateursFieldRefs {
    readonly tache_id: FieldRef<"tache_assignations_utilisateurs", 'Int'>
    readonly utilisateur_id: FieldRef<"tache_assignations_utilisateurs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tache_assignations_utilisateurs findUnique
   */
  export type tache_assignations_utilisateursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_utilisateurs to fetch.
     */
    where: tache_assignations_utilisateursWhereUniqueInput
  }

  /**
   * tache_assignations_utilisateurs findUniqueOrThrow
   */
  export type tache_assignations_utilisateursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_utilisateurs to fetch.
     */
    where: tache_assignations_utilisateursWhereUniqueInput
  }

  /**
   * tache_assignations_utilisateurs findFirst
   */
  export type tache_assignations_utilisateursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_utilisateurs to fetch.
     */
    where?: tache_assignations_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_utilisateurs to fetch.
     */
    orderBy?: tache_assignations_utilisateursOrderByWithRelationInput | tache_assignations_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tache_assignations_utilisateurs.
     */
    cursor?: tache_assignations_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tache_assignations_utilisateurs.
     */
    distinct?: Tache_assignations_utilisateursScalarFieldEnum | Tache_assignations_utilisateursScalarFieldEnum[]
  }

  /**
   * tache_assignations_utilisateurs findFirstOrThrow
   */
  export type tache_assignations_utilisateursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_utilisateurs to fetch.
     */
    where?: tache_assignations_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_utilisateurs to fetch.
     */
    orderBy?: tache_assignations_utilisateursOrderByWithRelationInput | tache_assignations_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tache_assignations_utilisateurs.
     */
    cursor?: tache_assignations_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tache_assignations_utilisateurs.
     */
    distinct?: Tache_assignations_utilisateursScalarFieldEnum | Tache_assignations_utilisateursScalarFieldEnum[]
  }

  /**
   * tache_assignations_utilisateurs findMany
   */
  export type tache_assignations_utilisateursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which tache_assignations_utilisateurs to fetch.
     */
    where?: tache_assignations_utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tache_assignations_utilisateurs to fetch.
     */
    orderBy?: tache_assignations_utilisateursOrderByWithRelationInput | tache_assignations_utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tache_assignations_utilisateurs.
     */
    cursor?: tache_assignations_utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tache_assignations_utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tache_assignations_utilisateurs.
     */
    skip?: number
    distinct?: Tache_assignations_utilisateursScalarFieldEnum | Tache_assignations_utilisateursScalarFieldEnum[]
  }

  /**
   * tache_assignations_utilisateurs create
   */
  export type tache_assignations_utilisateursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * The data needed to create a tache_assignations_utilisateurs.
     */
    data: XOR<tache_assignations_utilisateursCreateInput, tache_assignations_utilisateursUncheckedCreateInput>
  }

  /**
   * tache_assignations_utilisateurs createMany
   */
  export type tache_assignations_utilisateursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tache_assignations_utilisateurs.
     */
    data: tache_assignations_utilisateursCreateManyInput | tache_assignations_utilisateursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tache_assignations_utilisateurs update
   */
  export type tache_assignations_utilisateursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * The data needed to update a tache_assignations_utilisateurs.
     */
    data: XOR<tache_assignations_utilisateursUpdateInput, tache_assignations_utilisateursUncheckedUpdateInput>
    /**
     * Choose, which tache_assignations_utilisateurs to update.
     */
    where: tache_assignations_utilisateursWhereUniqueInput
  }

  /**
   * tache_assignations_utilisateurs updateMany
   */
  export type tache_assignations_utilisateursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tache_assignations_utilisateurs.
     */
    data: XOR<tache_assignations_utilisateursUpdateManyMutationInput, tache_assignations_utilisateursUncheckedUpdateManyInput>
    /**
     * Filter which tache_assignations_utilisateurs to update
     */
    where?: tache_assignations_utilisateursWhereInput
  }

  /**
   * tache_assignations_utilisateurs upsert
   */
  export type tache_assignations_utilisateursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * The filter to search for the tache_assignations_utilisateurs to update in case it exists.
     */
    where: tache_assignations_utilisateursWhereUniqueInput
    /**
     * In case the tache_assignations_utilisateurs found by the `where` argument doesn't exist, create a new tache_assignations_utilisateurs with this data.
     */
    create: XOR<tache_assignations_utilisateursCreateInput, tache_assignations_utilisateursUncheckedCreateInput>
    /**
     * In case the tache_assignations_utilisateurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tache_assignations_utilisateursUpdateInput, tache_assignations_utilisateursUncheckedUpdateInput>
  }

  /**
   * tache_assignations_utilisateurs delete
   */
  export type tache_assignations_utilisateursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    /**
     * Filter which tache_assignations_utilisateurs to delete.
     */
    where: tache_assignations_utilisateursWhereUniqueInput
  }

  /**
   * tache_assignations_utilisateurs deleteMany
   */
  export type tache_assignations_utilisateursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tache_assignations_utilisateurs to delete
     */
    where?: tache_assignations_utilisateursWhereInput
  }

  /**
   * tache_assignations_utilisateurs without action
   */
  export type tache_assignations_utilisateursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
  }


  /**
   * Model taches
   */

  export type AggregateTaches = {
    _count: TachesCountAggregateOutputType | null
    _avg: TachesAvgAggregateOutputType | null
    _sum: TachesSumAggregateOutputType | null
    _min: TachesMinAggregateOutputType | null
    _max: TachesMaxAggregateOutputType | null
  }

  export type TachesAvgAggregateOutputType = {
    id: number | null
    projet_id: number | null
    utilisateur_id: number | null
    tacheParentId: number | null
  }

  export type TachesSumAggregateOutputType = {
    id: number | null
    projet_id: number | null
    utilisateur_id: number | null
    tacheParentId: number | null
  }

  export type TachesMinAggregateOutputType = {
    id: number | null
    libelle: string | null
    description: string | null
    dateDebut: Date | null
    dateFin: Date | null
    projet_id: number | null
    utilisateur_id: number | null
    statut: string | null
    priorite: string | null
    dateCreation: Date | null
    dateMiseAJour: Date | null
    delaiEstime: string | null
    delaiReel: string | null
    commentaires: string | null
    tacheParentId: number | null
  }

  export type TachesMaxAggregateOutputType = {
    id: number | null
    libelle: string | null
    description: string | null
    dateDebut: Date | null
    dateFin: Date | null
    projet_id: number | null
    utilisateur_id: number | null
    statut: string | null
    priorite: string | null
    dateCreation: Date | null
    dateMiseAJour: Date | null
    delaiEstime: string | null
    delaiReel: string | null
    commentaires: string | null
    tacheParentId: number | null
  }

  export type TachesCountAggregateOutputType = {
    id: number
    libelle: number
    description: number
    dateDebut: number
    dateFin: number
    projet_id: number
    utilisateur_id: number
    statut: number
    priorite: number
    dateCreation: number
    dateMiseAJour: number
    delaiEstime: number
    delaiReel: number
    commentaires: number
    tacheParentId: number
    _all: number
  }


  export type TachesAvgAggregateInputType = {
    id?: true
    projet_id?: true
    utilisateur_id?: true
    tacheParentId?: true
  }

  export type TachesSumAggregateInputType = {
    id?: true
    projet_id?: true
    utilisateur_id?: true
    tacheParentId?: true
  }

  export type TachesMinAggregateInputType = {
    id?: true
    libelle?: true
    description?: true
    dateDebut?: true
    dateFin?: true
    projet_id?: true
    utilisateur_id?: true
    statut?: true
    priorite?: true
    dateCreation?: true
    dateMiseAJour?: true
    delaiEstime?: true
    delaiReel?: true
    commentaires?: true
    tacheParentId?: true
  }

  export type TachesMaxAggregateInputType = {
    id?: true
    libelle?: true
    description?: true
    dateDebut?: true
    dateFin?: true
    projet_id?: true
    utilisateur_id?: true
    statut?: true
    priorite?: true
    dateCreation?: true
    dateMiseAJour?: true
    delaiEstime?: true
    delaiReel?: true
    commentaires?: true
    tacheParentId?: true
  }

  export type TachesCountAggregateInputType = {
    id?: true
    libelle?: true
    description?: true
    dateDebut?: true
    dateFin?: true
    projet_id?: true
    utilisateur_id?: true
    statut?: true
    priorite?: true
    dateCreation?: true
    dateMiseAJour?: true
    delaiEstime?: true
    delaiReel?: true
    commentaires?: true
    tacheParentId?: true
    _all?: true
  }

  export type TachesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taches to aggregate.
     */
    where?: tachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taches to fetch.
     */
    orderBy?: tachesOrderByWithRelationInput | tachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned taches
    **/
    _count?: true | TachesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TachesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TachesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TachesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TachesMaxAggregateInputType
  }

  export type GetTachesAggregateType<T extends TachesAggregateArgs> = {
        [P in keyof T & keyof AggregateTaches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaches[P]>
      : GetScalarType<T[P], AggregateTaches[P]>
  }




  export type tachesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tachesWhereInput
    orderBy?: tachesOrderByWithAggregationInput | tachesOrderByWithAggregationInput[]
    by: TachesScalarFieldEnum[] | TachesScalarFieldEnum
    having?: tachesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TachesCountAggregateInputType | true
    _avg?: TachesAvgAggregateInputType
    _sum?: TachesSumAggregateInputType
    _min?: TachesMinAggregateInputType
    _max?: TachesMaxAggregateInputType
  }

  export type TachesGroupByOutputType = {
    id: number
    libelle: string
    description: string | null
    dateDebut: Date | null
    dateFin: Date | null
    projet_id: number | null
    utilisateur_id: number | null
    statut: string | null
    priorite: string | null
    dateCreation: Date
    dateMiseAJour: Date
    delaiEstime: string | null
    delaiReel: string | null
    commentaires: string | null
    tacheParentId: number | null
    _count: TachesCountAggregateOutputType | null
    _avg: TachesAvgAggregateOutputType | null
    _sum: TachesSumAggregateOutputType | null
    _min: TachesMinAggregateOutputType | null
    _max: TachesMaxAggregateOutputType | null
  }

  type GetTachesGroupByPayload<T extends tachesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TachesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TachesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TachesGroupByOutputType[P]>
            : GetScalarType<T[P], TachesGroupByOutputType[P]>
        }
      >
    >


  export type tachesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    description?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    projet_id?: boolean
    utilisateur_id?: boolean
    statut?: boolean
    priorite?: boolean
    dateCreation?: boolean
    dateMiseAJour?: boolean
    delaiEstime?: boolean
    delaiReel?: boolean
    commentaires?: boolean
    tacheParentId?: boolean
    tache_assignations_groupes?: boolean | taches$tache_assignations_groupesArgs<ExtArgs>
    tache_assignations_utilisateurs?: boolean | taches$tache_assignations_utilisateursArgs<ExtArgs>
    utilisateur?: boolean | taches$utilisateurArgs<ExtArgs>
    projet?: boolean | taches$projetArgs<ExtArgs>
    _count?: boolean | TachesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taches"]>


  export type tachesSelectScalar = {
    id?: boolean
    libelle?: boolean
    description?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    projet_id?: boolean
    utilisateur_id?: boolean
    statut?: boolean
    priorite?: boolean
    dateCreation?: boolean
    dateMiseAJour?: boolean
    delaiEstime?: boolean
    delaiReel?: boolean
    commentaires?: boolean
    tacheParentId?: boolean
  }

  export type tachesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tache_assignations_groupes?: boolean | taches$tache_assignations_groupesArgs<ExtArgs>
    tache_assignations_utilisateurs?: boolean | taches$tache_assignations_utilisateursArgs<ExtArgs>
    utilisateur?: boolean | taches$utilisateurArgs<ExtArgs>
    projet?: boolean | taches$projetArgs<ExtArgs>
    _count?: boolean | TachesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tachesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "taches"
    objects: {
      tache_assignations_groupes: Prisma.$tache_assignations_groupesPayload<ExtArgs>[]
      tache_assignations_utilisateurs: Prisma.$tache_assignations_utilisateursPayload<ExtArgs>[]
      utilisateur: Prisma.$utilisateursPayload<ExtArgs> | null
      projet: Prisma.$projetsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      libelle: string
      description: string | null
      dateDebut: Date | null
      dateFin: Date | null
      projet_id: number | null
      utilisateur_id: number | null
      statut: string | null
      priorite: string | null
      dateCreation: Date
      dateMiseAJour: Date
      delaiEstime: string | null
      delaiReel: string | null
      commentaires: string | null
      tacheParentId: number | null
    }, ExtArgs["result"]["taches"]>
    composites: {}
  }

  type tachesGetPayload<S extends boolean | null | undefined | tachesDefaultArgs> = $Result.GetResult<Prisma.$tachesPayload, S>

  type tachesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tachesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TachesCountAggregateInputType | true
    }

  export interface tachesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['taches'], meta: { name: 'taches' } }
    /**
     * Find zero or one Taches that matches the filter.
     * @param {tachesFindUniqueArgs} args - Arguments to find a Taches
     * @example
     * // Get one Taches
     * const taches = await prisma.taches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tachesFindUniqueArgs>(args: SelectSubset<T, tachesFindUniqueArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Taches that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tachesFindUniqueOrThrowArgs} args - Arguments to find a Taches
     * @example
     * // Get one Taches
     * const taches = await prisma.taches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tachesFindUniqueOrThrowArgs>(args: SelectSubset<T, tachesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Taches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tachesFindFirstArgs} args - Arguments to find a Taches
     * @example
     * // Get one Taches
     * const taches = await prisma.taches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tachesFindFirstArgs>(args?: SelectSubset<T, tachesFindFirstArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Taches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tachesFindFirstOrThrowArgs} args - Arguments to find a Taches
     * @example
     * // Get one Taches
     * const taches = await prisma.taches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tachesFindFirstOrThrowArgs>(args?: SelectSubset<T, tachesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Taches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tachesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taches
     * const taches = await prisma.taches.findMany()
     * 
     * // Get first 10 Taches
     * const taches = await prisma.taches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tachesWithIdOnly = await prisma.taches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tachesFindManyArgs>(args?: SelectSubset<T, tachesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Taches.
     * @param {tachesCreateArgs} args - Arguments to create a Taches.
     * @example
     * // Create one Taches
     * const Taches = await prisma.taches.create({
     *   data: {
     *     // ... data to create a Taches
     *   }
     * })
     * 
     */
    create<T extends tachesCreateArgs>(args: SelectSubset<T, tachesCreateArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Taches.
     * @param {tachesCreateManyArgs} args - Arguments to create many Taches.
     * @example
     * // Create many Taches
     * const taches = await prisma.taches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tachesCreateManyArgs>(args?: SelectSubset<T, tachesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Taches.
     * @param {tachesDeleteArgs} args - Arguments to delete one Taches.
     * @example
     * // Delete one Taches
     * const Taches = await prisma.taches.delete({
     *   where: {
     *     // ... filter to delete one Taches
     *   }
     * })
     * 
     */
    delete<T extends tachesDeleteArgs>(args: SelectSubset<T, tachesDeleteArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Taches.
     * @param {tachesUpdateArgs} args - Arguments to update one Taches.
     * @example
     * // Update one Taches
     * const taches = await prisma.taches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tachesUpdateArgs>(args: SelectSubset<T, tachesUpdateArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Taches.
     * @param {tachesDeleteManyArgs} args - Arguments to filter Taches to delete.
     * @example
     * // Delete a few Taches
     * const { count } = await prisma.taches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tachesDeleteManyArgs>(args?: SelectSubset<T, tachesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tachesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taches
     * const taches = await prisma.taches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tachesUpdateManyArgs>(args: SelectSubset<T, tachesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Taches.
     * @param {tachesUpsertArgs} args - Arguments to update or create a Taches.
     * @example
     * // Update or create a Taches
     * const taches = await prisma.taches.upsert({
     *   create: {
     *     // ... data to create a Taches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Taches we want to update
     *   }
     * })
     */
    upsert<T extends tachesUpsertArgs>(args: SelectSubset<T, tachesUpsertArgs<ExtArgs>>): Prisma__tachesClient<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Taches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tachesCountArgs} args - Arguments to filter Taches to count.
     * @example
     * // Count the number of Taches
     * const count = await prisma.taches.count({
     *   where: {
     *     // ... the filter for the Taches we want to count
     *   }
     * })
    **/
    count<T extends tachesCountArgs>(
      args?: Subset<T, tachesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TachesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Taches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TachesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TachesAggregateArgs>(args: Subset<T, TachesAggregateArgs>): Prisma.PrismaPromise<GetTachesAggregateType<T>>

    /**
     * Group by Taches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tachesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tachesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tachesGroupByArgs['orderBy'] }
        : { orderBy?: tachesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tachesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTachesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the taches model
   */
  readonly fields: tachesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for taches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tachesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tache_assignations_groupes<T extends taches$tache_assignations_groupesArgs<ExtArgs> = {}>(args?: Subset<T, taches$tache_assignations_groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tache_assignations_groupesPayload<ExtArgs>, T, "findMany"> | Null>
    tache_assignations_utilisateurs<T extends taches$tache_assignations_utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, taches$tache_assignations_utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "findMany"> | Null>
    utilisateur<T extends taches$utilisateurArgs<ExtArgs> = {}>(args?: Subset<T, taches$utilisateurArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    projet<T extends taches$projetArgs<ExtArgs> = {}>(args?: Subset<T, taches$projetArgs<ExtArgs>>): Prisma__projetsClient<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the taches model
   */ 
  interface tachesFieldRefs {
    readonly id: FieldRef<"taches", 'Int'>
    readonly libelle: FieldRef<"taches", 'String'>
    readonly description: FieldRef<"taches", 'String'>
    readonly dateDebut: FieldRef<"taches", 'DateTime'>
    readonly dateFin: FieldRef<"taches", 'DateTime'>
    readonly projet_id: FieldRef<"taches", 'Int'>
    readonly utilisateur_id: FieldRef<"taches", 'Int'>
    readonly statut: FieldRef<"taches", 'String'>
    readonly priorite: FieldRef<"taches", 'String'>
    readonly dateCreation: FieldRef<"taches", 'DateTime'>
    readonly dateMiseAJour: FieldRef<"taches", 'DateTime'>
    readonly delaiEstime: FieldRef<"taches", 'String'>
    readonly delaiReel: FieldRef<"taches", 'String'>
    readonly commentaires: FieldRef<"taches", 'String'>
    readonly tacheParentId: FieldRef<"taches", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * taches findUnique
   */
  export type tachesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * Filter, which taches to fetch.
     */
    where: tachesWhereUniqueInput
  }

  /**
   * taches findUniqueOrThrow
   */
  export type tachesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * Filter, which taches to fetch.
     */
    where: tachesWhereUniqueInput
  }

  /**
   * taches findFirst
   */
  export type tachesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * Filter, which taches to fetch.
     */
    where?: tachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taches to fetch.
     */
    orderBy?: tachesOrderByWithRelationInput | tachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taches.
     */
    cursor?: tachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taches.
     */
    distinct?: TachesScalarFieldEnum | TachesScalarFieldEnum[]
  }

  /**
   * taches findFirstOrThrow
   */
  export type tachesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * Filter, which taches to fetch.
     */
    where?: tachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taches to fetch.
     */
    orderBy?: tachesOrderByWithRelationInput | tachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taches.
     */
    cursor?: tachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taches.
     */
    distinct?: TachesScalarFieldEnum | TachesScalarFieldEnum[]
  }

  /**
   * taches findMany
   */
  export type tachesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * Filter, which taches to fetch.
     */
    where?: tachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taches to fetch.
     */
    orderBy?: tachesOrderByWithRelationInput | tachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing taches.
     */
    cursor?: tachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taches.
     */
    skip?: number
    distinct?: TachesScalarFieldEnum | TachesScalarFieldEnum[]
  }

  /**
   * taches create
   */
  export type tachesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * The data needed to create a taches.
     */
    data: XOR<tachesCreateInput, tachesUncheckedCreateInput>
  }

  /**
   * taches createMany
   */
  export type tachesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many taches.
     */
    data: tachesCreateManyInput | tachesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * taches update
   */
  export type tachesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * The data needed to update a taches.
     */
    data: XOR<tachesUpdateInput, tachesUncheckedUpdateInput>
    /**
     * Choose, which taches to update.
     */
    where: tachesWhereUniqueInput
  }

  /**
   * taches updateMany
   */
  export type tachesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update taches.
     */
    data: XOR<tachesUpdateManyMutationInput, tachesUncheckedUpdateManyInput>
    /**
     * Filter which taches to update
     */
    where?: tachesWhereInput
  }

  /**
   * taches upsert
   */
  export type tachesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * The filter to search for the taches to update in case it exists.
     */
    where: tachesWhereUniqueInput
    /**
     * In case the taches found by the `where` argument doesn't exist, create a new taches with this data.
     */
    create: XOR<tachesCreateInput, tachesUncheckedCreateInput>
    /**
     * In case the taches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tachesUpdateInput, tachesUncheckedUpdateInput>
  }

  /**
   * taches delete
   */
  export type tachesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    /**
     * Filter which taches to delete.
     */
    where: tachesWhereUniqueInput
  }

  /**
   * taches deleteMany
   */
  export type tachesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taches to delete
     */
    where?: tachesWhereInput
  }

  /**
   * taches.tache_assignations_groupes
   */
  export type taches$tache_assignations_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_groupes
     */
    select?: tache_assignations_groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_groupesInclude<ExtArgs> | null
    where?: tache_assignations_groupesWhereInput
    orderBy?: tache_assignations_groupesOrderByWithRelationInput | tache_assignations_groupesOrderByWithRelationInput[]
    cursor?: tache_assignations_groupesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tache_assignations_groupesScalarFieldEnum | Tache_assignations_groupesScalarFieldEnum[]
  }

  /**
   * taches.tache_assignations_utilisateurs
   */
  export type taches$tache_assignations_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    where?: tache_assignations_utilisateursWhereInput
    orderBy?: tache_assignations_utilisateursOrderByWithRelationInput | tache_assignations_utilisateursOrderByWithRelationInput[]
    cursor?: tache_assignations_utilisateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tache_assignations_utilisateursScalarFieldEnum | Tache_assignations_utilisateursScalarFieldEnum[]
  }

  /**
   * taches.utilisateur
   */
  export type taches$utilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    where?: utilisateursWhereInput
  }

  /**
   * taches.projet
   */
  export type taches$projetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    where?: projetsWhereInput
  }

  /**
   * taches without action
   */
  export type tachesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
  }


  /**
   * Model utilisateurs
   */

  export type AggregateUtilisateurs = {
    _count: UtilisateursCountAggregateOutputType | null
    _avg: UtilisateursAvgAggregateOutputType | null
    _sum: UtilisateursSumAggregateOutputType | null
    _min: UtilisateursMinAggregateOutputType | null
    _max: UtilisateursMaxAggregateOutputType | null
  }

  export type UtilisateursAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type UtilisateursSumAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type UtilisateursMinAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    category_id: number | null
    created_at: Date | null
  }

  export type UtilisateursMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    category_id: number | null
    created_at: Date | null
  }

  export type UtilisateursCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    email: number
    category_id: number
    created_at: number
    _all: number
  }


  export type UtilisateursAvgAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type UtilisateursSumAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type UtilisateursMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    category_id?: true
    created_at?: true
  }

  export type UtilisateursMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    category_id?: true
    created_at?: true
  }

  export type UtilisateursCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    category_id?: true
    created_at?: true
    _all?: true
  }

  export type UtilisateursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilisateurs to aggregate.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned utilisateurs
    **/
    _count?: true | UtilisateursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtilisateursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtilisateursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateursMaxAggregateInputType
  }

  export type GetUtilisateursAggregateType<T extends UtilisateursAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateurs[P]>
      : GetScalarType<T[P], AggregateUtilisateurs[P]>
  }




  export type utilisateursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: utilisateursWhereInput
    orderBy?: utilisateursOrderByWithAggregationInput | utilisateursOrderByWithAggregationInput[]
    by: UtilisateursScalarFieldEnum[] | UtilisateursScalarFieldEnum
    having?: utilisateursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateursCountAggregateInputType | true
    _avg?: UtilisateursAvgAggregateInputType
    _sum?: UtilisateursSumAggregateInputType
    _min?: UtilisateursMinAggregateInputType
    _max?: UtilisateursMaxAggregateInputType
  }

  export type UtilisateursGroupByOutputType = {
    id: number
    nom: string
    prenom: string
    email: string
    category_id: number | null
    created_at: Date
    _count: UtilisateursCountAggregateOutputType | null
    _avg: UtilisateursAvgAggregateOutputType | null
    _sum: UtilisateursSumAggregateOutputType | null
    _min: UtilisateursMinAggregateOutputType | null
    _max: UtilisateursMaxAggregateOutputType | null
  }

  type GetUtilisateursGroupByPayload<T extends utilisateursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateursGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateursGroupByOutputType[P]>
        }
      >
    >


  export type utilisateursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    category_id?: boolean
    created_at?: boolean
    comptes?: boolean | utilisateurs$comptesArgs<ExtArgs>
    projet_utilisateurs?: boolean | utilisateurs$projet_utilisateursArgs<ExtArgs>
    projets?: boolean | utilisateurs$projetsArgs<ExtArgs>
    tache_assignations_utilisateurs?: boolean | utilisateurs$tache_assignations_utilisateursArgs<ExtArgs>
    taches?: boolean | utilisateurs$tachesArgs<ExtArgs>
    category_user?: boolean | utilisateurs$category_userArgs<ExtArgs>
    groupesUtilisateurs?: boolean | utilisateurs$groupesUtilisateursArgs<ExtArgs>
    Notification?: boolean | utilisateurs$NotificationArgs<ExtArgs>
    _count?: boolean | UtilisateursCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utilisateurs"]>


  export type utilisateursSelectScalar = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    category_id?: boolean
    created_at?: boolean
  }

  export type utilisateursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comptes?: boolean | utilisateurs$comptesArgs<ExtArgs>
    projet_utilisateurs?: boolean | utilisateurs$projet_utilisateursArgs<ExtArgs>
    projets?: boolean | utilisateurs$projetsArgs<ExtArgs>
    tache_assignations_utilisateurs?: boolean | utilisateurs$tache_assignations_utilisateursArgs<ExtArgs>
    taches?: boolean | utilisateurs$tachesArgs<ExtArgs>
    category_user?: boolean | utilisateurs$category_userArgs<ExtArgs>
    groupesUtilisateurs?: boolean | utilisateurs$groupesUtilisateursArgs<ExtArgs>
    Notification?: boolean | utilisateurs$NotificationArgs<ExtArgs>
    _count?: boolean | UtilisateursCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $utilisateursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "utilisateurs"
    objects: {
      comptes: Prisma.$comptesPayload<ExtArgs>[]
      projet_utilisateurs: Prisma.$projet_utilisateursPayload<ExtArgs>[]
      projets: Prisma.$projetsPayload<ExtArgs>[]
      tache_assignations_utilisateurs: Prisma.$tache_assignations_utilisateursPayload<ExtArgs>[]
      taches: Prisma.$tachesPayload<ExtArgs>[]
      category_user: Prisma.$category_userPayload<ExtArgs> | null
      groupesUtilisateurs: Prisma.$GroupesUtilisateursPayload<ExtArgs>[]
      Notification: Prisma.$notificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      prenom: string
      email: string
      category_id: number | null
      created_at: Date
    }, ExtArgs["result"]["utilisateurs"]>
    composites: {}
  }

  type utilisateursGetPayload<S extends boolean | null | undefined | utilisateursDefaultArgs> = $Result.GetResult<Prisma.$utilisateursPayload, S>

  type utilisateursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<utilisateursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UtilisateursCountAggregateInputType | true
    }

  export interface utilisateursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['utilisateurs'], meta: { name: 'utilisateurs' } }
    /**
     * Find zero or one Utilisateurs that matches the filter.
     * @param {utilisateursFindUniqueArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends utilisateursFindUniqueArgs>(args: SelectSubset<T, utilisateursFindUniqueArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Utilisateurs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {utilisateursFindUniqueOrThrowArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends utilisateursFindUniqueOrThrowArgs>(args: SelectSubset<T, utilisateursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindFirstArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends utilisateursFindFirstArgs>(args?: SelectSubset<T, utilisateursFindFirstArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Utilisateurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindFirstOrThrowArgs} args - Arguments to find a Utilisateurs
     * @example
     * // Get one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends utilisateursFindFirstOrThrowArgs>(args?: SelectSubset<T, utilisateursFindFirstOrThrowArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utilisateursWithIdOnly = await prisma.utilisateurs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends utilisateursFindManyArgs>(args?: SelectSubset<T, utilisateursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Utilisateurs.
     * @param {utilisateursCreateArgs} args - Arguments to create a Utilisateurs.
     * @example
     * // Create one Utilisateurs
     * const Utilisateurs = await prisma.utilisateurs.create({
     *   data: {
     *     // ... data to create a Utilisateurs
     *   }
     * })
     * 
     */
    create<T extends utilisateursCreateArgs>(args: SelectSubset<T, utilisateursCreateArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Utilisateurs.
     * @param {utilisateursCreateManyArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends utilisateursCreateManyArgs>(args?: SelectSubset<T, utilisateursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utilisateurs.
     * @param {utilisateursDeleteArgs} args - Arguments to delete one Utilisateurs.
     * @example
     * // Delete one Utilisateurs
     * const Utilisateurs = await prisma.utilisateurs.delete({
     *   where: {
     *     // ... filter to delete one Utilisateurs
     *   }
     * })
     * 
     */
    delete<T extends utilisateursDeleteArgs>(args: SelectSubset<T, utilisateursDeleteArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Utilisateurs.
     * @param {utilisateursUpdateArgs} args - Arguments to update one Utilisateurs.
     * @example
     * // Update one Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends utilisateursUpdateArgs>(args: SelectSubset<T, utilisateursUpdateArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Utilisateurs.
     * @param {utilisateursDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends utilisateursDeleteManyArgs>(args?: SelectSubset<T, utilisateursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends utilisateursUpdateManyArgs>(args: SelectSubset<T, utilisateursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utilisateurs.
     * @param {utilisateursUpsertArgs} args - Arguments to update or create a Utilisateurs.
     * @example
     * // Update or create a Utilisateurs
     * const utilisateurs = await prisma.utilisateurs.upsert({
     *   create: {
     *     // ... data to create a Utilisateurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateurs we want to update
     *   }
     * })
     */
    upsert<T extends utilisateursUpsertArgs>(args: SelectSubset<T, utilisateursUpsertArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateurs.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends utilisateursCountArgs>(
      args?: Subset<T, utilisateursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateursAggregateArgs>(args: Subset<T, UtilisateursAggregateArgs>): Prisma.PrismaPromise<GetUtilisateursAggregateType<T>>

    /**
     * Group by Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utilisateursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends utilisateursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: utilisateursGroupByArgs['orderBy'] }
        : { orderBy?: utilisateursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, utilisateursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the utilisateurs model
   */
  readonly fields: utilisateursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for utilisateurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__utilisateursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comptes<T extends utilisateurs$comptesArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$comptesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findMany"> | Null>
    projet_utilisateurs<T extends utilisateurs$projet_utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$projet_utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_utilisateursPayload<ExtArgs>, T, "findMany"> | Null>
    projets<T extends utilisateurs$projetsArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$projetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetsPayload<ExtArgs>, T, "findMany"> | Null>
    tache_assignations_utilisateurs<T extends utilisateurs$tache_assignations_utilisateursArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$tache_assignations_utilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tache_assignations_utilisateursPayload<ExtArgs>, T, "findMany"> | Null>
    taches<T extends utilisateurs$tachesArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$tachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tachesPayload<ExtArgs>, T, "findMany"> | Null>
    category_user<T extends utilisateurs$category_userArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$category_userArgs<ExtArgs>>): Prisma__category_userClient<$Result.GetResult<Prisma.$category_userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    groupesUtilisateurs<T extends utilisateurs$groupesUtilisateursArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$groupesUtilisateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupesUtilisateursPayload<ExtArgs>, T, "findMany"> | Null>
    Notification<T extends utilisateurs$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, utilisateurs$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the utilisateurs model
   */ 
  interface utilisateursFieldRefs {
    readonly id: FieldRef<"utilisateurs", 'Int'>
    readonly nom: FieldRef<"utilisateurs", 'String'>
    readonly prenom: FieldRef<"utilisateurs", 'String'>
    readonly email: FieldRef<"utilisateurs", 'String'>
    readonly category_id: FieldRef<"utilisateurs", 'Int'>
    readonly created_at: FieldRef<"utilisateurs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * utilisateurs findUnique
   */
  export type utilisateursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs findUniqueOrThrow
   */
  export type utilisateursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs findFirst
   */
  export type utilisateursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilisateurs.
     */
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs findFirstOrThrow
   */
  export type utilisateursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utilisateurs.
     */
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs findMany
   */
  export type utilisateursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * Filter, which utilisateurs to fetch.
     */
    where?: utilisateursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utilisateurs to fetch.
     */
    orderBy?: utilisateursOrderByWithRelationInput | utilisateursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing utilisateurs.
     */
    cursor?: utilisateursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utilisateurs.
     */
    skip?: number
    distinct?: UtilisateursScalarFieldEnum | UtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs create
   */
  export type utilisateursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * The data needed to create a utilisateurs.
     */
    data: XOR<utilisateursCreateInput, utilisateursUncheckedCreateInput>
  }

  /**
   * utilisateurs createMany
   */
  export type utilisateursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many utilisateurs.
     */
    data: utilisateursCreateManyInput | utilisateursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * utilisateurs update
   */
  export type utilisateursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * The data needed to update a utilisateurs.
     */
    data: XOR<utilisateursUpdateInput, utilisateursUncheckedUpdateInput>
    /**
     * Choose, which utilisateurs to update.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs updateMany
   */
  export type utilisateursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update utilisateurs.
     */
    data: XOR<utilisateursUpdateManyMutationInput, utilisateursUncheckedUpdateManyInput>
    /**
     * Filter which utilisateurs to update
     */
    where?: utilisateursWhereInput
  }

  /**
   * utilisateurs upsert
   */
  export type utilisateursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * The filter to search for the utilisateurs to update in case it exists.
     */
    where: utilisateursWhereUniqueInput
    /**
     * In case the utilisateurs found by the `where` argument doesn't exist, create a new utilisateurs with this data.
     */
    create: XOR<utilisateursCreateInput, utilisateursUncheckedCreateInput>
    /**
     * In case the utilisateurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<utilisateursUpdateInput, utilisateursUncheckedUpdateInput>
  }

  /**
   * utilisateurs delete
   */
  export type utilisateursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    /**
     * Filter which utilisateurs to delete.
     */
    where: utilisateursWhereUniqueInput
  }

  /**
   * utilisateurs deleteMany
   */
  export type utilisateursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utilisateurs to delete
     */
    where?: utilisateursWhereInput
  }

  /**
   * utilisateurs.comptes
   */
  export type utilisateurs$comptesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comptes
     */
    select?: comptesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comptesInclude<ExtArgs> | null
    where?: comptesWhereInput
    orderBy?: comptesOrderByWithRelationInput | comptesOrderByWithRelationInput[]
    cursor?: comptesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComptesScalarFieldEnum | ComptesScalarFieldEnum[]
  }

  /**
   * utilisateurs.projet_utilisateurs
   */
  export type utilisateurs$projet_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_utilisateurs
     */
    select?: projet_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_utilisateursInclude<ExtArgs> | null
    where?: projet_utilisateursWhereInput
    orderBy?: projet_utilisateursOrderByWithRelationInput | projet_utilisateursOrderByWithRelationInput[]
    cursor?: projet_utilisateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_utilisateursScalarFieldEnum | Projet_utilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs.projets
   */
  export type utilisateurs$projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projets
     */
    select?: projetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetsInclude<ExtArgs> | null
    where?: projetsWhereInput
    orderBy?: projetsOrderByWithRelationInput | projetsOrderByWithRelationInput[]
    cursor?: projetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetsScalarFieldEnum | ProjetsScalarFieldEnum[]
  }

  /**
   * utilisateurs.tache_assignations_utilisateurs
   */
  export type utilisateurs$tache_assignations_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tache_assignations_utilisateurs
     */
    select?: tache_assignations_utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tache_assignations_utilisateursInclude<ExtArgs> | null
    where?: tache_assignations_utilisateursWhereInput
    orderBy?: tache_assignations_utilisateursOrderByWithRelationInput | tache_assignations_utilisateursOrderByWithRelationInput[]
    cursor?: tache_assignations_utilisateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tache_assignations_utilisateursScalarFieldEnum | Tache_assignations_utilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs.taches
   */
  export type utilisateurs$tachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taches
     */
    select?: tachesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tachesInclude<ExtArgs> | null
    where?: tachesWhereInput
    orderBy?: tachesOrderByWithRelationInput | tachesOrderByWithRelationInput[]
    cursor?: tachesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TachesScalarFieldEnum | TachesScalarFieldEnum[]
  }

  /**
   * utilisateurs.category_user
   */
  export type utilisateurs$category_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_user
     */
    select?: category_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_userInclude<ExtArgs> | null
    where?: category_userWhereInput
  }

  /**
   * utilisateurs.groupesUtilisateurs
   */
  export type utilisateurs$groupesUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupesUtilisateurs
     */
    select?: GroupesUtilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupesUtilisateursInclude<ExtArgs> | null
    where?: GroupesUtilisateursWhereInput
    orderBy?: GroupesUtilisateursOrderByWithRelationInput | GroupesUtilisateursOrderByWithRelationInput[]
    cursor?: GroupesUtilisateursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupesUtilisateursScalarFieldEnum | GroupesUtilisateursScalarFieldEnum[]
  }

  /**
   * utilisateurs.Notification
   */
  export type utilisateurs$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * utilisateurs without action
   */
  export type utilisateursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
  }


  /**
   * Model votes
   */

  export type AggregateVotes = {
    _count: VotesCountAggregateOutputType | null
    _avg: VotesAvgAggregateOutputType | null
    _sum: VotesSumAggregateOutputType | null
    _min: VotesMinAggregateOutputType | null
    _max: VotesMaxAggregateOutputType | null
  }

  export type VotesAvgAggregateOutputType = {
    id: number | null
    compte_id: number | null
    vote_value: number | null
  }

  export type VotesSumAggregateOutputType = {
    id: number | null
    compte_id: number | null
    vote_value: number | null
  }

  export type VotesMinAggregateOutputType = {
    id: number | null
    compte_id: number | null
    vote_value: number | null
    voted_at: Date | null
  }

  export type VotesMaxAggregateOutputType = {
    id: number | null
    compte_id: number | null
    vote_value: number | null
    voted_at: Date | null
  }

  export type VotesCountAggregateOutputType = {
    id: number
    compte_id: number
    vote_value: number
    voted_at: number
    _all: number
  }


  export type VotesAvgAggregateInputType = {
    id?: true
    compte_id?: true
    vote_value?: true
  }

  export type VotesSumAggregateInputType = {
    id?: true
    compte_id?: true
    vote_value?: true
  }

  export type VotesMinAggregateInputType = {
    id?: true
    compte_id?: true
    vote_value?: true
    voted_at?: true
  }

  export type VotesMaxAggregateInputType = {
    id?: true
    compte_id?: true
    vote_value?: true
    voted_at?: true
  }

  export type VotesCountAggregateInputType = {
    id?: true
    compte_id?: true
    vote_value?: true
    voted_at?: true
    _all?: true
  }

  export type VotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which votes to aggregate.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned votes
    **/
    _count?: true | VotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VotesMaxAggregateInputType
  }

  export type GetVotesAggregateType<T extends VotesAggregateArgs> = {
        [P in keyof T & keyof AggregateVotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVotes[P]>
      : GetScalarType<T[P], AggregateVotes[P]>
  }




  export type votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: votesWhereInput
    orderBy?: votesOrderByWithAggregationInput | votesOrderByWithAggregationInput[]
    by: VotesScalarFieldEnum[] | VotesScalarFieldEnum
    having?: votesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VotesCountAggregateInputType | true
    _avg?: VotesAvgAggregateInputType
    _sum?: VotesSumAggregateInputType
    _min?: VotesMinAggregateInputType
    _max?: VotesMaxAggregateInputType
  }

  export type VotesGroupByOutputType = {
    id: number
    compte_id: number
    vote_value: number | null
    voted_at: Date
    _count: VotesCountAggregateOutputType | null
    _avg: VotesAvgAggregateOutputType | null
    _sum: VotesSumAggregateOutputType | null
    _min: VotesMinAggregateOutputType | null
    _max: VotesMaxAggregateOutputType | null
  }

  type GetVotesGroupByPayload<T extends votesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VotesGroupByOutputType[P]>
            : GetScalarType<T[P], VotesGroupByOutputType[P]>
        }
      >
    >


  export type votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    compte_id?: boolean
    vote_value?: boolean
    voted_at?: boolean
    comptes?: boolean | comptesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["votes"]>


  export type votesSelectScalar = {
    id?: boolean
    compte_id?: boolean
    vote_value?: boolean
    voted_at?: boolean
  }

  export type votesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comptes?: boolean | comptesDefaultArgs<ExtArgs>
  }

  export type $votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "votes"
    objects: {
      comptes: Prisma.$comptesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      compte_id: number
      vote_value: number | null
      voted_at: Date
    }, ExtArgs["result"]["votes"]>
    composites: {}
  }

  type votesGetPayload<S extends boolean | null | undefined | votesDefaultArgs> = $Result.GetResult<Prisma.$votesPayload, S>

  type votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<votesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VotesCountAggregateInputType | true
    }

  export interface votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['votes'], meta: { name: 'votes' } }
    /**
     * Find zero or one Votes that matches the filter.
     * @param {votesFindUniqueArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends votesFindUniqueArgs>(args: SelectSubset<T, votesFindUniqueArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Votes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {votesFindUniqueOrThrowArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends votesFindUniqueOrThrowArgs>(args: SelectSubset<T, votesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesFindFirstArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends votesFindFirstArgs>(args?: SelectSubset<T, votesFindFirstArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Votes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesFindFirstOrThrowArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends votesFindFirstOrThrowArgs>(args?: SelectSubset<T, votesFindFirstOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.votes.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.votes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const votesWithIdOnly = await prisma.votes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends votesFindManyArgs>(args?: SelectSubset<T, votesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Votes.
     * @param {votesCreateArgs} args - Arguments to create a Votes.
     * @example
     * // Create one Votes
     * const Votes = await prisma.votes.create({
     *   data: {
     *     // ... data to create a Votes
     *   }
     * })
     * 
     */
    create<T extends votesCreateArgs>(args: SelectSubset<T, votesCreateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Votes.
     * @param {votesCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const votes = await prisma.votes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends votesCreateManyArgs>(args?: SelectSubset<T, votesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Votes.
     * @param {votesDeleteArgs} args - Arguments to delete one Votes.
     * @example
     * // Delete one Votes
     * const Votes = await prisma.votes.delete({
     *   where: {
     *     // ... filter to delete one Votes
     *   }
     * })
     * 
     */
    delete<T extends votesDeleteArgs>(args: SelectSubset<T, votesDeleteArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Votes.
     * @param {votesUpdateArgs} args - Arguments to update one Votes.
     * @example
     * // Update one Votes
     * const votes = await prisma.votes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends votesUpdateArgs>(args: SelectSubset<T, votesUpdateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Votes.
     * @param {votesDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.votes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends votesDeleteManyArgs>(args?: SelectSubset<T, votesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const votes = await prisma.votes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends votesUpdateManyArgs>(args: SelectSubset<T, votesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Votes.
     * @param {votesUpsertArgs} args - Arguments to update or create a Votes.
     * @example
     * // Update or create a Votes
     * const votes = await prisma.votes.upsert({
     *   create: {
     *     // ... data to create a Votes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Votes we want to update
     *   }
     * })
     */
    upsert<T extends votesUpsertArgs>(args: SelectSubset<T, votesUpsertArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.votes.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends votesCountArgs>(
      args?: Subset<T, votesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VotesAggregateArgs>(args: Subset<T, VotesAggregateArgs>): Prisma.PrismaPromise<GetVotesAggregateType<T>>

    /**
     * Group by Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends votesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: votesGroupByArgs['orderBy'] }
        : { orderBy?: votesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the votes model
   */
  readonly fields: votesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for votes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comptes<T extends comptesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, comptesDefaultArgs<ExtArgs>>): Prisma__comptesClient<$Result.GetResult<Prisma.$comptesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the votes model
   */ 
  interface votesFieldRefs {
    readonly id: FieldRef<"votes", 'Int'>
    readonly compte_id: FieldRef<"votes", 'Int'>
    readonly vote_value: FieldRef<"votes", 'Int'>
    readonly voted_at: FieldRef<"votes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * votes findUnique
   */
  export type votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes findUniqueOrThrow
   */
  export type votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes findFirst
   */
  export type votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for votes.
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of votes.
     */
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * votes findFirstOrThrow
   */
  export type votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for votes.
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of votes.
     */
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * votes findMany
   */
  export type votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing votes.
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * votes create
   */
  export type votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * The data needed to create a votes.
     */
    data: XOR<votesCreateInput, votesUncheckedCreateInput>
  }

  /**
   * votes createMany
   */
  export type votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many votes.
     */
    data: votesCreateManyInput | votesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * votes update
   */
  export type votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * The data needed to update a votes.
     */
    data: XOR<votesUpdateInput, votesUncheckedUpdateInput>
    /**
     * Choose, which votes to update.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes updateMany
   */
  export type votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update votes.
     */
    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyInput>
    /**
     * Filter which votes to update
     */
    where?: votesWhereInput
  }

  /**
   * votes upsert
   */
  export type votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * The filter to search for the votes to update in case it exists.
     */
    where: votesWhereUniqueInput
    /**
     * In case the votes found by the `where` argument doesn't exist, create a new votes with this data.
     */
    create: XOR<votesCreateInput, votesUncheckedCreateInput>
    /**
     * In case the votes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<votesUpdateInput, votesUncheckedUpdateInput>
  }

  /**
   * votes delete
   */
  export type votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter which votes to delete.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes deleteMany
   */
  export type votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which votes to delete
     */
    where?: votesWhereInput
  }

  /**
   * votes without action
   */
  export type votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    groupeId: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    groupeId: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    titre: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: number | null
    groupeId: number | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    titre: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: number | null
    groupeId: number | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    titre: number
    message: number
    type: number
    isRead: number
    createdAt: number
    userId: number
    groupeId: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    userId?: true
    groupeId?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    userId?: true
    groupeId?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    titre?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
    groupeId?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    titre?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
    groupeId?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    titre?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
    groupeId?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    titre: string
    message: string
    type: string
    isRead: boolean
    createdAt: Date
    userId: number | null
    groupeId: number | null
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    groupeId?: boolean
    user?: boolean | notifications$userArgs<ExtArgs>
    groupe?: boolean | notifications$groupeArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>


  export type notificationsSelectScalar = {
    id?: boolean
    titre?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    groupeId?: boolean
  }

  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | notifications$userArgs<ExtArgs>
    groupe?: boolean | notifications$groupeArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      user: Prisma.$utilisateursPayload<ExtArgs> | null
      groupe: Prisma.$groupesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titre: string
      message: string
      type: string
      isRead: boolean
      createdAt: Date
      userId: number | null
      groupeId: number | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends notifications$userArgs<ExtArgs> = {}>(args?: Subset<T, notifications$userArgs<ExtArgs>>): Prisma__utilisateursClient<$Result.GetResult<Prisma.$utilisateursPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    groupe<T extends notifications$groupeArgs<ExtArgs> = {}>(args?: Subset<T, notifications$groupeArgs<ExtArgs>>): Prisma__groupesClient<$Result.GetResult<Prisma.$groupesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */ 
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'Int'>
    readonly titre: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'String'>
    readonly isRead: FieldRef<"notifications", 'Boolean'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
    readonly userId: FieldRef<"notifications", 'Int'>
    readonly groupeId: FieldRef<"notifications", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications.user
   */
  export type notifications$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utilisateurs
     */
    select?: utilisateursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: utilisateursInclude<ExtArgs> | null
    where?: utilisateursWhereInput
  }

  /**
   * notifications.groupe
   */
  export type notifications$groupeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupes
     */
    select?: groupesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupesInclude<ExtArgs> | null
    where?: groupesWhereInput
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Actualite_imagesScalarFieldEnum: {
    id: 'id',
    actualite_id: 'actualite_id',
    image_url: 'image_url'
  };

  export type Actualite_imagesScalarFieldEnum = (typeof Actualite_imagesScalarFieldEnum)[keyof typeof Actualite_imagesScalarFieldEnum]


  export const ActualitesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type ActualitesScalarFieldEnum = (typeof ActualitesScalarFieldEnum)[keyof typeof ActualitesScalarFieldEnum]


  export const AxesScalarFieldEnum: {
    id: 'id',
    plan_id: 'plan_id',
    name: 'name',
    description: 'description',
    statut: 'statut',
    objectif: 'objectif',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type AxesScalarFieldEnum = (typeof AxesScalarFieldEnum)[keyof typeof AxesScalarFieldEnum]


  export const Category_userScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type Category_userScalarFieldEnum = (typeof Category_userScalarFieldEnum)[keyof typeof Category_userScalarFieldEnum]


  export const CommentairesScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    compte_id: 'compte_id',
    content: 'content',
    created_at: 'created_at'
  };

  export type CommentairesScalarFieldEnum = (typeof CommentairesScalarFieldEnum)[keyof typeof CommentairesScalarFieldEnum]


  export const ComptesScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    role_id: 'role_id',
    validity: 'validity',
    user_id: 'user_id'
  };

  export type ComptesScalarFieldEnum = (typeof ComptesScalarFieldEnum)[keyof typeof ComptesScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    name: 'name',
    file_path: 'file_path',
    uploaded_at: 'uploaded_at'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const EvaluationsScalarFieldEnum: {
    id: 'id',
    indicator_id: 'indicator_id',
    evaluation_date: 'evaluation_date',
    value: 'value',
    comment: 'comment'
  };

  export type EvaluationsScalarFieldEnum = (typeof EvaluationsScalarFieldEnum)[keyof typeof EvaluationsScalarFieldEnum]


  export const GroupesScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type GroupesScalarFieldEnum = (typeof GroupesScalarFieldEnum)[keyof typeof GroupesScalarFieldEnum]


  export const IndicateursScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    name: 'name',
    description: 'description',
    unit: 'unit',
    baseline_value: 'baseline_value',
    target_value: 'target_value',
    current_value: 'current_value',
    latitude: 'latitude',
    longitude: 'longitude',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type IndicateursScalarFieldEnum = (typeof IndicateursScalarFieldEnum)[keyof typeof IndicateursScalarFieldEnum]


  export const GroupesUtilisateursScalarFieldEnum: {
    groupe_id: 'groupe_id',
    utilisateur_id: 'utilisateur_id'
  };

  export type GroupesUtilisateursScalarFieldEnum = (typeof GroupesUtilisateursScalarFieldEnum)[keyof typeof GroupesUtilisateursScalarFieldEnum]


  export const NewsletterScalarFieldEnum: {
    id: 'id',
    title: 'title',
    body: 'body',
    posted_by: 'posted_by',
    created_date: 'created_date',
    last_updated: 'last_updated',
    newsletter_statut: 'newsletter_statut'
  };

  export type NewsletterScalarFieldEnum = (typeof NewsletterScalarFieldEnum)[keyof typeof NewsletterScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const Plans_actionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    objectif: 'objectif',
    start_date: 'start_date',
    end_date: 'end_date',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type Plans_actionScalarFieldEnum = (typeof Plans_actionScalarFieldEnum)[keyof typeof Plans_actionScalarFieldEnum]


  export const PriorityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type PriorityScalarFieldEnum = (typeof PriorityScalarFieldEnum)[keyof typeof PriorityScalarFieldEnum]


  export const Projet_groupesScalarFieldEnum: {
    projet_id: 'projet_id',
    groupe_id: 'groupe_id'
  };

  export type Projet_groupesScalarFieldEnum = (typeof Projet_groupesScalarFieldEnum)[keyof typeof Projet_groupesScalarFieldEnum]


  export const Projet_utilisateursScalarFieldEnum: {
    projet_id: 'projet_id',
    utilisateur_id: 'utilisateur_id'
  };

  export type Projet_utilisateursScalarFieldEnum = (typeof Projet_utilisateursScalarFieldEnum)[keyof typeof Projet_utilisateursScalarFieldEnum]


  export const ProjetsScalarFieldEnum: {
    id: 'id',
    axe_id: 'axe_id',
    priority_id: 'priority_id',
    manager: 'manager',
    name: 'name',
    description: 'description',
    objectif: 'objectif',
    statut: 'statut',
    budget: 'budget',
    start_date: 'start_date',
    end_date: 'end_date',
    created_date: 'created_date',
    last_updated: 'last_updated',
    target_value: 'target_value',
    current_value: 'current_value'
  };

  export type ProjetsScalarFieldEnum = (typeof ProjetsScalarFieldEnum)[keyof typeof ProjetsScalarFieldEnum]


  export const RessourcesScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    unit: 'unit',
    cost: 'cost'
  };

  export type RessourcesScalarFieldEnum = (typeof RessourcesScalarFieldEnum)[keyof typeof RessourcesScalarFieldEnum]


  export const Role_permissionsScalarFieldEnum: {
    role_id: 'role_id',
    permission_id: 'permission_id'
  };

  export type Role_permissionsScalarFieldEnum = (typeof Role_permissionsScalarFieldEnum)[keyof typeof Role_permissionsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    created_date: 'created_date',
    last_updated: 'last_updated'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SuggestionsScalarFieldEnum: {
    id: 'id',
    compte_id: 'compte_id',
    project_id: 'project_id',
    suggestion_content: 'suggestion_content',
    submitted_at: 'submitted_at'
  };

  export type SuggestionsScalarFieldEnum = (typeof SuggestionsScalarFieldEnum)[keyof typeof SuggestionsScalarFieldEnum]


  export const Tache_assignations_groupesScalarFieldEnum: {
    tache_id: 'tache_id',
    groupe_id: 'groupe_id'
  };

  export type Tache_assignations_groupesScalarFieldEnum = (typeof Tache_assignations_groupesScalarFieldEnum)[keyof typeof Tache_assignations_groupesScalarFieldEnum]


  export const Tache_assignations_utilisateursScalarFieldEnum: {
    tache_id: 'tache_id',
    utilisateur_id: 'utilisateur_id'
  };

  export type Tache_assignations_utilisateursScalarFieldEnum = (typeof Tache_assignations_utilisateursScalarFieldEnum)[keyof typeof Tache_assignations_utilisateursScalarFieldEnum]


  export const TachesScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle',
    description: 'description',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    projet_id: 'projet_id',
    utilisateur_id: 'utilisateur_id',
    statut: 'statut',
    priorite: 'priorite',
    dateCreation: 'dateCreation',
    dateMiseAJour: 'dateMiseAJour',
    delaiEstime: 'delaiEstime',
    delaiReel: 'delaiReel',
    commentaires: 'commentaires',
    tacheParentId: 'tacheParentId'
  };

  export type TachesScalarFieldEnum = (typeof TachesScalarFieldEnum)[keyof typeof TachesScalarFieldEnum]


  export const UtilisateursScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    category_id: 'category_id',
    created_at: 'created_at'
  };

  export type UtilisateursScalarFieldEnum = (typeof UtilisateursScalarFieldEnum)[keyof typeof UtilisateursScalarFieldEnum]


  export const VotesScalarFieldEnum: {
    id: 'id',
    compte_id: 'compte_id',
    vote_value: 'vote_value',
    voted_at: 'voted_at'
  };

  export type VotesScalarFieldEnum = (typeof VotesScalarFieldEnum)[keyof typeof VotesScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt',
    userId: 'userId',
    groupeId: 'groupeId'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'comptes_validity'
   */
  export type Enumcomptes_validityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'comptes_validity'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type actualite_imagesWhereInput = {
    AND?: actualite_imagesWhereInput | actualite_imagesWhereInput[]
    OR?: actualite_imagesWhereInput[]
    NOT?: actualite_imagesWhereInput | actualite_imagesWhereInput[]
    id?: IntFilter<"actualite_images"> | number
    actualite_id?: IntFilter<"actualite_images"> | number
    image_url?: StringFilter<"actualite_images"> | string
    actualites?: XOR<ActualitesRelationFilter, actualitesWhereInput>
  }

  export type actualite_imagesOrderByWithRelationInput = {
    id?: SortOrder
    actualite_id?: SortOrder
    image_url?: SortOrder
    actualites?: actualitesOrderByWithRelationInput
  }

  export type actualite_imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: actualite_imagesWhereInput | actualite_imagesWhereInput[]
    OR?: actualite_imagesWhereInput[]
    NOT?: actualite_imagesWhereInput | actualite_imagesWhereInput[]
    actualite_id?: IntFilter<"actualite_images"> | number
    image_url?: StringFilter<"actualite_images"> | string
    actualites?: XOR<ActualitesRelationFilter, actualitesWhereInput>
  }, "id">

  export type actualite_imagesOrderByWithAggregationInput = {
    id?: SortOrder
    actualite_id?: SortOrder
    image_url?: SortOrder
    _count?: actualite_imagesCountOrderByAggregateInput
    _avg?: actualite_imagesAvgOrderByAggregateInput
    _max?: actualite_imagesMaxOrderByAggregateInput
    _min?: actualite_imagesMinOrderByAggregateInput
    _sum?: actualite_imagesSumOrderByAggregateInput
  }

  export type actualite_imagesScalarWhereWithAggregatesInput = {
    AND?: actualite_imagesScalarWhereWithAggregatesInput | actualite_imagesScalarWhereWithAggregatesInput[]
    OR?: actualite_imagesScalarWhereWithAggregatesInput[]
    NOT?: actualite_imagesScalarWhereWithAggregatesInput | actualite_imagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"actualite_images"> | number
    actualite_id?: IntWithAggregatesFilter<"actualite_images"> | number
    image_url?: StringWithAggregatesFilter<"actualite_images"> | string
  }

  export type actualitesWhereInput = {
    AND?: actualitesWhereInput | actualitesWhereInput[]
    OR?: actualitesWhereInput[]
    NOT?: actualitesWhereInput | actualitesWhereInput[]
    id?: IntFilter<"actualites"> | number
    title?: StringFilter<"actualites"> | string
    content?: StringFilter<"actualites"> | string
    created_date?: DateTimeFilter<"actualites"> | Date | string
    last_updated?: DateTimeFilter<"actualites"> | Date | string
    actualite_images?: Actualite_imagesListRelationFilter
  }

  export type actualitesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    actualite_images?: actualite_imagesOrderByRelationAggregateInput
  }

  export type actualitesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: actualitesWhereInput | actualitesWhereInput[]
    OR?: actualitesWhereInput[]
    NOT?: actualitesWhereInput | actualitesWhereInput[]
    title?: StringFilter<"actualites"> | string
    content?: StringFilter<"actualites"> | string
    created_date?: DateTimeFilter<"actualites"> | Date | string
    last_updated?: DateTimeFilter<"actualites"> | Date | string
    actualite_images?: Actualite_imagesListRelationFilter
  }, "id">

  export type actualitesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: actualitesCountOrderByAggregateInput
    _avg?: actualitesAvgOrderByAggregateInput
    _max?: actualitesMaxOrderByAggregateInput
    _min?: actualitesMinOrderByAggregateInput
    _sum?: actualitesSumOrderByAggregateInput
  }

  export type actualitesScalarWhereWithAggregatesInput = {
    AND?: actualitesScalarWhereWithAggregatesInput | actualitesScalarWhereWithAggregatesInput[]
    OR?: actualitesScalarWhereWithAggregatesInput[]
    NOT?: actualitesScalarWhereWithAggregatesInput | actualitesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"actualites"> | number
    title?: StringWithAggregatesFilter<"actualites"> | string
    content?: StringWithAggregatesFilter<"actualites"> | string
    created_date?: DateTimeWithAggregatesFilter<"actualites"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"actualites"> | Date | string
  }

  export type axesWhereInput = {
    AND?: axesWhereInput | axesWhereInput[]
    OR?: axesWhereInput[]
    NOT?: axesWhereInput | axesWhereInput[]
    id?: IntFilter<"axes"> | number
    plan_id?: IntFilter<"axes"> | number
    name?: StringFilter<"axes"> | string
    description?: StringNullableFilter<"axes"> | string | null
    statut?: StringNullableFilter<"axes"> | string | null
    objectif?: StringNullableFilter<"axes"> | string | null
    created_date?: DateTimeFilter<"axes"> | Date | string
    last_updated?: DateTimeFilter<"axes"> | Date | string
    plans_action?: XOR<Plans_actionRelationFilter, plans_actionWhereInput>
    projets?: ProjetsListRelationFilter
  }

  export type axesOrderByWithRelationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    objectif?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    plans_action?: plans_actionOrderByWithRelationInput
    projets?: projetsOrderByRelationAggregateInput
  }

  export type axesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: axesWhereInput | axesWhereInput[]
    OR?: axesWhereInput[]
    NOT?: axesWhereInput | axesWhereInput[]
    plan_id?: IntFilter<"axes"> | number
    name?: StringFilter<"axes"> | string
    description?: StringNullableFilter<"axes"> | string | null
    statut?: StringNullableFilter<"axes"> | string | null
    objectif?: StringNullableFilter<"axes"> | string | null
    created_date?: DateTimeFilter<"axes"> | Date | string
    last_updated?: DateTimeFilter<"axes"> | Date | string
    plans_action?: XOR<Plans_actionRelationFilter, plans_actionWhereInput>
    projets?: ProjetsListRelationFilter
  }, "id">

  export type axesOrderByWithAggregationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    objectif?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: axesCountOrderByAggregateInput
    _avg?: axesAvgOrderByAggregateInput
    _max?: axesMaxOrderByAggregateInput
    _min?: axesMinOrderByAggregateInput
    _sum?: axesSumOrderByAggregateInput
  }

  export type axesScalarWhereWithAggregatesInput = {
    AND?: axesScalarWhereWithAggregatesInput | axesScalarWhereWithAggregatesInput[]
    OR?: axesScalarWhereWithAggregatesInput[]
    NOT?: axesScalarWhereWithAggregatesInput | axesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"axes"> | number
    plan_id?: IntWithAggregatesFilter<"axes"> | number
    name?: StringWithAggregatesFilter<"axes"> | string
    description?: StringNullableWithAggregatesFilter<"axes"> | string | null
    statut?: StringNullableWithAggregatesFilter<"axes"> | string | null
    objectif?: StringNullableWithAggregatesFilter<"axes"> | string | null
    created_date?: DateTimeWithAggregatesFilter<"axes"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"axes"> | Date | string
  }

  export type category_userWhereInput = {
    AND?: category_userWhereInput | category_userWhereInput[]
    OR?: category_userWhereInput[]
    NOT?: category_userWhereInput | category_userWhereInput[]
    id?: IntFilter<"category_user"> | number
    name?: StringFilter<"category_user"> | string
    description?: StringFilter<"category_user"> | string
    created_date?: DateTimeFilter<"category_user"> | Date | string
    last_updated?: DateTimeFilter<"category_user"> | Date | string
    utilisateurs?: UtilisateursListRelationFilter
  }

  export type category_userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    utilisateurs?: utilisateursOrderByRelationAggregateInput
  }

  export type category_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: category_userWhereInput | category_userWhereInput[]
    OR?: category_userWhereInput[]
    NOT?: category_userWhereInput | category_userWhereInput[]
    name?: StringFilter<"category_user"> | string
    description?: StringFilter<"category_user"> | string
    created_date?: DateTimeFilter<"category_user"> | Date | string
    last_updated?: DateTimeFilter<"category_user"> | Date | string
    utilisateurs?: UtilisateursListRelationFilter
  }, "id">

  export type category_userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: category_userCountOrderByAggregateInput
    _avg?: category_userAvgOrderByAggregateInput
    _max?: category_userMaxOrderByAggregateInput
    _min?: category_userMinOrderByAggregateInput
    _sum?: category_userSumOrderByAggregateInput
  }

  export type category_userScalarWhereWithAggregatesInput = {
    AND?: category_userScalarWhereWithAggregatesInput | category_userScalarWhereWithAggregatesInput[]
    OR?: category_userScalarWhereWithAggregatesInput[]
    NOT?: category_userScalarWhereWithAggregatesInput | category_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category_user"> | number
    name?: StringWithAggregatesFilter<"category_user"> | string
    description?: StringWithAggregatesFilter<"category_user"> | string
    created_date?: DateTimeWithAggregatesFilter<"category_user"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"category_user"> | Date | string
  }

  export type commentairesWhereInput = {
    AND?: commentairesWhereInput | commentairesWhereInput[]
    OR?: commentairesWhereInput[]
    NOT?: commentairesWhereInput | commentairesWhereInput[]
    id?: IntFilter<"commentaires"> | number
    project_id?: IntFilter<"commentaires"> | number
    compte_id?: IntFilter<"commentaires"> | number
    content?: StringFilter<"commentaires"> | string
    created_at?: DateTimeFilter<"commentaires"> | Date | string
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
    comptes?: XOR<ComptesRelationFilter, comptesWhereInput>
  }

  export type commentairesOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    compte_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    projets?: projetsOrderByWithRelationInput
    comptes?: comptesOrderByWithRelationInput
  }

  export type commentairesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: commentairesWhereInput | commentairesWhereInput[]
    OR?: commentairesWhereInput[]
    NOT?: commentairesWhereInput | commentairesWhereInput[]
    project_id?: IntFilter<"commentaires"> | number
    compte_id?: IntFilter<"commentaires"> | number
    content?: StringFilter<"commentaires"> | string
    created_at?: DateTimeFilter<"commentaires"> | Date | string
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
    comptes?: XOR<ComptesRelationFilter, comptesWhereInput>
  }, "id">

  export type commentairesOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    compte_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    _count?: commentairesCountOrderByAggregateInput
    _avg?: commentairesAvgOrderByAggregateInput
    _max?: commentairesMaxOrderByAggregateInput
    _min?: commentairesMinOrderByAggregateInput
    _sum?: commentairesSumOrderByAggregateInput
  }

  export type commentairesScalarWhereWithAggregatesInput = {
    AND?: commentairesScalarWhereWithAggregatesInput | commentairesScalarWhereWithAggregatesInput[]
    OR?: commentairesScalarWhereWithAggregatesInput[]
    NOT?: commentairesScalarWhereWithAggregatesInput | commentairesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"commentaires"> | number
    project_id?: IntWithAggregatesFilter<"commentaires"> | number
    compte_id?: IntWithAggregatesFilter<"commentaires"> | number
    content?: StringWithAggregatesFilter<"commentaires"> | string
    created_at?: DateTimeWithAggregatesFilter<"commentaires"> | Date | string
  }

  export type comptesWhereInput = {
    AND?: comptesWhereInput | comptesWhereInput[]
    OR?: comptesWhereInput[]
    NOT?: comptesWhereInput | comptesWhereInput[]
    id?: IntFilter<"comptes"> | number
    username?: StringFilter<"comptes"> | string
    password?: StringFilter<"comptes"> | string
    role_id?: IntFilter<"comptes"> | number
    validity?: Enumcomptes_validityFilter<"comptes"> | $Enums.comptes_validity
    user_id?: IntNullableFilter<"comptes"> | number | null
    commentaires?: CommentairesListRelationFilter
    utilisateurs?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    suggestions?: SuggestionsListRelationFilter
    votes?: VotesListRelationFilter
  }

  export type comptesOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    validity?: SortOrder
    user_id?: SortOrderInput | SortOrder
    commentaires?: commentairesOrderByRelationAggregateInput
    utilisateurs?: utilisateursOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
    suggestions?: suggestionsOrderByRelationAggregateInput
    votes?: votesOrderByRelationAggregateInput
  }

  export type comptesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: comptesWhereInput | comptesWhereInput[]
    OR?: comptesWhereInput[]
    NOT?: comptesWhereInput | comptesWhereInput[]
    password?: StringFilter<"comptes"> | string
    role_id?: IntFilter<"comptes"> | number
    validity?: Enumcomptes_validityFilter<"comptes"> | $Enums.comptes_validity
    user_id?: IntNullableFilter<"comptes"> | number | null
    commentaires?: CommentairesListRelationFilter
    utilisateurs?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    suggestions?: SuggestionsListRelationFilter
    votes?: VotesListRelationFilter
  }, "id" | "username">

  export type comptesOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    validity?: SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: comptesCountOrderByAggregateInput
    _avg?: comptesAvgOrderByAggregateInput
    _max?: comptesMaxOrderByAggregateInput
    _min?: comptesMinOrderByAggregateInput
    _sum?: comptesSumOrderByAggregateInput
  }

  export type comptesScalarWhereWithAggregatesInput = {
    AND?: comptesScalarWhereWithAggregatesInput | comptesScalarWhereWithAggregatesInput[]
    OR?: comptesScalarWhereWithAggregatesInput[]
    NOT?: comptesScalarWhereWithAggregatesInput | comptesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"comptes"> | number
    username?: StringWithAggregatesFilter<"comptes"> | string
    password?: StringWithAggregatesFilter<"comptes"> | string
    role_id?: IntWithAggregatesFilter<"comptes"> | number
    validity?: Enumcomptes_validityWithAggregatesFilter<"comptes"> | $Enums.comptes_validity
    user_id?: IntNullableWithAggregatesFilter<"comptes"> | number | null
  }

  export type documentsWhereInput = {
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    id?: IntFilter<"documents"> | number
    project_id?: IntFilter<"documents"> | number
    name?: StringFilter<"documents"> | string
    file_path?: StringNullableFilter<"documents"> | string | null
    uploaded_at?: DateTimeFilter<"documents"> | Date | string
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }

  export type documentsOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    file_path?: SortOrderInput | SortOrder
    uploaded_at?: SortOrder
    projets?: projetsOrderByWithRelationInput
  }

  export type documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    project_id?: IntFilter<"documents"> | number
    name?: StringFilter<"documents"> | string
    file_path?: StringNullableFilter<"documents"> | string | null
    uploaded_at?: DateTimeFilter<"documents"> | Date | string
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }, "id">

  export type documentsOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    file_path?: SortOrderInput | SortOrder
    uploaded_at?: SortOrder
    _count?: documentsCountOrderByAggregateInput
    _avg?: documentsAvgOrderByAggregateInput
    _max?: documentsMaxOrderByAggregateInput
    _min?: documentsMinOrderByAggregateInput
    _sum?: documentsSumOrderByAggregateInput
  }

  export type documentsScalarWhereWithAggregatesInput = {
    AND?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    OR?: documentsScalarWhereWithAggregatesInput[]
    NOT?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"documents"> | number
    project_id?: IntWithAggregatesFilter<"documents"> | number
    name?: StringWithAggregatesFilter<"documents"> | string
    file_path?: StringNullableWithAggregatesFilter<"documents"> | string | null
    uploaded_at?: DateTimeWithAggregatesFilter<"documents"> | Date | string
  }

  export type evaluationsWhereInput = {
    AND?: evaluationsWhereInput | evaluationsWhereInput[]
    OR?: evaluationsWhereInput[]
    NOT?: evaluationsWhereInput | evaluationsWhereInput[]
    id?: IntFilter<"evaluations"> | number
    indicator_id?: IntFilter<"evaluations"> | number
    evaluation_date?: DateTimeNullableFilter<"evaluations"> | Date | string | null
    value?: FloatNullableFilter<"evaluations"> | number | null
    comment?: StringNullableFilter<"evaluations"> | string | null
    indicateurs?: XOR<IndicateursRelationFilter, indicateursWhereInput>
  }

  export type evaluationsOrderByWithRelationInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    evaluation_date?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    indicateurs?: indicateursOrderByWithRelationInput
  }

  export type evaluationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: evaluationsWhereInput | evaluationsWhereInput[]
    OR?: evaluationsWhereInput[]
    NOT?: evaluationsWhereInput | evaluationsWhereInput[]
    indicator_id?: IntFilter<"evaluations"> | number
    evaluation_date?: DateTimeNullableFilter<"evaluations"> | Date | string | null
    value?: FloatNullableFilter<"evaluations"> | number | null
    comment?: StringNullableFilter<"evaluations"> | string | null
    indicateurs?: XOR<IndicateursRelationFilter, indicateursWhereInput>
  }, "id">

  export type evaluationsOrderByWithAggregationInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    evaluation_date?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: evaluationsCountOrderByAggregateInput
    _avg?: evaluationsAvgOrderByAggregateInput
    _max?: evaluationsMaxOrderByAggregateInput
    _min?: evaluationsMinOrderByAggregateInput
    _sum?: evaluationsSumOrderByAggregateInput
  }

  export type evaluationsScalarWhereWithAggregatesInput = {
    AND?: evaluationsScalarWhereWithAggregatesInput | evaluationsScalarWhereWithAggregatesInput[]
    OR?: evaluationsScalarWhereWithAggregatesInput[]
    NOT?: evaluationsScalarWhereWithAggregatesInput | evaluationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"evaluations"> | number
    indicator_id?: IntWithAggregatesFilter<"evaluations"> | number
    evaluation_date?: DateTimeNullableWithAggregatesFilter<"evaluations"> | Date | string | null
    value?: FloatNullableWithAggregatesFilter<"evaluations"> | number | null
    comment?: StringNullableWithAggregatesFilter<"evaluations"> | string | null
  }

  export type groupesWhereInput = {
    AND?: groupesWhereInput | groupesWhereInput[]
    OR?: groupesWhereInput[]
    NOT?: groupesWhereInput | groupesWhereInput[]
    id?: IntFilter<"groupes"> | number
    nom?: StringFilter<"groupes"> | string
    projet_groupes?: Projet_groupesListRelationFilter
    tache_assignations_groupes?: Tache_assignations_groupesListRelationFilter
    groupesUtilisateurs?: GroupesUtilisateursListRelationFilter
    Notification?: NotificationsListRelationFilter
  }

  export type groupesOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    projet_groupes?: projet_groupesOrderByRelationAggregateInput
    tache_assignations_groupes?: tache_assignations_groupesOrderByRelationAggregateInput
    groupesUtilisateurs?: GroupesUtilisateursOrderByRelationAggregateInput
    Notification?: notificationsOrderByRelationAggregateInput
  }

  export type groupesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: groupesWhereInput | groupesWhereInput[]
    OR?: groupesWhereInput[]
    NOT?: groupesWhereInput | groupesWhereInput[]
    nom?: StringFilter<"groupes"> | string
    projet_groupes?: Projet_groupesListRelationFilter
    tache_assignations_groupes?: Tache_assignations_groupesListRelationFilter
    groupesUtilisateurs?: GroupesUtilisateursListRelationFilter
    Notification?: NotificationsListRelationFilter
  }, "id">

  export type groupesOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: groupesCountOrderByAggregateInput
    _avg?: groupesAvgOrderByAggregateInput
    _max?: groupesMaxOrderByAggregateInput
    _min?: groupesMinOrderByAggregateInput
    _sum?: groupesSumOrderByAggregateInput
  }

  export type groupesScalarWhereWithAggregatesInput = {
    AND?: groupesScalarWhereWithAggregatesInput | groupesScalarWhereWithAggregatesInput[]
    OR?: groupesScalarWhereWithAggregatesInput[]
    NOT?: groupesScalarWhereWithAggregatesInput | groupesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"groupes"> | number
    nom?: StringWithAggregatesFilter<"groupes"> | string
  }

  export type indicateursWhereInput = {
    AND?: indicateursWhereInput | indicateursWhereInput[]
    OR?: indicateursWhereInput[]
    NOT?: indicateursWhereInput | indicateursWhereInput[]
    id?: IntFilter<"indicateurs"> | number
    project_id?: IntFilter<"indicateurs"> | number
    name?: StringFilter<"indicateurs"> | string
    description?: StringNullableFilter<"indicateurs"> | string | null
    unit?: StringNullableFilter<"indicateurs"> | string | null
    baseline_value?: FloatNullableFilter<"indicateurs"> | number | null
    target_value?: FloatNullableFilter<"indicateurs"> | number | null
    current_value?: FloatNullableFilter<"indicateurs"> | number | null
    latitude?: FloatNullableFilter<"indicateurs"> | number | null
    longitude?: FloatNullableFilter<"indicateurs"> | number | null
    created_date?: DateTimeFilter<"indicateurs"> | Date | string
    last_updated?: DateTimeFilter<"indicateurs"> | Date | string
    evaluations?: EvaluationsListRelationFilter
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }

  export type indicateursOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    baseline_value?: SortOrderInput | SortOrder
    target_value?: SortOrderInput | SortOrder
    current_value?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    evaluations?: evaluationsOrderByRelationAggregateInput
    projets?: projetsOrderByWithRelationInput
  }

  export type indicateursWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: indicateursWhereInput | indicateursWhereInput[]
    OR?: indicateursWhereInput[]
    NOT?: indicateursWhereInput | indicateursWhereInput[]
    project_id?: IntFilter<"indicateurs"> | number
    name?: StringFilter<"indicateurs"> | string
    description?: StringNullableFilter<"indicateurs"> | string | null
    unit?: StringNullableFilter<"indicateurs"> | string | null
    baseline_value?: FloatNullableFilter<"indicateurs"> | number | null
    target_value?: FloatNullableFilter<"indicateurs"> | number | null
    current_value?: FloatNullableFilter<"indicateurs"> | number | null
    latitude?: FloatNullableFilter<"indicateurs"> | number | null
    longitude?: FloatNullableFilter<"indicateurs"> | number | null
    created_date?: DateTimeFilter<"indicateurs"> | Date | string
    last_updated?: DateTimeFilter<"indicateurs"> | Date | string
    evaluations?: EvaluationsListRelationFilter
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }, "id">

  export type indicateursOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    baseline_value?: SortOrderInput | SortOrder
    target_value?: SortOrderInput | SortOrder
    current_value?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: indicateursCountOrderByAggregateInput
    _avg?: indicateursAvgOrderByAggregateInput
    _max?: indicateursMaxOrderByAggregateInput
    _min?: indicateursMinOrderByAggregateInput
    _sum?: indicateursSumOrderByAggregateInput
  }

  export type indicateursScalarWhereWithAggregatesInput = {
    AND?: indicateursScalarWhereWithAggregatesInput | indicateursScalarWhereWithAggregatesInput[]
    OR?: indicateursScalarWhereWithAggregatesInput[]
    NOT?: indicateursScalarWhereWithAggregatesInput | indicateursScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"indicateurs"> | number
    project_id?: IntWithAggregatesFilter<"indicateurs"> | number
    name?: StringWithAggregatesFilter<"indicateurs"> | string
    description?: StringNullableWithAggregatesFilter<"indicateurs"> | string | null
    unit?: StringNullableWithAggregatesFilter<"indicateurs"> | string | null
    baseline_value?: FloatNullableWithAggregatesFilter<"indicateurs"> | number | null
    target_value?: FloatNullableWithAggregatesFilter<"indicateurs"> | number | null
    current_value?: FloatNullableWithAggregatesFilter<"indicateurs"> | number | null
    latitude?: FloatNullableWithAggregatesFilter<"indicateurs"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"indicateurs"> | number | null
    created_date?: DateTimeWithAggregatesFilter<"indicateurs"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"indicateurs"> | Date | string
  }

  export type GroupesUtilisateursWhereInput = {
    AND?: GroupesUtilisateursWhereInput | GroupesUtilisateursWhereInput[]
    OR?: GroupesUtilisateursWhereInput[]
    NOT?: GroupesUtilisateursWhereInput | GroupesUtilisateursWhereInput[]
    groupe_id?: IntFilter<"GroupesUtilisateurs"> | number
    utilisateur_id?: IntFilter<"GroupesUtilisateurs"> | number
    groupes?: XOR<GroupesRelationFilter, groupesWhereInput>
    utilisateurs?: XOR<UtilisateursRelationFilter, utilisateursWhereInput>
  }

  export type GroupesUtilisateursOrderByWithRelationInput = {
    groupe_id?: SortOrder
    utilisateur_id?: SortOrder
    groupes?: groupesOrderByWithRelationInput
    utilisateurs?: utilisateursOrderByWithRelationInput
  }

  export type GroupesUtilisateursWhereUniqueInput = Prisma.AtLeast<{
    groupe_id_utilisateur_id?: GroupesUtilisateursGroupe_idUtilisateur_idCompoundUniqueInput
    AND?: GroupesUtilisateursWhereInput | GroupesUtilisateursWhereInput[]
    OR?: GroupesUtilisateursWhereInput[]
    NOT?: GroupesUtilisateursWhereInput | GroupesUtilisateursWhereInput[]
    groupe_id?: IntFilter<"GroupesUtilisateurs"> | number
    utilisateur_id?: IntFilter<"GroupesUtilisateurs"> | number
    groupes?: XOR<GroupesRelationFilter, groupesWhereInput>
    utilisateurs?: XOR<UtilisateursRelationFilter, utilisateursWhereInput>
  }, "groupe_id_utilisateur_id">

  export type GroupesUtilisateursOrderByWithAggregationInput = {
    groupe_id?: SortOrder
    utilisateur_id?: SortOrder
    _count?: GroupesUtilisateursCountOrderByAggregateInput
    _avg?: GroupesUtilisateursAvgOrderByAggregateInput
    _max?: GroupesUtilisateursMaxOrderByAggregateInput
    _min?: GroupesUtilisateursMinOrderByAggregateInput
    _sum?: GroupesUtilisateursSumOrderByAggregateInput
  }

  export type GroupesUtilisateursScalarWhereWithAggregatesInput = {
    AND?: GroupesUtilisateursScalarWhereWithAggregatesInput | GroupesUtilisateursScalarWhereWithAggregatesInput[]
    OR?: GroupesUtilisateursScalarWhereWithAggregatesInput[]
    NOT?: GroupesUtilisateursScalarWhereWithAggregatesInput | GroupesUtilisateursScalarWhereWithAggregatesInput[]
    groupe_id?: IntWithAggregatesFilter<"GroupesUtilisateurs"> | number
    utilisateur_id?: IntWithAggregatesFilter<"GroupesUtilisateurs"> | number
  }

  export type newsletterWhereInput = {
    AND?: newsletterWhereInput | newsletterWhereInput[]
    OR?: newsletterWhereInput[]
    NOT?: newsletterWhereInput | newsletterWhereInput[]
    id?: IntFilter<"newsletter"> | number
    title?: StringNullableFilter<"newsletter"> | string | null
    body?: StringFilter<"newsletter"> | string
    posted_by?: IntFilter<"newsletter"> | number
    created_date?: DateTimeFilter<"newsletter"> | Date | string
    last_updated?: DateTimeFilter<"newsletter"> | Date | string
    newsletter_statut?: StringFilter<"newsletter"> | string
  }

  export type newsletterOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrder
    posted_by?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    newsletter_statut?: SortOrder
  }

  export type newsletterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: newsletterWhereInput | newsletterWhereInput[]
    OR?: newsletterWhereInput[]
    NOT?: newsletterWhereInput | newsletterWhereInput[]
    title?: StringNullableFilter<"newsletter"> | string | null
    body?: StringFilter<"newsletter"> | string
    posted_by?: IntFilter<"newsletter"> | number
    created_date?: DateTimeFilter<"newsletter"> | Date | string
    last_updated?: DateTimeFilter<"newsletter"> | Date | string
    newsletter_statut?: StringFilter<"newsletter"> | string
  }, "id">

  export type newsletterOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrder
    posted_by?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    newsletter_statut?: SortOrder
    _count?: newsletterCountOrderByAggregateInput
    _avg?: newsletterAvgOrderByAggregateInput
    _max?: newsletterMaxOrderByAggregateInput
    _min?: newsletterMinOrderByAggregateInput
    _sum?: newsletterSumOrderByAggregateInput
  }

  export type newsletterScalarWhereWithAggregatesInput = {
    AND?: newsletterScalarWhereWithAggregatesInput | newsletterScalarWhereWithAggregatesInput[]
    OR?: newsletterScalarWhereWithAggregatesInput[]
    NOT?: newsletterScalarWhereWithAggregatesInput | newsletterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"newsletter"> | number
    title?: StringNullableWithAggregatesFilter<"newsletter"> | string | null
    body?: StringWithAggregatesFilter<"newsletter"> | string
    posted_by?: IntWithAggregatesFilter<"newsletter"> | number
    created_date?: DateTimeWithAggregatesFilter<"newsletter"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"newsletter"> | Date | string
    newsletter_statut?: StringWithAggregatesFilter<"newsletter"> | string
  }

  export type permissionsWhereInput = {
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    id?: IntFilter<"permissions"> | number
    name?: StringFilter<"permissions"> | string
    description?: StringNullableFilter<"permissions"> | string | null
    created_date?: DateTimeFilter<"permissions"> | Date | string
    last_updated?: DateTimeFilter<"permissions"> | Date | string
    role_permissions?: Role_permissionsListRelationFilter
  }

  export type permissionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    role_permissions?: role_permissionsOrderByRelationAggregateInput
  }

  export type permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    name?: StringFilter<"permissions"> | string
    description?: StringNullableFilter<"permissions"> | string | null
    created_date?: DateTimeFilter<"permissions"> | Date | string
    last_updated?: DateTimeFilter<"permissions"> | Date | string
    role_permissions?: Role_permissionsListRelationFilter
  }, "id">

  export type permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: permissionsCountOrderByAggregateInput
    _avg?: permissionsAvgOrderByAggregateInput
    _max?: permissionsMaxOrderByAggregateInput
    _min?: permissionsMinOrderByAggregateInput
    _sum?: permissionsSumOrderByAggregateInput
  }

  export type permissionsScalarWhereWithAggregatesInput = {
    AND?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    OR?: permissionsScalarWhereWithAggregatesInput[]
    NOT?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"permissions"> | number
    name?: StringWithAggregatesFilter<"permissions"> | string
    description?: StringNullableWithAggregatesFilter<"permissions"> | string | null
    created_date?: DateTimeWithAggregatesFilter<"permissions"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"permissions"> | Date | string
  }

  export type plans_actionWhereInput = {
    AND?: plans_actionWhereInput | plans_actionWhereInput[]
    OR?: plans_actionWhereInput[]
    NOT?: plans_actionWhereInput | plans_actionWhereInput[]
    id?: IntFilter<"plans_action"> | number
    name?: StringFilter<"plans_action"> | string
    description?: StringNullableFilter<"plans_action"> | string | null
    objectif?: StringNullableFilter<"plans_action"> | string | null
    start_date?: DateTimeNullableFilter<"plans_action"> | Date | string | null
    end_date?: DateTimeNullableFilter<"plans_action"> | Date | string | null
    created_date?: DateTimeFilter<"plans_action"> | Date | string
    last_updated?: DateTimeFilter<"plans_action"> | Date | string
    axes?: AxesListRelationFilter
  }

  export type plans_actionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objectif?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    axes?: axesOrderByRelationAggregateInput
  }

  export type plans_actionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: plans_actionWhereInput | plans_actionWhereInput[]
    OR?: plans_actionWhereInput[]
    NOT?: plans_actionWhereInput | plans_actionWhereInput[]
    name?: StringFilter<"plans_action"> | string
    description?: StringNullableFilter<"plans_action"> | string | null
    objectif?: StringNullableFilter<"plans_action"> | string | null
    start_date?: DateTimeNullableFilter<"plans_action"> | Date | string | null
    end_date?: DateTimeNullableFilter<"plans_action"> | Date | string | null
    created_date?: DateTimeFilter<"plans_action"> | Date | string
    last_updated?: DateTimeFilter<"plans_action"> | Date | string
    axes?: AxesListRelationFilter
  }, "id">

  export type plans_actionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objectif?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: plans_actionCountOrderByAggregateInput
    _avg?: plans_actionAvgOrderByAggregateInput
    _max?: plans_actionMaxOrderByAggregateInput
    _min?: plans_actionMinOrderByAggregateInput
    _sum?: plans_actionSumOrderByAggregateInput
  }

  export type plans_actionScalarWhereWithAggregatesInput = {
    AND?: plans_actionScalarWhereWithAggregatesInput | plans_actionScalarWhereWithAggregatesInput[]
    OR?: plans_actionScalarWhereWithAggregatesInput[]
    NOT?: plans_actionScalarWhereWithAggregatesInput | plans_actionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"plans_action"> | number
    name?: StringWithAggregatesFilter<"plans_action"> | string
    description?: StringNullableWithAggregatesFilter<"plans_action"> | string | null
    objectif?: StringNullableWithAggregatesFilter<"plans_action"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"plans_action"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"plans_action"> | Date | string | null
    created_date?: DateTimeWithAggregatesFilter<"plans_action"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"plans_action"> | Date | string
  }

  export type priorityWhereInput = {
    AND?: priorityWhereInput | priorityWhereInput[]
    OR?: priorityWhereInput[]
    NOT?: priorityWhereInput | priorityWhereInput[]
    id?: IntFilter<"priority"> | number
    name?: StringFilter<"priority"> | string
    created_date?: DateTimeFilter<"priority"> | Date | string
    last_updated?: DateTimeFilter<"priority"> | Date | string
    projets?: ProjetsListRelationFilter
  }

  export type priorityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    projets?: projetsOrderByRelationAggregateInput
  }

  export type priorityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: priorityWhereInput | priorityWhereInput[]
    OR?: priorityWhereInput[]
    NOT?: priorityWhereInput | priorityWhereInput[]
    name?: StringFilter<"priority"> | string
    created_date?: DateTimeFilter<"priority"> | Date | string
    last_updated?: DateTimeFilter<"priority"> | Date | string
    projets?: ProjetsListRelationFilter
  }, "id">

  export type priorityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: priorityCountOrderByAggregateInput
    _avg?: priorityAvgOrderByAggregateInput
    _max?: priorityMaxOrderByAggregateInput
    _min?: priorityMinOrderByAggregateInput
    _sum?: prioritySumOrderByAggregateInput
  }

  export type priorityScalarWhereWithAggregatesInput = {
    AND?: priorityScalarWhereWithAggregatesInput | priorityScalarWhereWithAggregatesInput[]
    OR?: priorityScalarWhereWithAggregatesInput[]
    NOT?: priorityScalarWhereWithAggregatesInput | priorityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"priority"> | number
    name?: StringWithAggregatesFilter<"priority"> | string
    created_date?: DateTimeWithAggregatesFilter<"priority"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"priority"> | Date | string
  }

  export type projet_groupesWhereInput = {
    AND?: projet_groupesWhereInput | projet_groupesWhereInput[]
    OR?: projet_groupesWhereInput[]
    NOT?: projet_groupesWhereInput | projet_groupesWhereInput[]
    projet_id?: IntFilter<"projet_groupes"> | number
    groupe_id?: IntFilter<"projet_groupes"> | number
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
    groupes?: XOR<GroupesRelationFilter, groupesWhereInput>
  }

  export type projet_groupesOrderByWithRelationInput = {
    projet_id?: SortOrder
    groupe_id?: SortOrder
    projets?: projetsOrderByWithRelationInput
    groupes?: groupesOrderByWithRelationInput
  }

  export type projet_groupesWhereUniqueInput = Prisma.AtLeast<{
    projet_id_groupe_id?: projet_groupesProjet_idGroupe_idCompoundUniqueInput
    AND?: projet_groupesWhereInput | projet_groupesWhereInput[]
    OR?: projet_groupesWhereInput[]
    NOT?: projet_groupesWhereInput | projet_groupesWhereInput[]
    projet_id?: IntFilter<"projet_groupes"> | number
    groupe_id?: IntFilter<"projet_groupes"> | number
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
    groupes?: XOR<GroupesRelationFilter, groupesWhereInput>
  }, "projet_id_groupe_id">

  export type projet_groupesOrderByWithAggregationInput = {
    projet_id?: SortOrder
    groupe_id?: SortOrder
    _count?: projet_groupesCountOrderByAggregateInput
    _avg?: projet_groupesAvgOrderByAggregateInput
    _max?: projet_groupesMaxOrderByAggregateInput
    _min?: projet_groupesMinOrderByAggregateInput
    _sum?: projet_groupesSumOrderByAggregateInput
  }

  export type projet_groupesScalarWhereWithAggregatesInput = {
    AND?: projet_groupesScalarWhereWithAggregatesInput | projet_groupesScalarWhereWithAggregatesInput[]
    OR?: projet_groupesScalarWhereWithAggregatesInput[]
    NOT?: projet_groupesScalarWhereWithAggregatesInput | projet_groupesScalarWhereWithAggregatesInput[]
    projet_id?: IntWithAggregatesFilter<"projet_groupes"> | number
    groupe_id?: IntWithAggregatesFilter<"projet_groupes"> | number
  }

  export type projet_utilisateursWhereInput = {
    AND?: projet_utilisateursWhereInput | projet_utilisateursWhereInput[]
    OR?: projet_utilisateursWhereInput[]
    NOT?: projet_utilisateursWhereInput | projet_utilisateursWhereInput[]
    projet_id?: IntFilter<"projet_utilisateurs"> | number
    utilisateur_id?: IntFilter<"projet_utilisateurs"> | number
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
    utilisateurs?: XOR<UtilisateursRelationFilter, utilisateursWhereInput>
  }

  export type projet_utilisateursOrderByWithRelationInput = {
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
    projets?: projetsOrderByWithRelationInput
    utilisateurs?: utilisateursOrderByWithRelationInput
  }

  export type projet_utilisateursWhereUniqueInput = Prisma.AtLeast<{
    projet_id_utilisateur_id?: projet_utilisateursProjet_idUtilisateur_idCompoundUniqueInput
    AND?: projet_utilisateursWhereInput | projet_utilisateursWhereInput[]
    OR?: projet_utilisateursWhereInput[]
    NOT?: projet_utilisateursWhereInput | projet_utilisateursWhereInput[]
    projet_id?: IntFilter<"projet_utilisateurs"> | number
    utilisateur_id?: IntFilter<"projet_utilisateurs"> | number
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
    utilisateurs?: XOR<UtilisateursRelationFilter, utilisateursWhereInput>
  }, "projet_id_utilisateur_id">

  export type projet_utilisateursOrderByWithAggregationInput = {
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
    _count?: projet_utilisateursCountOrderByAggregateInput
    _avg?: projet_utilisateursAvgOrderByAggregateInput
    _max?: projet_utilisateursMaxOrderByAggregateInput
    _min?: projet_utilisateursMinOrderByAggregateInput
    _sum?: projet_utilisateursSumOrderByAggregateInput
  }

  export type projet_utilisateursScalarWhereWithAggregatesInput = {
    AND?: projet_utilisateursScalarWhereWithAggregatesInput | projet_utilisateursScalarWhereWithAggregatesInput[]
    OR?: projet_utilisateursScalarWhereWithAggregatesInput[]
    NOT?: projet_utilisateursScalarWhereWithAggregatesInput | projet_utilisateursScalarWhereWithAggregatesInput[]
    projet_id?: IntWithAggregatesFilter<"projet_utilisateurs"> | number
    utilisateur_id?: IntWithAggregatesFilter<"projet_utilisateurs"> | number
  }

  export type projetsWhereInput = {
    AND?: projetsWhereInput | projetsWhereInput[]
    OR?: projetsWhereInput[]
    NOT?: projetsWhereInput | projetsWhereInput[]
    id?: IntFilter<"projets"> | number
    axe_id?: IntFilter<"projets"> | number
    priority_id?: IntNullableFilter<"projets"> | number | null
    manager?: IntNullableFilter<"projets"> | number | null
    name?: StringFilter<"projets"> | string
    description?: StringNullableFilter<"projets"> | string | null
    objectif?: StringNullableFilter<"projets"> | string | null
    statut?: StringNullableFilter<"projets"> | string | null
    budget?: IntNullableFilter<"projets"> | number | null
    start_date?: DateTimeNullableFilter<"projets"> | Date | string | null
    end_date?: DateTimeNullableFilter<"projets"> | Date | string | null
    created_date?: DateTimeFilter<"projets"> | Date | string
    last_updated?: DateTimeFilter<"projets"> | Date | string
    target_value?: FloatNullableFilter<"projets"> | number | null
    current_value?: FloatNullableFilter<"projets"> | number | null
    commentaires?: CommentairesListRelationFilter
    documents?: DocumentsListRelationFilter
    indicateurs?: IndicateursListRelationFilter
    projet_groupes?: Projet_groupesListRelationFilter
    projet_utilisateurs?: Projet_utilisateursListRelationFilter
    utilisateurs?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    axes?: XOR<AxesRelationFilter, axesWhereInput>
    priority?: XOR<PriorityNullableRelationFilter, priorityWhereInput> | null
    ressources?: RessourcesListRelationFilter
    suggestions?: SuggestionsListRelationFilter
    taches?: TachesListRelationFilter
  }

  export type projetsOrderByWithRelationInput = {
    id?: SortOrder
    axe_id?: SortOrder
    priority_id?: SortOrderInput | SortOrder
    manager?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objectif?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    target_value?: SortOrderInput | SortOrder
    current_value?: SortOrderInput | SortOrder
    commentaires?: commentairesOrderByRelationAggregateInput
    documents?: documentsOrderByRelationAggregateInput
    indicateurs?: indicateursOrderByRelationAggregateInput
    projet_groupes?: projet_groupesOrderByRelationAggregateInput
    projet_utilisateurs?: projet_utilisateursOrderByRelationAggregateInput
    utilisateurs?: utilisateursOrderByWithRelationInput
    axes?: axesOrderByWithRelationInput
    priority?: priorityOrderByWithRelationInput
    ressources?: ressourcesOrderByRelationAggregateInput
    suggestions?: suggestionsOrderByRelationAggregateInput
    taches?: tachesOrderByRelationAggregateInput
  }

  export type projetsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: projetsWhereInput | projetsWhereInput[]
    OR?: projetsWhereInput[]
    NOT?: projetsWhereInput | projetsWhereInput[]
    axe_id?: IntFilter<"projets"> | number
    priority_id?: IntNullableFilter<"projets"> | number | null
    manager?: IntNullableFilter<"projets"> | number | null
    name?: StringFilter<"projets"> | string
    description?: StringNullableFilter<"projets"> | string | null
    objectif?: StringNullableFilter<"projets"> | string | null
    statut?: StringNullableFilter<"projets"> | string | null
    budget?: IntNullableFilter<"projets"> | number | null
    start_date?: DateTimeNullableFilter<"projets"> | Date | string | null
    end_date?: DateTimeNullableFilter<"projets"> | Date | string | null
    created_date?: DateTimeFilter<"projets"> | Date | string
    last_updated?: DateTimeFilter<"projets"> | Date | string
    target_value?: FloatNullableFilter<"projets"> | number | null
    current_value?: FloatNullableFilter<"projets"> | number | null
    commentaires?: CommentairesListRelationFilter
    documents?: DocumentsListRelationFilter
    indicateurs?: IndicateursListRelationFilter
    projet_groupes?: Projet_groupesListRelationFilter
    projet_utilisateurs?: Projet_utilisateursListRelationFilter
    utilisateurs?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    axes?: XOR<AxesRelationFilter, axesWhereInput>
    priority?: XOR<PriorityNullableRelationFilter, priorityWhereInput> | null
    ressources?: RessourcesListRelationFilter
    suggestions?: SuggestionsListRelationFilter
    taches?: TachesListRelationFilter
  }, "id">

  export type projetsOrderByWithAggregationInput = {
    id?: SortOrder
    axe_id?: SortOrder
    priority_id?: SortOrderInput | SortOrder
    manager?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objectif?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    target_value?: SortOrderInput | SortOrder
    current_value?: SortOrderInput | SortOrder
    _count?: projetsCountOrderByAggregateInput
    _avg?: projetsAvgOrderByAggregateInput
    _max?: projetsMaxOrderByAggregateInput
    _min?: projetsMinOrderByAggregateInput
    _sum?: projetsSumOrderByAggregateInput
  }

  export type projetsScalarWhereWithAggregatesInput = {
    AND?: projetsScalarWhereWithAggregatesInput | projetsScalarWhereWithAggregatesInput[]
    OR?: projetsScalarWhereWithAggregatesInput[]
    NOT?: projetsScalarWhereWithAggregatesInput | projetsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"projets"> | number
    axe_id?: IntWithAggregatesFilter<"projets"> | number
    priority_id?: IntNullableWithAggregatesFilter<"projets"> | number | null
    manager?: IntNullableWithAggregatesFilter<"projets"> | number | null
    name?: StringWithAggregatesFilter<"projets"> | string
    description?: StringNullableWithAggregatesFilter<"projets"> | string | null
    objectif?: StringNullableWithAggregatesFilter<"projets"> | string | null
    statut?: StringNullableWithAggregatesFilter<"projets"> | string | null
    budget?: IntNullableWithAggregatesFilter<"projets"> | number | null
    start_date?: DateTimeNullableWithAggregatesFilter<"projets"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"projets"> | Date | string | null
    created_date?: DateTimeWithAggregatesFilter<"projets"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"projets"> | Date | string
    target_value?: FloatNullableWithAggregatesFilter<"projets"> | number | null
    current_value?: FloatNullableWithAggregatesFilter<"projets"> | number | null
  }

  export type ressourcesWhereInput = {
    AND?: ressourcesWhereInput | ressourcesWhereInput[]
    OR?: ressourcesWhereInput[]
    NOT?: ressourcesWhereInput | ressourcesWhereInput[]
    id?: IntFilter<"ressources"> | number
    project_id?: IntFilter<"ressources"> | number
    name?: StringFilter<"ressources"> | string
    description?: StringNullableFilter<"ressources"> | string | null
    quantity?: FloatNullableFilter<"ressources"> | number | null
    unit?: StringNullableFilter<"ressources"> | string | null
    cost?: DecimalNullableFilter<"ressources"> | Decimal | DecimalJsLike | number | string | null
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }

  export type ressourcesOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    projets?: projetsOrderByWithRelationInput
  }

  export type ressourcesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ressourcesWhereInput | ressourcesWhereInput[]
    OR?: ressourcesWhereInput[]
    NOT?: ressourcesWhereInput | ressourcesWhereInput[]
    project_id?: IntFilter<"ressources"> | number
    name?: StringFilter<"ressources"> | string
    description?: StringNullableFilter<"ressources"> | string | null
    quantity?: FloatNullableFilter<"ressources"> | number | null
    unit?: StringNullableFilter<"ressources"> | string | null
    cost?: DecimalNullableFilter<"ressources"> | Decimal | DecimalJsLike | number | string | null
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }, "id">

  export type ressourcesOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    _count?: ressourcesCountOrderByAggregateInput
    _avg?: ressourcesAvgOrderByAggregateInput
    _max?: ressourcesMaxOrderByAggregateInput
    _min?: ressourcesMinOrderByAggregateInput
    _sum?: ressourcesSumOrderByAggregateInput
  }

  export type ressourcesScalarWhereWithAggregatesInput = {
    AND?: ressourcesScalarWhereWithAggregatesInput | ressourcesScalarWhereWithAggregatesInput[]
    OR?: ressourcesScalarWhereWithAggregatesInput[]
    NOT?: ressourcesScalarWhereWithAggregatesInput | ressourcesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ressources"> | number
    project_id?: IntWithAggregatesFilter<"ressources"> | number
    name?: StringWithAggregatesFilter<"ressources"> | string
    description?: StringNullableWithAggregatesFilter<"ressources"> | string | null
    quantity?: FloatNullableWithAggregatesFilter<"ressources"> | number | null
    unit?: StringNullableWithAggregatesFilter<"ressources"> | string | null
    cost?: DecimalNullableWithAggregatesFilter<"ressources"> | Decimal | DecimalJsLike | number | string | null
  }

  export type role_permissionsWhereInput = {
    AND?: role_permissionsWhereInput | role_permissionsWhereInput[]
    OR?: role_permissionsWhereInput[]
    NOT?: role_permissionsWhereInput | role_permissionsWhereInput[]
    role_id?: IntFilter<"role_permissions"> | number
    permission_id?: IntFilter<"role_permissions"> | number
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    permissions?: XOR<PermissionsRelationFilter, permissionsWhereInput>
  }

  export type role_permissionsOrderByWithRelationInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    roles?: rolesOrderByWithRelationInput
    permissions?: permissionsOrderByWithRelationInput
  }

  export type role_permissionsWhereUniqueInput = Prisma.AtLeast<{
    role_id_permission_id?: role_permissionsRole_idPermission_idCompoundUniqueInput
    AND?: role_permissionsWhereInput | role_permissionsWhereInput[]
    OR?: role_permissionsWhereInput[]
    NOT?: role_permissionsWhereInput | role_permissionsWhereInput[]
    role_id?: IntFilter<"role_permissions"> | number
    permission_id?: IntFilter<"role_permissions"> | number
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    permissions?: XOR<PermissionsRelationFilter, permissionsWhereInput>
  }, "role_id_permission_id">

  export type role_permissionsOrderByWithAggregationInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    _count?: role_permissionsCountOrderByAggregateInput
    _avg?: role_permissionsAvgOrderByAggregateInput
    _max?: role_permissionsMaxOrderByAggregateInput
    _min?: role_permissionsMinOrderByAggregateInput
    _sum?: role_permissionsSumOrderByAggregateInput
  }

  export type role_permissionsScalarWhereWithAggregatesInput = {
    AND?: role_permissionsScalarWhereWithAggregatesInput | role_permissionsScalarWhereWithAggregatesInput[]
    OR?: role_permissionsScalarWhereWithAggregatesInput[]
    NOT?: role_permissionsScalarWhereWithAggregatesInput | role_permissionsScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"role_permissions"> | number
    permission_id?: IntWithAggregatesFilter<"role_permissions"> | number
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    nom?: StringFilter<"roles"> | string
    created_date?: DateTimeFilter<"roles"> | Date | string
    last_updated?: DateTimeFilter<"roles"> | Date | string
    comptes?: ComptesListRelationFilter
    role_permissions?: Role_permissionsListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    comptes?: comptesOrderByRelationAggregateInput
    role_permissions?: role_permissionsOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    nom?: StringFilter<"roles"> | string
    created_date?: DateTimeFilter<"roles"> | Date | string
    last_updated?: DateTimeFilter<"roles"> | Date | string
    comptes?: ComptesListRelationFilter
    role_permissions?: Role_permissionsListRelationFilter
  }, "id">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    nom?: StringWithAggregatesFilter<"roles"> | string
    created_date?: DateTimeWithAggregatesFilter<"roles"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"roles"> | Date | string
  }

  export type suggestionsWhereInput = {
    AND?: suggestionsWhereInput | suggestionsWhereInput[]
    OR?: suggestionsWhereInput[]
    NOT?: suggestionsWhereInput | suggestionsWhereInput[]
    id?: IntFilter<"suggestions"> | number
    compte_id?: IntFilter<"suggestions"> | number
    project_id?: IntFilter<"suggestions"> | number
    suggestion_content?: StringFilter<"suggestions"> | string
    submitted_at?: DateTimeFilter<"suggestions"> | Date | string
    comptes?: XOR<ComptesRelationFilter, comptesWhereInput>
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }

  export type suggestionsOrderByWithRelationInput = {
    id?: SortOrder
    compte_id?: SortOrder
    project_id?: SortOrder
    suggestion_content?: SortOrder
    submitted_at?: SortOrder
    comptes?: comptesOrderByWithRelationInput
    projets?: projetsOrderByWithRelationInput
  }

  export type suggestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: suggestionsWhereInput | suggestionsWhereInput[]
    OR?: suggestionsWhereInput[]
    NOT?: suggestionsWhereInput | suggestionsWhereInput[]
    compte_id?: IntFilter<"suggestions"> | number
    project_id?: IntFilter<"suggestions"> | number
    suggestion_content?: StringFilter<"suggestions"> | string
    submitted_at?: DateTimeFilter<"suggestions"> | Date | string
    comptes?: XOR<ComptesRelationFilter, comptesWhereInput>
    projets?: XOR<ProjetsRelationFilter, projetsWhereInput>
  }, "id">

  export type suggestionsOrderByWithAggregationInput = {
    id?: SortOrder
    compte_id?: SortOrder
    project_id?: SortOrder
    suggestion_content?: SortOrder
    submitted_at?: SortOrder
    _count?: suggestionsCountOrderByAggregateInput
    _avg?: suggestionsAvgOrderByAggregateInput
    _max?: suggestionsMaxOrderByAggregateInput
    _min?: suggestionsMinOrderByAggregateInput
    _sum?: suggestionsSumOrderByAggregateInput
  }

  export type suggestionsScalarWhereWithAggregatesInput = {
    AND?: suggestionsScalarWhereWithAggregatesInput | suggestionsScalarWhereWithAggregatesInput[]
    OR?: suggestionsScalarWhereWithAggregatesInput[]
    NOT?: suggestionsScalarWhereWithAggregatesInput | suggestionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"suggestions"> | number
    compte_id?: IntWithAggregatesFilter<"suggestions"> | number
    project_id?: IntWithAggregatesFilter<"suggestions"> | number
    suggestion_content?: StringWithAggregatesFilter<"suggestions"> | string
    submitted_at?: DateTimeWithAggregatesFilter<"suggestions"> | Date | string
  }

  export type tache_assignations_groupesWhereInput = {
    AND?: tache_assignations_groupesWhereInput | tache_assignations_groupesWhereInput[]
    OR?: tache_assignations_groupesWhereInput[]
    NOT?: tache_assignations_groupesWhereInput | tache_assignations_groupesWhereInput[]
    tache_id?: IntFilter<"tache_assignations_groupes"> | number
    groupe_id?: IntFilter<"tache_assignations_groupes"> | number
    taches?: XOR<TachesRelationFilter, tachesWhereInput>
    groupes?: XOR<GroupesRelationFilter, groupesWhereInput>
  }

  export type tache_assignations_groupesOrderByWithRelationInput = {
    tache_id?: SortOrder
    groupe_id?: SortOrder
    taches?: tachesOrderByWithRelationInput
    groupes?: groupesOrderByWithRelationInput
  }

  export type tache_assignations_groupesWhereUniqueInput = Prisma.AtLeast<{
    tache_id_groupe_id?: tache_assignations_groupesTache_idGroupe_idCompoundUniqueInput
    AND?: tache_assignations_groupesWhereInput | tache_assignations_groupesWhereInput[]
    OR?: tache_assignations_groupesWhereInput[]
    NOT?: tache_assignations_groupesWhereInput | tache_assignations_groupesWhereInput[]
    tache_id?: IntFilter<"tache_assignations_groupes"> | number
    groupe_id?: IntFilter<"tache_assignations_groupes"> | number
    taches?: XOR<TachesRelationFilter, tachesWhereInput>
    groupes?: XOR<GroupesRelationFilter, groupesWhereInput>
  }, "tache_id_groupe_id">

  export type tache_assignations_groupesOrderByWithAggregationInput = {
    tache_id?: SortOrder
    groupe_id?: SortOrder
    _count?: tache_assignations_groupesCountOrderByAggregateInput
    _avg?: tache_assignations_groupesAvgOrderByAggregateInput
    _max?: tache_assignations_groupesMaxOrderByAggregateInput
    _min?: tache_assignations_groupesMinOrderByAggregateInput
    _sum?: tache_assignations_groupesSumOrderByAggregateInput
  }

  export type tache_assignations_groupesScalarWhereWithAggregatesInput = {
    AND?: tache_assignations_groupesScalarWhereWithAggregatesInput | tache_assignations_groupesScalarWhereWithAggregatesInput[]
    OR?: tache_assignations_groupesScalarWhereWithAggregatesInput[]
    NOT?: tache_assignations_groupesScalarWhereWithAggregatesInput | tache_assignations_groupesScalarWhereWithAggregatesInput[]
    tache_id?: IntWithAggregatesFilter<"tache_assignations_groupes"> | number
    groupe_id?: IntWithAggregatesFilter<"tache_assignations_groupes"> | number
  }

  export type tache_assignations_utilisateursWhereInput = {
    AND?: tache_assignations_utilisateursWhereInput | tache_assignations_utilisateursWhereInput[]
    OR?: tache_assignations_utilisateursWhereInput[]
    NOT?: tache_assignations_utilisateursWhereInput | tache_assignations_utilisateursWhereInput[]
    tache_id?: IntFilter<"tache_assignations_utilisateurs"> | number
    utilisateur_id?: IntFilter<"tache_assignations_utilisateurs"> | number
    taches?: XOR<TachesRelationFilter, tachesWhereInput>
    utilisateurs?: XOR<UtilisateursRelationFilter, utilisateursWhereInput>
  }

  export type tache_assignations_utilisateursOrderByWithRelationInput = {
    tache_id?: SortOrder
    utilisateur_id?: SortOrder
    taches?: tachesOrderByWithRelationInput
    utilisateurs?: utilisateursOrderByWithRelationInput
  }

  export type tache_assignations_utilisateursWhereUniqueInput = Prisma.AtLeast<{
    tache_id_utilisateur_id?: tache_assignations_utilisateursTache_idUtilisateur_idCompoundUniqueInput
    AND?: tache_assignations_utilisateursWhereInput | tache_assignations_utilisateursWhereInput[]
    OR?: tache_assignations_utilisateursWhereInput[]
    NOT?: tache_assignations_utilisateursWhereInput | tache_assignations_utilisateursWhereInput[]
    tache_id?: IntFilter<"tache_assignations_utilisateurs"> | number
    utilisateur_id?: IntFilter<"tache_assignations_utilisateurs"> | number
    taches?: XOR<TachesRelationFilter, tachesWhereInput>
    utilisateurs?: XOR<UtilisateursRelationFilter, utilisateursWhereInput>
  }, "tache_id_utilisateur_id">

  export type tache_assignations_utilisateursOrderByWithAggregationInput = {
    tache_id?: SortOrder
    utilisateur_id?: SortOrder
    _count?: tache_assignations_utilisateursCountOrderByAggregateInput
    _avg?: tache_assignations_utilisateursAvgOrderByAggregateInput
    _max?: tache_assignations_utilisateursMaxOrderByAggregateInput
    _min?: tache_assignations_utilisateursMinOrderByAggregateInput
    _sum?: tache_assignations_utilisateursSumOrderByAggregateInput
  }

  export type tache_assignations_utilisateursScalarWhereWithAggregatesInput = {
    AND?: tache_assignations_utilisateursScalarWhereWithAggregatesInput | tache_assignations_utilisateursScalarWhereWithAggregatesInput[]
    OR?: tache_assignations_utilisateursScalarWhereWithAggregatesInput[]
    NOT?: tache_assignations_utilisateursScalarWhereWithAggregatesInput | tache_assignations_utilisateursScalarWhereWithAggregatesInput[]
    tache_id?: IntWithAggregatesFilter<"tache_assignations_utilisateurs"> | number
    utilisateur_id?: IntWithAggregatesFilter<"tache_assignations_utilisateurs"> | number
  }

  export type tachesWhereInput = {
    AND?: tachesWhereInput | tachesWhereInput[]
    OR?: tachesWhereInput[]
    NOT?: tachesWhereInput | tachesWhereInput[]
    id?: IntFilter<"taches"> | number
    libelle?: StringFilter<"taches"> | string
    description?: StringNullableFilter<"taches"> | string | null
    dateDebut?: DateTimeNullableFilter<"taches"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"taches"> | Date | string | null
    projet_id?: IntNullableFilter<"taches"> | number | null
    utilisateur_id?: IntNullableFilter<"taches"> | number | null
    statut?: StringNullableFilter<"taches"> | string | null
    priorite?: StringNullableFilter<"taches"> | string | null
    dateCreation?: DateTimeFilter<"taches"> | Date | string
    dateMiseAJour?: DateTimeFilter<"taches"> | Date | string
    delaiEstime?: StringNullableFilter<"taches"> | string | null
    delaiReel?: StringNullableFilter<"taches"> | string | null
    commentaires?: StringNullableFilter<"taches"> | string | null
    tacheParentId?: IntNullableFilter<"taches"> | number | null
    tache_assignations_groupes?: Tache_assignations_groupesListRelationFilter
    tache_assignations_utilisateurs?: Tache_assignations_utilisateursListRelationFilter
    utilisateur?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    projet?: XOR<ProjetsNullableRelationFilter, projetsWhereInput> | null
  }

  export type tachesOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    projet_id?: SortOrderInput | SortOrder
    utilisateur_id?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    priorite?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateMiseAJour?: SortOrder
    delaiEstime?: SortOrderInput | SortOrder
    delaiReel?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    tacheParentId?: SortOrderInput | SortOrder
    tache_assignations_groupes?: tache_assignations_groupesOrderByRelationAggregateInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursOrderByRelationAggregateInput
    utilisateur?: utilisateursOrderByWithRelationInput
    projet?: projetsOrderByWithRelationInput
  }

  export type tachesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tachesWhereInput | tachesWhereInput[]
    OR?: tachesWhereInput[]
    NOT?: tachesWhereInput | tachesWhereInput[]
    libelle?: StringFilter<"taches"> | string
    description?: StringNullableFilter<"taches"> | string | null
    dateDebut?: DateTimeNullableFilter<"taches"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"taches"> | Date | string | null
    projet_id?: IntNullableFilter<"taches"> | number | null
    utilisateur_id?: IntNullableFilter<"taches"> | number | null
    statut?: StringNullableFilter<"taches"> | string | null
    priorite?: StringNullableFilter<"taches"> | string | null
    dateCreation?: DateTimeFilter<"taches"> | Date | string
    dateMiseAJour?: DateTimeFilter<"taches"> | Date | string
    delaiEstime?: StringNullableFilter<"taches"> | string | null
    delaiReel?: StringNullableFilter<"taches"> | string | null
    commentaires?: StringNullableFilter<"taches"> | string | null
    tacheParentId?: IntNullableFilter<"taches"> | number | null
    tache_assignations_groupes?: Tache_assignations_groupesListRelationFilter
    tache_assignations_utilisateurs?: Tache_assignations_utilisateursListRelationFilter
    utilisateur?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    projet?: XOR<ProjetsNullableRelationFilter, projetsWhereInput> | null
  }, "id">

  export type tachesOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    projet_id?: SortOrderInput | SortOrder
    utilisateur_id?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    priorite?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateMiseAJour?: SortOrder
    delaiEstime?: SortOrderInput | SortOrder
    delaiReel?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    tacheParentId?: SortOrderInput | SortOrder
    _count?: tachesCountOrderByAggregateInput
    _avg?: tachesAvgOrderByAggregateInput
    _max?: tachesMaxOrderByAggregateInput
    _min?: tachesMinOrderByAggregateInput
    _sum?: tachesSumOrderByAggregateInput
  }

  export type tachesScalarWhereWithAggregatesInput = {
    AND?: tachesScalarWhereWithAggregatesInput | tachesScalarWhereWithAggregatesInput[]
    OR?: tachesScalarWhereWithAggregatesInput[]
    NOT?: tachesScalarWhereWithAggregatesInput | tachesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"taches"> | number
    libelle?: StringWithAggregatesFilter<"taches"> | string
    description?: StringNullableWithAggregatesFilter<"taches"> | string | null
    dateDebut?: DateTimeNullableWithAggregatesFilter<"taches"> | Date | string | null
    dateFin?: DateTimeNullableWithAggregatesFilter<"taches"> | Date | string | null
    projet_id?: IntNullableWithAggregatesFilter<"taches"> | number | null
    utilisateur_id?: IntNullableWithAggregatesFilter<"taches"> | number | null
    statut?: StringNullableWithAggregatesFilter<"taches"> | string | null
    priorite?: StringNullableWithAggregatesFilter<"taches"> | string | null
    dateCreation?: DateTimeWithAggregatesFilter<"taches"> | Date | string
    dateMiseAJour?: DateTimeWithAggregatesFilter<"taches"> | Date | string
    delaiEstime?: StringNullableWithAggregatesFilter<"taches"> | string | null
    delaiReel?: StringNullableWithAggregatesFilter<"taches"> | string | null
    commentaires?: StringNullableWithAggregatesFilter<"taches"> | string | null
    tacheParentId?: IntNullableWithAggregatesFilter<"taches"> | number | null
  }

  export type utilisateursWhereInput = {
    AND?: utilisateursWhereInput | utilisateursWhereInput[]
    OR?: utilisateursWhereInput[]
    NOT?: utilisateursWhereInput | utilisateursWhereInput[]
    id?: IntFilter<"utilisateurs"> | number
    nom?: StringFilter<"utilisateurs"> | string
    prenom?: StringFilter<"utilisateurs"> | string
    email?: StringFilter<"utilisateurs"> | string
    category_id?: IntNullableFilter<"utilisateurs"> | number | null
    created_at?: DateTimeFilter<"utilisateurs"> | Date | string
    comptes?: ComptesListRelationFilter
    projet_utilisateurs?: Projet_utilisateursListRelationFilter
    projets?: ProjetsListRelationFilter
    tache_assignations_utilisateurs?: Tache_assignations_utilisateursListRelationFilter
    taches?: TachesListRelationFilter
    category_user?: XOR<Category_userNullableRelationFilter, category_userWhereInput> | null
    groupesUtilisateurs?: GroupesUtilisateursListRelationFilter
    Notification?: NotificationsListRelationFilter
  }

  export type utilisateursOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    category_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    comptes?: comptesOrderByRelationAggregateInput
    projet_utilisateurs?: projet_utilisateursOrderByRelationAggregateInput
    projets?: projetsOrderByRelationAggregateInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursOrderByRelationAggregateInput
    taches?: tachesOrderByRelationAggregateInput
    category_user?: category_userOrderByWithRelationInput
    groupesUtilisateurs?: GroupesUtilisateursOrderByRelationAggregateInput
    Notification?: notificationsOrderByRelationAggregateInput
  }

  export type utilisateursWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: utilisateursWhereInput | utilisateursWhereInput[]
    OR?: utilisateursWhereInput[]
    NOT?: utilisateursWhereInput | utilisateursWhereInput[]
    nom?: StringFilter<"utilisateurs"> | string
    prenom?: StringFilter<"utilisateurs"> | string
    category_id?: IntNullableFilter<"utilisateurs"> | number | null
    created_at?: DateTimeFilter<"utilisateurs"> | Date | string
    comptes?: ComptesListRelationFilter
    projet_utilisateurs?: Projet_utilisateursListRelationFilter
    projets?: ProjetsListRelationFilter
    tache_assignations_utilisateurs?: Tache_assignations_utilisateursListRelationFilter
    taches?: TachesListRelationFilter
    category_user?: XOR<Category_userNullableRelationFilter, category_userWhereInput> | null
    groupesUtilisateurs?: GroupesUtilisateursListRelationFilter
    Notification?: NotificationsListRelationFilter
  }, "id" | "email">

  export type utilisateursOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    category_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: utilisateursCountOrderByAggregateInput
    _avg?: utilisateursAvgOrderByAggregateInput
    _max?: utilisateursMaxOrderByAggregateInput
    _min?: utilisateursMinOrderByAggregateInput
    _sum?: utilisateursSumOrderByAggregateInput
  }

  export type utilisateursScalarWhereWithAggregatesInput = {
    AND?: utilisateursScalarWhereWithAggregatesInput | utilisateursScalarWhereWithAggregatesInput[]
    OR?: utilisateursScalarWhereWithAggregatesInput[]
    NOT?: utilisateursScalarWhereWithAggregatesInput | utilisateursScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"utilisateurs"> | number
    nom?: StringWithAggregatesFilter<"utilisateurs"> | string
    prenom?: StringWithAggregatesFilter<"utilisateurs"> | string
    email?: StringWithAggregatesFilter<"utilisateurs"> | string
    category_id?: IntNullableWithAggregatesFilter<"utilisateurs"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"utilisateurs"> | Date | string
  }

  export type votesWhereInput = {
    AND?: votesWhereInput | votesWhereInput[]
    OR?: votesWhereInput[]
    NOT?: votesWhereInput | votesWhereInput[]
    id?: IntFilter<"votes"> | number
    compte_id?: IntFilter<"votes"> | number
    vote_value?: IntNullableFilter<"votes"> | number | null
    voted_at?: DateTimeFilter<"votes"> | Date | string
    comptes?: XOR<ComptesRelationFilter, comptesWhereInput>
  }

  export type votesOrderByWithRelationInput = {
    id?: SortOrder
    compte_id?: SortOrder
    vote_value?: SortOrderInput | SortOrder
    voted_at?: SortOrder
    comptes?: comptesOrderByWithRelationInput
  }

  export type votesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: votesWhereInput | votesWhereInput[]
    OR?: votesWhereInput[]
    NOT?: votesWhereInput | votesWhereInput[]
    compte_id?: IntFilter<"votes"> | number
    vote_value?: IntNullableFilter<"votes"> | number | null
    voted_at?: DateTimeFilter<"votes"> | Date | string
    comptes?: XOR<ComptesRelationFilter, comptesWhereInput>
  }, "id">

  export type votesOrderByWithAggregationInput = {
    id?: SortOrder
    compte_id?: SortOrder
    vote_value?: SortOrderInput | SortOrder
    voted_at?: SortOrder
    _count?: votesCountOrderByAggregateInput
    _avg?: votesAvgOrderByAggregateInput
    _max?: votesMaxOrderByAggregateInput
    _min?: votesMinOrderByAggregateInput
    _sum?: votesSumOrderByAggregateInput
  }

  export type votesScalarWhereWithAggregatesInput = {
    AND?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]
    OR?: votesScalarWhereWithAggregatesInput[]
    NOT?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"votes"> | number
    compte_id?: IntWithAggregatesFilter<"votes"> | number
    vote_value?: IntNullableWithAggregatesFilter<"votes"> | number | null
    voted_at?: DateTimeWithAggregatesFilter<"votes"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: IntFilter<"notifications"> | number
    titre?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: IntNullableFilter<"notifications"> | number | null
    groupeId?: IntNullableFilter<"notifications"> | number | null
    user?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    groupe?: XOR<GroupesNullableRelationFilter, groupesWhereInput> | null
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupeId?: SortOrderInput | SortOrder
    user?: utilisateursOrderByWithRelationInput
    groupe?: groupesOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    titre?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: IntNullableFilter<"notifications"> | number | null
    groupeId?: IntNullableFilter<"notifications"> | number | null
    user?: XOR<UtilisateursNullableRelationFilter, utilisateursWhereInput> | null
    groupe?: XOR<GroupesNullableRelationFilter, groupesWhereInput> | null
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupeId?: SortOrderInput | SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notifications"> | number
    titre?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    type?: StringWithAggregatesFilter<"notifications"> | string
    isRead?: BoolWithAggregatesFilter<"notifications"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"notifications"> | number | null
    groupeId?: IntNullableWithAggregatesFilter<"notifications"> | number | null
  }

  export type actualite_imagesCreateInput = {
    image_url: string
    actualites: actualitesCreateNestedOneWithoutActualite_imagesInput
  }

  export type actualite_imagesUncheckedCreateInput = {
    id?: number
    actualite_id: number
    image_url: string
  }

  export type actualite_imagesUpdateInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    actualites?: actualitesUpdateOneRequiredWithoutActualite_imagesNestedInput
  }

  export type actualite_imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actualite_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type actualite_imagesCreateManyInput = {
    id?: number
    actualite_id: number
    image_url: string
  }

  export type actualite_imagesUpdateManyMutationInput = {
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type actualite_imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actualite_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type actualitesCreateInput = {
    title: string
    content: string
    created_date?: Date | string
    last_updated?: Date | string
    actualite_images?: actualite_imagesCreateNestedManyWithoutActualitesInput
  }

  export type actualitesUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    created_date?: Date | string
    last_updated?: Date | string
    actualite_images?: actualite_imagesUncheckedCreateNestedManyWithoutActualitesInput
  }

  export type actualitesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    actualite_images?: actualite_imagesUpdateManyWithoutActualitesNestedInput
  }

  export type actualitesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    actualite_images?: actualite_imagesUncheckedUpdateManyWithoutActualitesNestedInput
  }

  export type actualitesCreateManyInput = {
    id?: number
    title: string
    content: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type actualitesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type actualitesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type axesCreateInput = {
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
    plans_action: plans_actionCreateNestedOneWithoutAxesInput
    projets?: projetsCreateNestedManyWithoutAxesInput
  }

  export type axesUncheckedCreateInput = {
    id?: number
    plan_id: number
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
    projets?: projetsUncheckedCreateNestedManyWithoutAxesInput
  }

  export type axesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    plans_action?: plans_actionUpdateOneRequiredWithoutAxesNestedInput
    projets?: projetsUpdateManyWithoutAxesNestedInput
  }

  export type axesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUncheckedUpdateManyWithoutAxesNestedInput
  }

  export type axesCreateManyInput = {
    id?: number
    plan_id: number
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type axesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type axesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_userCreateInput = {
    name: string
    description: string
    created_date?: Date | string
    last_updated?: Date | string
    utilisateurs?: utilisateursCreateNestedManyWithoutCategory_userInput
  }

  export type category_userUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    created_date?: Date | string
    last_updated?: Date | string
    utilisateurs?: utilisateursUncheckedCreateNestedManyWithoutCategory_userInput
  }

  export type category_userUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurs?: utilisateursUpdateManyWithoutCategory_userNestedInput
  }

  export type category_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurs?: utilisateursUncheckedUpdateManyWithoutCategory_userNestedInput
  }

  export type category_userCreateManyInput = {
    id?: number
    name: string
    description: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type category_userUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentairesCreateInput = {
    content: string
    created_at?: Date | string
    projets: projetsCreateNestedOneWithoutCommentairesInput
    comptes: comptesCreateNestedOneWithoutCommentairesInput
  }

  export type commentairesUncheckedCreateInput = {
    id?: number
    project_id: number
    compte_id: number
    content: string
    created_at?: Date | string
  }

  export type commentairesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUpdateOneRequiredWithoutCommentairesNestedInput
    comptes?: comptesUpdateOneRequiredWithoutCommentairesNestedInput
  }

  export type commentairesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentairesCreateManyInput = {
    id?: number
    project_id: number
    compte_id: number
    content: string
    created_at?: Date | string
  }

  export type commentairesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentairesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comptesCreateInput = {
    username: string
    password: string
    validity?: $Enums.comptes_validity
    commentaires?: commentairesCreateNestedManyWithoutComptesInput
    utilisateurs?: utilisateursCreateNestedOneWithoutComptesInput
    roles: rolesCreateNestedOneWithoutComptesInput
    suggestions?: suggestionsCreateNestedManyWithoutComptesInput
    votes?: votesCreateNestedManyWithoutComptesInput
  }

  export type comptesUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    role_id: number
    validity?: $Enums.comptes_validity
    user_id?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutComptesInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutComptesInput
    votes?: votesUncheckedCreateNestedManyWithoutComptesInput
  }

  export type comptesUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    commentaires?: commentairesUpdateManyWithoutComptesNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutComptesNestedInput
    roles?: rolesUpdateOneRequiredWithoutComptesNestedInput
    suggestions?: suggestionsUpdateManyWithoutComptesNestedInput
    votes?: votesUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutComptesNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutComptesNestedInput
    votes?: votesUncheckedUpdateManyWithoutComptesNestedInput
  }

  export type comptesCreateManyInput = {
    id?: number
    username: string
    password: string
    role_id: number
    validity?: $Enums.comptes_validity
    user_id?: number | null
  }

  export type comptesUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
  }

  export type comptesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type documentsCreateInput = {
    name: string
    file_path?: string | null
    uploaded_at?: Date | string
    projets: projetsCreateNestedOneWithoutDocumentsInput
  }

  export type documentsUncheckedCreateInput = {
    id?: number
    project_id: number
    name: string
    file_path?: string | null
    uploaded_at?: Date | string
  }

  export type documentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentsCreateManyInput = {
    id?: number
    project_id: number
    name: string
    file_path?: string | null
    uploaded_at?: Date | string
  }

  export type documentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type evaluationsCreateInput = {
    evaluation_date?: Date | string | null
    value?: number | null
    comment?: string | null
    indicateurs: indicateursCreateNestedOneWithoutEvaluationsInput
  }

  export type evaluationsUncheckedCreateInput = {
    id?: number
    indicator_id: number
    evaluation_date?: Date | string | null
    value?: number | null
    comment?: string | null
  }

  export type evaluationsUpdateInput = {
    evaluation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    indicateurs?: indicateursUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type evaluationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    evaluation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type evaluationsCreateManyInput = {
    id?: number
    indicator_id: number
    evaluation_date?: Date | string | null
    value?: number | null
    comment?: string | null
  }

  export type evaluationsUpdateManyMutationInput = {
    evaluation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type evaluationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    evaluation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupesCreateInput = {
    nom: string
    projet_groupes?: projet_groupesCreateNestedManyWithoutGroupesInput
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutGroupesInput
    Notification?: notificationsCreateNestedManyWithoutGroupeInput
  }

  export type groupesUncheckedCreateInput = {
    id?: number
    nom: string
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutGroupesInput
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutGroupesInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutGroupeInput
  }

  export type groupesUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUpdateManyWithoutGroupesNestedInput
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUpdateManyWithoutGroupeNestedInput
  }

  export type groupesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutGroupeNestedInput
  }

  export type groupesCreateManyInput = {
    id?: number
    nom: string
  }

  export type groupesUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type groupesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type indicateursCreateInput = {
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
    evaluations?: evaluationsCreateNestedManyWithoutIndicateursInput
    projets: projetsCreateNestedOneWithoutIndicateursInput
  }

  export type indicateursUncheckedCreateInput = {
    id?: number
    project_id: number
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
    evaluations?: evaluationsUncheckedCreateNestedManyWithoutIndicateursInput
  }

  export type indicateursUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: evaluationsUpdateManyWithoutIndicateursNestedInput
    projets?: projetsUpdateOneRequiredWithoutIndicateursNestedInput
  }

  export type indicateursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: evaluationsUncheckedUpdateManyWithoutIndicateursNestedInput
  }

  export type indicateursCreateManyInput = {
    id?: number
    project_id: number
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type indicateursUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type indicateursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupesUtilisateursCreateInput = {
    groupes: groupesCreateNestedOneWithoutGroupesUtilisateursInput
    utilisateurs: utilisateursCreateNestedOneWithoutGroupesUtilisateursInput
  }

  export type GroupesUtilisateursUncheckedCreateInput = {
    groupe_id: number
    utilisateur_id: number
  }

  export type GroupesUtilisateursUpdateInput = {
    groupes?: groupesUpdateOneRequiredWithoutGroupesUtilisateursNestedInput
    utilisateurs?: utilisateursUpdateOneRequiredWithoutGroupesUtilisateursNestedInput
  }

  export type GroupesUtilisateursUncheckedUpdateInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupesUtilisateursCreateManyInput = {
    groupe_id: number
    utilisateur_id: number
  }

  export type GroupesUtilisateursUpdateManyMutationInput = {

  }

  export type GroupesUtilisateursUncheckedUpdateManyInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type newsletterCreateInput = {
    title?: string | null
    body: string
    posted_by?: number
    created_date?: Date | string
    last_updated?: Date | string
    newsletter_statut?: string
  }

  export type newsletterUncheckedCreateInput = {
    id?: number
    title?: string | null
    body: string
    posted_by?: number
    created_date?: Date | string
    last_updated?: Date | string
    newsletter_statut?: string
  }

  export type newsletterUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    newsletter_statut?: StringFieldUpdateOperationsInput | string
  }

  export type newsletterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    newsletter_statut?: StringFieldUpdateOperationsInput | string
  }

  export type newsletterCreateManyInput = {
    id?: number
    title?: string | null
    body: string
    posted_by?: number
    created_date?: Date | string
    last_updated?: Date | string
    newsletter_statut?: string
  }

  export type newsletterUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    newsletter_statut?: StringFieldUpdateOperationsInput | string
  }

  export type newsletterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    posted_by?: IntFieldUpdateOperationsInput | number
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    newsletter_statut?: StringFieldUpdateOperationsInput | string
  }

  export type permissionsCreateInput = {
    name: string
    description?: string | null
    created_date?: Date | string
    last_updated?: Date | string
    role_permissions?: role_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string
    last_updated?: Date | string
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type permissionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type plans_actionCreateInput = {
    name: string
    description?: string | null
    objectif?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    axes?: axesCreateNestedManyWithoutPlans_actionInput
  }

  export type plans_actionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    objectif?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    axes?: axesUncheckedCreateNestedManyWithoutPlans_actionInput
  }

  export type plans_actionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    axes?: axesUpdateManyWithoutPlans_actionNestedInput
  }

  export type plans_actionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    axes?: axesUncheckedUpdateManyWithoutPlans_actionNestedInput
  }

  export type plans_actionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    objectif?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type plans_actionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type plans_actionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type priorityCreateInput = {
    name: string
    created_date?: Date | string
    last_updated?: Date | string
    projets?: projetsCreateNestedManyWithoutPriorityInput
  }

  export type priorityUncheckedCreateInput = {
    id?: number
    name: string
    created_date?: Date | string
    last_updated?: Date | string
    projets?: projetsUncheckedCreateNestedManyWithoutPriorityInput
  }

  export type priorityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUpdateManyWithoutPriorityNestedInput
  }

  export type priorityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUncheckedUpdateManyWithoutPriorityNestedInput
  }

  export type priorityCreateManyInput = {
    id?: number
    name: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type priorityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type priorityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_groupesCreateInput = {
    projets: projetsCreateNestedOneWithoutProjet_groupesInput
    groupes: groupesCreateNestedOneWithoutProjet_groupesInput
  }

  export type projet_groupesUncheckedCreateInput = {
    projet_id: number
    groupe_id: number
  }

  export type projet_groupesUpdateInput = {
    projets?: projetsUpdateOneRequiredWithoutProjet_groupesNestedInput
    groupes?: groupesUpdateOneRequiredWithoutProjet_groupesNestedInput
  }

  export type projet_groupesUncheckedUpdateInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_groupesCreateManyInput = {
    projet_id: number
    groupe_id: number
  }

  export type projet_groupesUpdateManyMutationInput = {

  }

  export type projet_groupesUncheckedUpdateManyInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_utilisateursCreateInput = {
    projets: projetsCreateNestedOneWithoutProjet_utilisateursInput
    utilisateurs: utilisateursCreateNestedOneWithoutProjet_utilisateursInput
  }

  export type projet_utilisateursUncheckedCreateInput = {
    projet_id: number
    utilisateur_id: number
  }

  export type projet_utilisateursUpdateInput = {
    projets?: projetsUpdateOneRequiredWithoutProjet_utilisateursNestedInput
    utilisateurs?: utilisateursUpdateOneRequiredWithoutProjet_utilisateursNestedInput
  }

  export type projet_utilisateursUncheckedUpdateInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_utilisateursCreateManyInput = {
    projet_id: number
    utilisateur_id: number
  }

  export type projet_utilisateursUpdateManyMutationInput = {

  }

  export type projet_utilisateursUncheckedUpdateManyInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetsCreateInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetsCreateManyInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
  }

  export type projetsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type projetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ressourcesCreateInput = {
    name: string
    description?: string | null
    quantity?: number | null
    unit?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    projets: projetsCreateNestedOneWithoutRessourcesInput
  }

  export type ressourcesUncheckedCreateInput = {
    id?: number
    project_id: number
    name: string
    description?: string | null
    quantity?: number | null
    unit?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    projets?: projetsUpdateOneRequiredWithoutRessourcesNestedInput
  }

  export type ressourcesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesCreateManyInput = {
    id?: number
    project_id: number
    name: string
    description?: string | null
    quantity?: number | null
    unit?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type role_permissionsCreateInput = {
    roles: rolesCreateNestedOneWithoutRole_permissionsInput
    permissions: permissionsCreateNestedOneWithoutRole_permissionsInput
  }

  export type role_permissionsUncheckedCreateInput = {
    role_id: number
    permission_id: number
  }

  export type role_permissionsUpdateInput = {
    roles?: rolesUpdateOneRequiredWithoutRole_permissionsNestedInput
    permissions?: permissionsUpdateOneRequiredWithoutRole_permissionsNestedInput
  }

  export type role_permissionsUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type role_permissionsCreateManyInput = {
    role_id: number
    permission_id: number
  }

  export type role_permissionsUpdateManyMutationInput = {

  }

  export type role_permissionsUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type rolesCreateInput = {
    nom: string
    created_date?: Date | string
    last_updated?: Date | string
    comptes?: comptesCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    nom: string
    created_date?: Date | string
    last_updated?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    nom: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type rolesUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsCreateInput = {
    suggestion_content: string
    submitted_at?: Date | string
    comptes: comptesCreateNestedOneWithoutSuggestionsInput
    projets: projetsCreateNestedOneWithoutSuggestionsInput
  }

  export type suggestionsUncheckedCreateInput = {
    id?: number
    compte_id: number
    project_id: number
    suggestion_content: string
    submitted_at?: Date | string
  }

  export type suggestionsUpdateInput = {
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateOneRequiredWithoutSuggestionsNestedInput
    projets?: projetsUpdateOneRequiredWithoutSuggestionsNestedInput
  }

  export type suggestionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsCreateManyInput = {
    id?: number
    compte_id: number
    project_id: number
    suggestion_content: string
    submitted_at?: Date | string
  }

  export type suggestionsUpdateManyMutationInput = {
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tache_assignations_groupesCreateInput = {
    taches: tachesCreateNestedOneWithoutTache_assignations_groupesInput
    groupes: groupesCreateNestedOneWithoutTache_assignations_groupesInput
  }

  export type tache_assignations_groupesUncheckedCreateInput = {
    tache_id: number
    groupe_id: number
  }

  export type tache_assignations_groupesUpdateInput = {
    taches?: tachesUpdateOneRequiredWithoutTache_assignations_groupesNestedInput
    groupes?: groupesUpdateOneRequiredWithoutTache_assignations_groupesNestedInput
  }

  export type tache_assignations_groupesUncheckedUpdateInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_groupesCreateManyInput = {
    tache_id: number
    groupe_id: number
  }

  export type tache_assignations_groupesUpdateManyMutationInput = {

  }

  export type tache_assignations_groupesUncheckedUpdateManyInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_utilisateursCreateInput = {
    taches: tachesCreateNestedOneWithoutTache_assignations_utilisateursInput
    utilisateurs: utilisateursCreateNestedOneWithoutTache_assignations_utilisateursInput
  }

  export type tache_assignations_utilisateursUncheckedCreateInput = {
    tache_id: number
    utilisateur_id: number
  }

  export type tache_assignations_utilisateursUpdateInput = {
    taches?: tachesUpdateOneRequiredWithoutTache_assignations_utilisateursNestedInput
    utilisateurs?: utilisateursUpdateOneRequiredWithoutTache_assignations_utilisateursNestedInput
  }

  export type tache_assignations_utilisateursUncheckedUpdateInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_utilisateursCreateManyInput = {
    tache_id: number
    utilisateur_id: number
  }

  export type tache_assignations_utilisateursUpdateManyMutationInput = {

  }

  export type tache_assignations_utilisateursUncheckedUpdateManyInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type tachesCreateInput = {
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutTachesInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutTachesInput
    utilisateur?: utilisateursCreateNestedOneWithoutTachesInput
    projet?: projetsCreateNestedOneWithoutTachesInput
  }

  export type tachesUncheckedCreateInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    projet_id?: number | null
    utilisateur_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutTachesInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutTachesInput
  }

  export type tachesUpdateInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutTachesNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutTachesNestedInput
    utilisateur?: utilisateursUpdateOneWithoutTachesNestedInput
    projet?: projetsUpdateOneWithoutTachesNestedInput
  }

  export type tachesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateur_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutTachesNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutTachesNestedInput
  }

  export type tachesCreateManyInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    projet_id?: number | null
    utilisateur_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
  }

  export type tachesUpdateManyMutationInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tachesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateur_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type utilisateursCreateInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type utilisateursCreateManyInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
  }

  export type utilisateursUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type utilisateursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesCreateInput = {
    vote_value?: number | null
    voted_at?: Date | string
    comptes: comptesCreateNestedOneWithoutVotesInput
  }

  export type votesUncheckedCreateInput = {
    id?: number
    compte_id: number
    vote_value?: number | null
    voted_at?: Date | string
  }

  export type votesUpdateInput = {
    vote_value?: NullableIntFieldUpdateOperationsInput | number | null
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateOneRequiredWithoutVotesNestedInput
  }

  export type votesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    vote_value?: NullableIntFieldUpdateOperationsInput | number | null
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesCreateManyInput = {
    id?: number
    compte_id: number
    vote_value?: number | null
    voted_at?: Date | string
  }

  export type votesUpdateManyMutationInput = {
    vote_value?: NullableIntFieldUpdateOperationsInput | number | null
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    vote_value?: NullableIntFieldUpdateOperationsInput | number | null
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    user?: utilisateursCreateNestedOneWithoutNotificationInput
    groupe?: groupesCreateNestedOneWithoutNotificationInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: number
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    userId?: number | null
    groupeId?: number | null
  }

  export type notificationsUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: utilisateursUpdateOneWithoutNotificationNestedInput
    groupe?: groupesUpdateOneWithoutNotificationNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    groupeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notificationsCreateManyInput = {
    id?: number
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    userId?: number | null
    groupeId?: number | null
  }

  export type notificationsUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    groupeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ActualitesRelationFilter = {
    is?: actualitesWhereInput
    isNot?: actualitesWhereInput
  }

  export type actualite_imagesCountOrderByAggregateInput = {
    id?: SortOrder
    actualite_id?: SortOrder
    image_url?: SortOrder
  }

  export type actualite_imagesAvgOrderByAggregateInput = {
    id?: SortOrder
    actualite_id?: SortOrder
  }

  export type actualite_imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    actualite_id?: SortOrder
    image_url?: SortOrder
  }

  export type actualite_imagesMinOrderByAggregateInput = {
    id?: SortOrder
    actualite_id?: SortOrder
    image_url?: SortOrder
  }

  export type actualite_imagesSumOrderByAggregateInput = {
    id?: SortOrder
    actualite_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Actualite_imagesListRelationFilter = {
    every?: actualite_imagesWhereInput
    some?: actualite_imagesWhereInput
    none?: actualite_imagesWhereInput
  }

  export type actualite_imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type actualitesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type actualitesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type actualitesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type actualitesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type actualitesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Plans_actionRelationFilter = {
    is?: plans_actionWhereInput
    isNot?: plans_actionWhereInput
  }

  export type ProjetsListRelationFilter = {
    every?: projetsWhereInput
    some?: projetsWhereInput
    none?: projetsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type projetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type axesCountOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    objectif?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type axesAvgOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
  }

  export type axesMaxOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    objectif?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type axesMinOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    objectif?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type axesSumOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UtilisateursListRelationFilter = {
    every?: utilisateursWhereInput
    some?: utilisateursWhereInput
    none?: utilisateursWhereInput
  }

  export type utilisateursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type category_userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type category_userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type category_userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type category_userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type category_userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjetsRelationFilter = {
    is?: projetsWhereInput
    isNot?: projetsWhereInput
  }

  export type ComptesRelationFilter = {
    is?: comptesWhereInput
    isNot?: comptesWhereInput
  }

  export type commentairesCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    compte_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type commentairesAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    compte_id?: SortOrder
  }

  export type commentairesMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    compte_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type commentairesMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    compte_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type commentairesSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    compte_id?: SortOrder
  }

  export type Enumcomptes_validityFilter<$PrismaModel = never> = {
    equals?: $Enums.comptes_validity | Enumcomptes_validityFieldRefInput<$PrismaModel>
    in?: $Enums.comptes_validity[]
    notIn?: $Enums.comptes_validity[]
    not?: NestedEnumcomptes_validityFilter<$PrismaModel> | $Enums.comptes_validity
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CommentairesListRelationFilter = {
    every?: commentairesWhereInput
    some?: commentairesWhereInput
    none?: commentairesWhereInput
  }

  export type UtilisateursNullableRelationFilter = {
    is?: utilisateursWhereInput | null
    isNot?: utilisateursWhereInput | null
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type SuggestionsListRelationFilter = {
    every?: suggestionsWhereInput
    some?: suggestionsWhereInput
    none?: suggestionsWhereInput
  }

  export type VotesListRelationFilter = {
    every?: votesWhereInput
    some?: votesWhereInput
    none?: votesWhereInput
  }

  export type commentairesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type suggestionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type votesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comptesCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    validity?: SortOrder
    user_id?: SortOrder
  }

  export type comptesAvgOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    user_id?: SortOrder
  }

  export type comptesMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    validity?: SortOrder
    user_id?: SortOrder
  }

  export type comptesMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    validity?: SortOrder
    user_id?: SortOrder
  }

  export type comptesSumOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    user_id?: SortOrder
  }

  export type Enumcomptes_validityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.comptes_validity | Enumcomptes_validityFieldRefInput<$PrismaModel>
    in?: $Enums.comptes_validity[]
    notIn?: $Enums.comptes_validity[]
    not?: NestedEnumcomptes_validityWithAggregatesFilter<$PrismaModel> | $Enums.comptes_validity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcomptes_validityFilter<$PrismaModel>
    _max?: NestedEnumcomptes_validityFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type documentsCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    file_path?: SortOrder
    uploaded_at?: SortOrder
  }

  export type documentsAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
  }

  export type documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    file_path?: SortOrder
    uploaded_at?: SortOrder
  }

  export type documentsMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    file_path?: SortOrder
    uploaded_at?: SortOrder
  }

  export type documentsSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IndicateursRelationFilter = {
    is?: indicateursWhereInput
    isNot?: indicateursWhereInput
  }

  export type evaluationsCountOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    evaluation_date?: SortOrder
    value?: SortOrder
    comment?: SortOrder
  }

  export type evaluationsAvgOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    value?: SortOrder
  }

  export type evaluationsMaxOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    evaluation_date?: SortOrder
    value?: SortOrder
    comment?: SortOrder
  }

  export type evaluationsMinOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    evaluation_date?: SortOrder
    value?: SortOrder
    comment?: SortOrder
  }

  export type evaluationsSumOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    value?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Projet_groupesListRelationFilter = {
    every?: projet_groupesWhereInput
    some?: projet_groupesWhereInput
    none?: projet_groupesWhereInput
  }

  export type Tache_assignations_groupesListRelationFilter = {
    every?: tache_assignations_groupesWhereInput
    some?: tache_assignations_groupesWhereInput
    none?: tache_assignations_groupesWhereInput
  }

  export type GroupesUtilisateursListRelationFilter = {
    every?: GroupesUtilisateursWhereInput
    some?: GroupesUtilisateursWhereInput
    none?: GroupesUtilisateursWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type projet_groupesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tache_assignations_groupesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupesUtilisateursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groupesCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type groupesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type groupesMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type groupesMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type groupesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EvaluationsListRelationFilter = {
    every?: evaluationsWhereInput
    some?: evaluationsWhereInput
    none?: evaluationsWhereInput
  }

  export type evaluationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type indicateursCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    baseline_value?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type indicateursAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    baseline_value?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type indicateursMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    baseline_value?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type indicateursMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    baseline_value?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type indicateursSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    baseline_value?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type GroupesRelationFilter = {
    is?: groupesWhereInput
    isNot?: groupesWhereInput
  }

  export type UtilisateursRelationFilter = {
    is?: utilisateursWhereInput
    isNot?: utilisateursWhereInput
  }

  export type GroupesUtilisateursGroupe_idUtilisateur_idCompoundUniqueInput = {
    groupe_id: number
    utilisateur_id: number
  }

  export type GroupesUtilisateursCountOrderByAggregateInput = {
    groupe_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type GroupesUtilisateursAvgOrderByAggregateInput = {
    groupe_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type GroupesUtilisateursMaxOrderByAggregateInput = {
    groupe_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type GroupesUtilisateursMinOrderByAggregateInput = {
    groupe_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type GroupesUtilisateursSumOrderByAggregateInput = {
    groupe_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type newsletterCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    posted_by?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    newsletter_statut?: SortOrder
  }

  export type newsletterAvgOrderByAggregateInput = {
    id?: SortOrder
    posted_by?: SortOrder
  }

  export type newsletterMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    posted_by?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    newsletter_statut?: SortOrder
  }

  export type newsletterMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    posted_by?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    newsletter_statut?: SortOrder
  }

  export type newsletterSumOrderByAggregateInput = {
    id?: SortOrder
    posted_by?: SortOrder
  }

  export type Role_permissionsListRelationFilter = {
    every?: role_permissionsWhereInput
    some?: role_permissionsWhereInput
    none?: role_permissionsWhereInput
  }

  export type role_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AxesListRelationFilter = {
    every?: axesWhereInput
    some?: axesWhereInput
    none?: axesWhereInput
  }

  export type axesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plans_actionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objectif?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type plans_actionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plans_actionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objectif?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type plans_actionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objectif?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type plans_actionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type priorityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type priorityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type priorityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type priorityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type prioritySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type projet_groupesProjet_idGroupe_idCompoundUniqueInput = {
    projet_id: number
    groupe_id: number
  }

  export type projet_groupesCountOrderByAggregateInput = {
    projet_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type projet_groupesAvgOrderByAggregateInput = {
    projet_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type projet_groupesMaxOrderByAggregateInput = {
    projet_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type projet_groupesMinOrderByAggregateInput = {
    projet_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type projet_groupesSumOrderByAggregateInput = {
    projet_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type projet_utilisateursProjet_idUtilisateur_idCompoundUniqueInput = {
    projet_id: number
    utilisateur_id: number
  }

  export type projet_utilisateursCountOrderByAggregateInput = {
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type projet_utilisateursAvgOrderByAggregateInput = {
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type projet_utilisateursMaxOrderByAggregateInput = {
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type projet_utilisateursMinOrderByAggregateInput = {
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type projet_utilisateursSumOrderByAggregateInput = {
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type DocumentsListRelationFilter = {
    every?: documentsWhereInput
    some?: documentsWhereInput
    none?: documentsWhereInput
  }

  export type IndicateursListRelationFilter = {
    every?: indicateursWhereInput
    some?: indicateursWhereInput
    none?: indicateursWhereInput
  }

  export type Projet_utilisateursListRelationFilter = {
    every?: projet_utilisateursWhereInput
    some?: projet_utilisateursWhereInput
    none?: projet_utilisateursWhereInput
  }

  export type AxesRelationFilter = {
    is?: axesWhereInput
    isNot?: axesWhereInput
  }

  export type PriorityNullableRelationFilter = {
    is?: priorityWhereInput | null
    isNot?: priorityWhereInput | null
  }

  export type RessourcesListRelationFilter = {
    every?: ressourcesWhereInput
    some?: ressourcesWhereInput
    none?: ressourcesWhereInput
  }

  export type TachesListRelationFilter = {
    every?: tachesWhereInput
    some?: tachesWhereInput
    none?: tachesWhereInput
  }

  export type documentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type indicateursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projet_utilisateursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ressourcesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tachesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projetsCountOrderByAggregateInput = {
    id?: SortOrder
    axe_id?: SortOrder
    priority_id?: SortOrder
    manager?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objectif?: SortOrder
    statut?: SortOrder
    budget?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
  }

  export type projetsAvgOrderByAggregateInput = {
    id?: SortOrder
    axe_id?: SortOrder
    priority_id?: SortOrder
    manager?: SortOrder
    budget?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
  }

  export type projetsMaxOrderByAggregateInput = {
    id?: SortOrder
    axe_id?: SortOrder
    priority_id?: SortOrder
    manager?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objectif?: SortOrder
    statut?: SortOrder
    budget?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
  }

  export type projetsMinOrderByAggregateInput = {
    id?: SortOrder
    axe_id?: SortOrder
    priority_id?: SortOrder
    manager?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objectif?: SortOrder
    statut?: SortOrder
    budget?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
  }

  export type projetsSumOrderByAggregateInput = {
    id?: SortOrder
    axe_id?: SortOrder
    priority_id?: SortOrder
    manager?: SortOrder
    budget?: SortOrder
    target_value?: SortOrder
    current_value?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    cost?: SortOrder
  }

  export type ressourcesAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
  }

  export type ressourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    cost?: SortOrder
  }

  export type ressourcesMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    cost?: SortOrder
  }

  export type ressourcesSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type PermissionsRelationFilter = {
    is?: permissionsWhereInput
    isNot?: permissionsWhereInput
  }

  export type role_permissionsRole_idPermission_idCompoundUniqueInput = {
    role_id: number
    permission_id: number
  }

  export type role_permissionsCountOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type role_permissionsAvgOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type role_permissionsMaxOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type role_permissionsMinOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type role_permissionsSumOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type ComptesListRelationFilter = {
    every?: comptesWhereInput
    some?: comptesWhereInput
    none?: comptesWhereInput
  }

  export type comptesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    created_date?: SortOrder
    last_updated?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type suggestionsCountOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    project_id?: SortOrder
    suggestion_content?: SortOrder
    submitted_at?: SortOrder
  }

  export type suggestionsAvgOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    project_id?: SortOrder
  }

  export type suggestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    project_id?: SortOrder
    suggestion_content?: SortOrder
    submitted_at?: SortOrder
  }

  export type suggestionsMinOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    project_id?: SortOrder
    suggestion_content?: SortOrder
    submitted_at?: SortOrder
  }

  export type suggestionsSumOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    project_id?: SortOrder
  }

  export type TachesRelationFilter = {
    is?: tachesWhereInput
    isNot?: tachesWhereInput
  }

  export type tache_assignations_groupesTache_idGroupe_idCompoundUniqueInput = {
    tache_id: number
    groupe_id: number
  }

  export type tache_assignations_groupesCountOrderByAggregateInput = {
    tache_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type tache_assignations_groupesAvgOrderByAggregateInput = {
    tache_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type tache_assignations_groupesMaxOrderByAggregateInput = {
    tache_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type tache_assignations_groupesMinOrderByAggregateInput = {
    tache_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type tache_assignations_groupesSumOrderByAggregateInput = {
    tache_id?: SortOrder
    groupe_id?: SortOrder
  }

  export type tache_assignations_utilisateursTache_idUtilisateur_idCompoundUniqueInput = {
    tache_id: number
    utilisateur_id: number
  }

  export type tache_assignations_utilisateursCountOrderByAggregateInput = {
    tache_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type tache_assignations_utilisateursAvgOrderByAggregateInput = {
    tache_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type tache_assignations_utilisateursMaxOrderByAggregateInput = {
    tache_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type tache_assignations_utilisateursMinOrderByAggregateInput = {
    tache_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type tache_assignations_utilisateursSumOrderByAggregateInput = {
    tache_id?: SortOrder
    utilisateur_id?: SortOrder
  }

  export type Tache_assignations_utilisateursListRelationFilter = {
    every?: tache_assignations_utilisateursWhereInput
    some?: tache_assignations_utilisateursWhereInput
    none?: tache_assignations_utilisateursWhereInput
  }

  export type ProjetsNullableRelationFilter = {
    is?: projetsWhereInput | null
    isNot?: projetsWhereInput | null
  }

  export type tache_assignations_utilisateursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tachesCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
    statut?: SortOrder
    priorite?: SortOrder
    dateCreation?: SortOrder
    dateMiseAJour?: SortOrder
    delaiEstime?: SortOrder
    delaiReel?: SortOrder
    commentaires?: SortOrder
    tacheParentId?: SortOrder
  }

  export type tachesAvgOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
    tacheParentId?: SortOrder
  }

  export type tachesMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
    statut?: SortOrder
    priorite?: SortOrder
    dateCreation?: SortOrder
    dateMiseAJour?: SortOrder
    delaiEstime?: SortOrder
    delaiReel?: SortOrder
    commentaires?: SortOrder
    tacheParentId?: SortOrder
  }

  export type tachesMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
    statut?: SortOrder
    priorite?: SortOrder
    dateCreation?: SortOrder
    dateMiseAJour?: SortOrder
    delaiEstime?: SortOrder
    delaiReel?: SortOrder
    commentaires?: SortOrder
    tacheParentId?: SortOrder
  }

  export type tachesSumOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    utilisateur_id?: SortOrder
    tacheParentId?: SortOrder
  }

  export type Category_userNullableRelationFilter = {
    is?: category_userWhereInput | null
    isNot?: category_userWhereInput | null
  }

  export type utilisateursCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
  }

  export type utilisateursAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type utilisateursMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
  }

  export type utilisateursMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
  }

  export type utilisateursSumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type votesCountOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    vote_value?: SortOrder
    voted_at?: SortOrder
  }

  export type votesAvgOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    vote_value?: SortOrder
  }

  export type votesMaxOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    vote_value?: SortOrder
    voted_at?: SortOrder
  }

  export type votesMinOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    vote_value?: SortOrder
    voted_at?: SortOrder
  }

  export type votesSumOrderByAggregateInput = {
    id?: SortOrder
    compte_id?: SortOrder
    vote_value?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type GroupesNullableRelationFilter = {
    is?: groupesWhereInput | null
    isNot?: groupesWhereInput | null
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    groupeId?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupeId?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    groupeId?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    groupeId?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupeId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type actualitesCreateNestedOneWithoutActualite_imagesInput = {
    create?: XOR<actualitesCreateWithoutActualite_imagesInput, actualitesUncheckedCreateWithoutActualite_imagesInput>
    connectOrCreate?: actualitesCreateOrConnectWithoutActualite_imagesInput
    connect?: actualitesWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type actualitesUpdateOneRequiredWithoutActualite_imagesNestedInput = {
    create?: XOR<actualitesCreateWithoutActualite_imagesInput, actualitesUncheckedCreateWithoutActualite_imagesInput>
    connectOrCreate?: actualitesCreateOrConnectWithoutActualite_imagesInput
    upsert?: actualitesUpsertWithoutActualite_imagesInput
    connect?: actualitesWhereUniqueInput
    update?: XOR<XOR<actualitesUpdateToOneWithWhereWithoutActualite_imagesInput, actualitesUpdateWithoutActualite_imagesInput>, actualitesUncheckedUpdateWithoutActualite_imagesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type actualite_imagesCreateNestedManyWithoutActualitesInput = {
    create?: XOR<actualite_imagesCreateWithoutActualitesInput, actualite_imagesUncheckedCreateWithoutActualitesInput> | actualite_imagesCreateWithoutActualitesInput[] | actualite_imagesUncheckedCreateWithoutActualitesInput[]
    connectOrCreate?: actualite_imagesCreateOrConnectWithoutActualitesInput | actualite_imagesCreateOrConnectWithoutActualitesInput[]
    createMany?: actualite_imagesCreateManyActualitesInputEnvelope
    connect?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
  }

  export type actualite_imagesUncheckedCreateNestedManyWithoutActualitesInput = {
    create?: XOR<actualite_imagesCreateWithoutActualitesInput, actualite_imagesUncheckedCreateWithoutActualitesInput> | actualite_imagesCreateWithoutActualitesInput[] | actualite_imagesUncheckedCreateWithoutActualitesInput[]
    connectOrCreate?: actualite_imagesCreateOrConnectWithoutActualitesInput | actualite_imagesCreateOrConnectWithoutActualitesInput[]
    createMany?: actualite_imagesCreateManyActualitesInputEnvelope
    connect?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type actualite_imagesUpdateManyWithoutActualitesNestedInput = {
    create?: XOR<actualite_imagesCreateWithoutActualitesInput, actualite_imagesUncheckedCreateWithoutActualitesInput> | actualite_imagesCreateWithoutActualitesInput[] | actualite_imagesUncheckedCreateWithoutActualitesInput[]
    connectOrCreate?: actualite_imagesCreateOrConnectWithoutActualitesInput | actualite_imagesCreateOrConnectWithoutActualitesInput[]
    upsert?: actualite_imagesUpsertWithWhereUniqueWithoutActualitesInput | actualite_imagesUpsertWithWhereUniqueWithoutActualitesInput[]
    createMany?: actualite_imagesCreateManyActualitesInputEnvelope
    set?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    disconnect?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    delete?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    connect?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    update?: actualite_imagesUpdateWithWhereUniqueWithoutActualitesInput | actualite_imagesUpdateWithWhereUniqueWithoutActualitesInput[]
    updateMany?: actualite_imagesUpdateManyWithWhereWithoutActualitesInput | actualite_imagesUpdateManyWithWhereWithoutActualitesInput[]
    deleteMany?: actualite_imagesScalarWhereInput | actualite_imagesScalarWhereInput[]
  }

  export type actualite_imagesUncheckedUpdateManyWithoutActualitesNestedInput = {
    create?: XOR<actualite_imagesCreateWithoutActualitesInput, actualite_imagesUncheckedCreateWithoutActualitesInput> | actualite_imagesCreateWithoutActualitesInput[] | actualite_imagesUncheckedCreateWithoutActualitesInput[]
    connectOrCreate?: actualite_imagesCreateOrConnectWithoutActualitesInput | actualite_imagesCreateOrConnectWithoutActualitesInput[]
    upsert?: actualite_imagesUpsertWithWhereUniqueWithoutActualitesInput | actualite_imagesUpsertWithWhereUniqueWithoutActualitesInput[]
    createMany?: actualite_imagesCreateManyActualitesInputEnvelope
    set?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    disconnect?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    delete?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    connect?: actualite_imagesWhereUniqueInput | actualite_imagesWhereUniqueInput[]
    update?: actualite_imagesUpdateWithWhereUniqueWithoutActualitesInput | actualite_imagesUpdateWithWhereUniqueWithoutActualitesInput[]
    updateMany?: actualite_imagesUpdateManyWithWhereWithoutActualitesInput | actualite_imagesUpdateManyWithWhereWithoutActualitesInput[]
    deleteMany?: actualite_imagesScalarWhereInput | actualite_imagesScalarWhereInput[]
  }

  export type plans_actionCreateNestedOneWithoutAxesInput = {
    create?: XOR<plans_actionCreateWithoutAxesInput, plans_actionUncheckedCreateWithoutAxesInput>
    connectOrCreate?: plans_actionCreateOrConnectWithoutAxesInput
    connect?: plans_actionWhereUniqueInput
  }

  export type projetsCreateNestedManyWithoutAxesInput = {
    create?: XOR<projetsCreateWithoutAxesInput, projetsUncheckedCreateWithoutAxesInput> | projetsCreateWithoutAxesInput[] | projetsUncheckedCreateWithoutAxesInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutAxesInput | projetsCreateOrConnectWithoutAxesInput[]
    createMany?: projetsCreateManyAxesInputEnvelope
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
  }

  export type projetsUncheckedCreateNestedManyWithoutAxesInput = {
    create?: XOR<projetsCreateWithoutAxesInput, projetsUncheckedCreateWithoutAxesInput> | projetsCreateWithoutAxesInput[] | projetsUncheckedCreateWithoutAxesInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutAxesInput | projetsCreateOrConnectWithoutAxesInput[]
    createMany?: projetsCreateManyAxesInputEnvelope
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type plans_actionUpdateOneRequiredWithoutAxesNestedInput = {
    create?: XOR<plans_actionCreateWithoutAxesInput, plans_actionUncheckedCreateWithoutAxesInput>
    connectOrCreate?: plans_actionCreateOrConnectWithoutAxesInput
    upsert?: plans_actionUpsertWithoutAxesInput
    connect?: plans_actionWhereUniqueInput
    update?: XOR<XOR<plans_actionUpdateToOneWithWhereWithoutAxesInput, plans_actionUpdateWithoutAxesInput>, plans_actionUncheckedUpdateWithoutAxesInput>
  }

  export type projetsUpdateManyWithoutAxesNestedInput = {
    create?: XOR<projetsCreateWithoutAxesInput, projetsUncheckedCreateWithoutAxesInput> | projetsCreateWithoutAxesInput[] | projetsUncheckedCreateWithoutAxesInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutAxesInput | projetsCreateOrConnectWithoutAxesInput[]
    upsert?: projetsUpsertWithWhereUniqueWithoutAxesInput | projetsUpsertWithWhereUniqueWithoutAxesInput[]
    createMany?: projetsCreateManyAxesInputEnvelope
    set?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    disconnect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    delete?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    update?: projetsUpdateWithWhereUniqueWithoutAxesInput | projetsUpdateWithWhereUniqueWithoutAxesInput[]
    updateMany?: projetsUpdateManyWithWhereWithoutAxesInput | projetsUpdateManyWithWhereWithoutAxesInput[]
    deleteMany?: projetsScalarWhereInput | projetsScalarWhereInput[]
  }

  export type projetsUncheckedUpdateManyWithoutAxesNestedInput = {
    create?: XOR<projetsCreateWithoutAxesInput, projetsUncheckedCreateWithoutAxesInput> | projetsCreateWithoutAxesInput[] | projetsUncheckedCreateWithoutAxesInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutAxesInput | projetsCreateOrConnectWithoutAxesInput[]
    upsert?: projetsUpsertWithWhereUniqueWithoutAxesInput | projetsUpsertWithWhereUniqueWithoutAxesInput[]
    createMany?: projetsCreateManyAxesInputEnvelope
    set?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    disconnect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    delete?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    update?: projetsUpdateWithWhereUniqueWithoutAxesInput | projetsUpdateWithWhereUniqueWithoutAxesInput[]
    updateMany?: projetsUpdateManyWithWhereWithoutAxesInput | projetsUpdateManyWithWhereWithoutAxesInput[]
    deleteMany?: projetsScalarWhereInput | projetsScalarWhereInput[]
  }

  export type utilisateursCreateNestedManyWithoutCategory_userInput = {
    create?: XOR<utilisateursCreateWithoutCategory_userInput, utilisateursUncheckedCreateWithoutCategory_userInput> | utilisateursCreateWithoutCategory_userInput[] | utilisateursUncheckedCreateWithoutCategory_userInput[]
    connectOrCreate?: utilisateursCreateOrConnectWithoutCategory_userInput | utilisateursCreateOrConnectWithoutCategory_userInput[]
    createMany?: utilisateursCreateManyCategory_userInputEnvelope
    connect?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
  }

  export type utilisateursUncheckedCreateNestedManyWithoutCategory_userInput = {
    create?: XOR<utilisateursCreateWithoutCategory_userInput, utilisateursUncheckedCreateWithoutCategory_userInput> | utilisateursCreateWithoutCategory_userInput[] | utilisateursUncheckedCreateWithoutCategory_userInput[]
    connectOrCreate?: utilisateursCreateOrConnectWithoutCategory_userInput | utilisateursCreateOrConnectWithoutCategory_userInput[]
    createMany?: utilisateursCreateManyCategory_userInputEnvelope
    connect?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
  }

  export type utilisateursUpdateManyWithoutCategory_userNestedInput = {
    create?: XOR<utilisateursCreateWithoutCategory_userInput, utilisateursUncheckedCreateWithoutCategory_userInput> | utilisateursCreateWithoutCategory_userInput[] | utilisateursUncheckedCreateWithoutCategory_userInput[]
    connectOrCreate?: utilisateursCreateOrConnectWithoutCategory_userInput | utilisateursCreateOrConnectWithoutCategory_userInput[]
    upsert?: utilisateursUpsertWithWhereUniqueWithoutCategory_userInput | utilisateursUpsertWithWhereUniqueWithoutCategory_userInput[]
    createMany?: utilisateursCreateManyCategory_userInputEnvelope
    set?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    disconnect?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    delete?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    connect?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    update?: utilisateursUpdateWithWhereUniqueWithoutCategory_userInput | utilisateursUpdateWithWhereUniqueWithoutCategory_userInput[]
    updateMany?: utilisateursUpdateManyWithWhereWithoutCategory_userInput | utilisateursUpdateManyWithWhereWithoutCategory_userInput[]
    deleteMany?: utilisateursScalarWhereInput | utilisateursScalarWhereInput[]
  }

  export type utilisateursUncheckedUpdateManyWithoutCategory_userNestedInput = {
    create?: XOR<utilisateursCreateWithoutCategory_userInput, utilisateursUncheckedCreateWithoutCategory_userInput> | utilisateursCreateWithoutCategory_userInput[] | utilisateursUncheckedCreateWithoutCategory_userInput[]
    connectOrCreate?: utilisateursCreateOrConnectWithoutCategory_userInput | utilisateursCreateOrConnectWithoutCategory_userInput[]
    upsert?: utilisateursUpsertWithWhereUniqueWithoutCategory_userInput | utilisateursUpsertWithWhereUniqueWithoutCategory_userInput[]
    createMany?: utilisateursCreateManyCategory_userInputEnvelope
    set?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    disconnect?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    delete?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    connect?: utilisateursWhereUniqueInput | utilisateursWhereUniqueInput[]
    update?: utilisateursUpdateWithWhereUniqueWithoutCategory_userInput | utilisateursUpdateWithWhereUniqueWithoutCategory_userInput[]
    updateMany?: utilisateursUpdateManyWithWhereWithoutCategory_userInput | utilisateursUpdateManyWithWhereWithoutCategory_userInput[]
    deleteMany?: utilisateursScalarWhereInput | utilisateursScalarWhereInput[]
  }

  export type projetsCreateNestedOneWithoutCommentairesInput = {
    create?: XOR<projetsCreateWithoutCommentairesInput, projetsUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutCommentairesInput
    connect?: projetsWhereUniqueInput
  }

  export type comptesCreateNestedOneWithoutCommentairesInput = {
    create?: XOR<comptesCreateWithoutCommentairesInput, comptesUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: comptesCreateOrConnectWithoutCommentairesInput
    connect?: comptesWhereUniqueInput
  }

  export type projetsUpdateOneRequiredWithoutCommentairesNestedInput = {
    create?: XOR<projetsCreateWithoutCommentairesInput, projetsUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutCommentairesInput
    upsert?: projetsUpsertWithoutCommentairesInput
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutCommentairesInput, projetsUpdateWithoutCommentairesInput>, projetsUncheckedUpdateWithoutCommentairesInput>
  }

  export type comptesUpdateOneRequiredWithoutCommentairesNestedInput = {
    create?: XOR<comptesCreateWithoutCommentairesInput, comptesUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: comptesCreateOrConnectWithoutCommentairesInput
    upsert?: comptesUpsertWithoutCommentairesInput
    connect?: comptesWhereUniqueInput
    update?: XOR<XOR<comptesUpdateToOneWithWhereWithoutCommentairesInput, comptesUpdateWithoutCommentairesInput>, comptesUncheckedUpdateWithoutCommentairesInput>
  }

  export type commentairesCreateNestedManyWithoutComptesInput = {
    create?: XOR<commentairesCreateWithoutComptesInput, commentairesUncheckedCreateWithoutComptesInput> | commentairesCreateWithoutComptesInput[] | commentairesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutComptesInput | commentairesCreateOrConnectWithoutComptesInput[]
    createMany?: commentairesCreateManyComptesInputEnvelope
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
  }

  export type utilisateursCreateNestedOneWithoutComptesInput = {
    create?: XOR<utilisateursCreateWithoutComptesInput, utilisateursUncheckedCreateWithoutComptesInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutComptesInput
    connect?: utilisateursWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutComptesInput = {
    create?: XOR<rolesCreateWithoutComptesInput, rolesUncheckedCreateWithoutComptesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutComptesInput
    connect?: rolesWhereUniqueInput
  }

  export type suggestionsCreateNestedManyWithoutComptesInput = {
    create?: XOR<suggestionsCreateWithoutComptesInput, suggestionsUncheckedCreateWithoutComptesInput> | suggestionsCreateWithoutComptesInput[] | suggestionsUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutComptesInput | suggestionsCreateOrConnectWithoutComptesInput[]
    createMany?: suggestionsCreateManyComptesInputEnvelope
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
  }

  export type votesCreateNestedManyWithoutComptesInput = {
    create?: XOR<votesCreateWithoutComptesInput, votesUncheckedCreateWithoutComptesInput> | votesCreateWithoutComptesInput[] | votesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: votesCreateOrConnectWithoutComptesInput | votesCreateOrConnectWithoutComptesInput[]
    createMany?: votesCreateManyComptesInputEnvelope
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
  }

  export type commentairesUncheckedCreateNestedManyWithoutComptesInput = {
    create?: XOR<commentairesCreateWithoutComptesInput, commentairesUncheckedCreateWithoutComptesInput> | commentairesCreateWithoutComptesInput[] | commentairesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutComptesInput | commentairesCreateOrConnectWithoutComptesInput[]
    createMany?: commentairesCreateManyComptesInputEnvelope
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
  }

  export type suggestionsUncheckedCreateNestedManyWithoutComptesInput = {
    create?: XOR<suggestionsCreateWithoutComptesInput, suggestionsUncheckedCreateWithoutComptesInput> | suggestionsCreateWithoutComptesInput[] | suggestionsUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutComptesInput | suggestionsCreateOrConnectWithoutComptesInput[]
    createMany?: suggestionsCreateManyComptesInputEnvelope
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
  }

  export type votesUncheckedCreateNestedManyWithoutComptesInput = {
    create?: XOR<votesCreateWithoutComptesInput, votesUncheckedCreateWithoutComptesInput> | votesCreateWithoutComptesInput[] | votesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: votesCreateOrConnectWithoutComptesInput | votesCreateOrConnectWithoutComptesInput[]
    createMany?: votesCreateManyComptesInputEnvelope
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
  }

  export type Enumcomptes_validityFieldUpdateOperationsInput = {
    set?: $Enums.comptes_validity
  }

  export type commentairesUpdateManyWithoutComptesNestedInput = {
    create?: XOR<commentairesCreateWithoutComptesInput, commentairesUncheckedCreateWithoutComptesInput> | commentairesCreateWithoutComptesInput[] | commentairesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutComptesInput | commentairesCreateOrConnectWithoutComptesInput[]
    upsert?: commentairesUpsertWithWhereUniqueWithoutComptesInput | commentairesUpsertWithWhereUniqueWithoutComptesInput[]
    createMany?: commentairesCreateManyComptesInputEnvelope
    set?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    disconnect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    delete?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    update?: commentairesUpdateWithWhereUniqueWithoutComptesInput | commentairesUpdateWithWhereUniqueWithoutComptesInput[]
    updateMany?: commentairesUpdateManyWithWhereWithoutComptesInput | commentairesUpdateManyWithWhereWithoutComptesInput[]
    deleteMany?: commentairesScalarWhereInput | commentairesScalarWhereInput[]
  }

  export type utilisateursUpdateOneWithoutComptesNestedInput = {
    create?: XOR<utilisateursCreateWithoutComptesInput, utilisateursUncheckedCreateWithoutComptesInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutComptesInput
    upsert?: utilisateursUpsertWithoutComptesInput
    disconnect?: utilisateursWhereInput | boolean
    delete?: utilisateursWhereInput | boolean
    connect?: utilisateursWhereUniqueInput
    update?: XOR<XOR<utilisateursUpdateToOneWithWhereWithoutComptesInput, utilisateursUpdateWithoutComptesInput>, utilisateursUncheckedUpdateWithoutComptesInput>
  }

  export type rolesUpdateOneRequiredWithoutComptesNestedInput = {
    create?: XOR<rolesCreateWithoutComptesInput, rolesUncheckedCreateWithoutComptesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutComptesInput
    upsert?: rolesUpsertWithoutComptesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutComptesInput, rolesUpdateWithoutComptesInput>, rolesUncheckedUpdateWithoutComptesInput>
  }

  export type suggestionsUpdateManyWithoutComptesNestedInput = {
    create?: XOR<suggestionsCreateWithoutComptesInput, suggestionsUncheckedCreateWithoutComptesInput> | suggestionsCreateWithoutComptesInput[] | suggestionsUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutComptesInput | suggestionsCreateOrConnectWithoutComptesInput[]
    upsert?: suggestionsUpsertWithWhereUniqueWithoutComptesInput | suggestionsUpsertWithWhereUniqueWithoutComptesInput[]
    createMany?: suggestionsCreateManyComptesInputEnvelope
    set?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    disconnect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    delete?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    update?: suggestionsUpdateWithWhereUniqueWithoutComptesInput | suggestionsUpdateWithWhereUniqueWithoutComptesInput[]
    updateMany?: suggestionsUpdateManyWithWhereWithoutComptesInput | suggestionsUpdateManyWithWhereWithoutComptesInput[]
    deleteMany?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
  }

  export type votesUpdateManyWithoutComptesNestedInput = {
    create?: XOR<votesCreateWithoutComptesInput, votesUncheckedCreateWithoutComptesInput> | votesCreateWithoutComptesInput[] | votesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: votesCreateOrConnectWithoutComptesInput | votesCreateOrConnectWithoutComptesInput[]
    upsert?: votesUpsertWithWhereUniqueWithoutComptesInput | votesUpsertWithWhereUniqueWithoutComptesInput[]
    createMany?: votesCreateManyComptesInputEnvelope
    set?: votesWhereUniqueInput | votesWhereUniqueInput[]
    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    update?: votesUpdateWithWhereUniqueWithoutComptesInput | votesUpdateWithWhereUniqueWithoutComptesInput[]
    updateMany?: votesUpdateManyWithWhereWithoutComptesInput | votesUpdateManyWithWhereWithoutComptesInput[]
    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type commentairesUncheckedUpdateManyWithoutComptesNestedInput = {
    create?: XOR<commentairesCreateWithoutComptesInput, commentairesUncheckedCreateWithoutComptesInput> | commentairesCreateWithoutComptesInput[] | commentairesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutComptesInput | commentairesCreateOrConnectWithoutComptesInput[]
    upsert?: commentairesUpsertWithWhereUniqueWithoutComptesInput | commentairesUpsertWithWhereUniqueWithoutComptesInput[]
    createMany?: commentairesCreateManyComptesInputEnvelope
    set?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    disconnect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    delete?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    update?: commentairesUpdateWithWhereUniqueWithoutComptesInput | commentairesUpdateWithWhereUniqueWithoutComptesInput[]
    updateMany?: commentairesUpdateManyWithWhereWithoutComptesInput | commentairesUpdateManyWithWhereWithoutComptesInput[]
    deleteMany?: commentairesScalarWhereInput | commentairesScalarWhereInput[]
  }

  export type suggestionsUncheckedUpdateManyWithoutComptesNestedInput = {
    create?: XOR<suggestionsCreateWithoutComptesInput, suggestionsUncheckedCreateWithoutComptesInput> | suggestionsCreateWithoutComptesInput[] | suggestionsUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutComptesInput | suggestionsCreateOrConnectWithoutComptesInput[]
    upsert?: suggestionsUpsertWithWhereUniqueWithoutComptesInput | suggestionsUpsertWithWhereUniqueWithoutComptesInput[]
    createMany?: suggestionsCreateManyComptesInputEnvelope
    set?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    disconnect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    delete?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    update?: suggestionsUpdateWithWhereUniqueWithoutComptesInput | suggestionsUpdateWithWhereUniqueWithoutComptesInput[]
    updateMany?: suggestionsUpdateManyWithWhereWithoutComptesInput | suggestionsUpdateManyWithWhereWithoutComptesInput[]
    deleteMany?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
  }

  export type votesUncheckedUpdateManyWithoutComptesNestedInput = {
    create?: XOR<votesCreateWithoutComptesInput, votesUncheckedCreateWithoutComptesInput> | votesCreateWithoutComptesInput[] | votesUncheckedCreateWithoutComptesInput[]
    connectOrCreate?: votesCreateOrConnectWithoutComptesInput | votesCreateOrConnectWithoutComptesInput[]
    upsert?: votesUpsertWithWhereUniqueWithoutComptesInput | votesUpsertWithWhereUniqueWithoutComptesInput[]
    createMany?: votesCreateManyComptesInputEnvelope
    set?: votesWhereUniqueInput | votesWhereUniqueInput[]
    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    update?: votesUpdateWithWhereUniqueWithoutComptesInput | votesUpdateWithWhereUniqueWithoutComptesInput[]
    updateMany?: votesUpdateManyWithWhereWithoutComptesInput | votesUpdateManyWithWhereWithoutComptesInput[]
    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]
  }

  export type projetsCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<projetsCreateWithoutDocumentsInput, projetsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: projetsCreateOrConnectWithoutDocumentsInput
    connect?: projetsWhereUniqueInput
  }

  export type projetsUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<projetsCreateWithoutDocumentsInput, projetsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: projetsCreateOrConnectWithoutDocumentsInput
    upsert?: projetsUpsertWithoutDocumentsInput
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutDocumentsInput, projetsUpdateWithoutDocumentsInput>, projetsUncheckedUpdateWithoutDocumentsInput>
  }

  export type indicateursCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<indicateursCreateWithoutEvaluationsInput, indicateursUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: indicateursCreateOrConnectWithoutEvaluationsInput
    connect?: indicateursWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type indicateursUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<indicateursCreateWithoutEvaluationsInput, indicateursUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: indicateursCreateOrConnectWithoutEvaluationsInput
    upsert?: indicateursUpsertWithoutEvaluationsInput
    connect?: indicateursWhereUniqueInput
    update?: XOR<XOR<indicateursUpdateToOneWithWhereWithoutEvaluationsInput, indicateursUpdateWithoutEvaluationsInput>, indicateursUncheckedUpdateWithoutEvaluationsInput>
  }

  export type projet_groupesCreateNestedManyWithoutGroupesInput = {
    create?: XOR<projet_groupesCreateWithoutGroupesInput, projet_groupesUncheckedCreateWithoutGroupesInput> | projet_groupesCreateWithoutGroupesInput[] | projet_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutGroupesInput | projet_groupesCreateOrConnectWithoutGroupesInput[]
    createMany?: projet_groupesCreateManyGroupesInputEnvelope
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
  }

  export type tache_assignations_groupesCreateNestedManyWithoutGroupesInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutGroupesInput, tache_assignations_groupesUncheckedCreateWithoutGroupesInput> | tache_assignations_groupesCreateWithoutGroupesInput[] | tache_assignations_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutGroupesInput | tache_assignations_groupesCreateOrConnectWithoutGroupesInput[]
    createMany?: tache_assignations_groupesCreateManyGroupesInputEnvelope
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
  }

  export type GroupesUtilisateursCreateNestedManyWithoutGroupesInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutGroupesInput, GroupesUtilisateursUncheckedCreateWithoutGroupesInput> | GroupesUtilisateursCreateWithoutGroupesInput[] | GroupesUtilisateursUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutGroupesInput | GroupesUtilisateursCreateOrConnectWithoutGroupesInput[]
    createMany?: GroupesUtilisateursCreateManyGroupesInputEnvelope
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutGroupeInput = {
    create?: XOR<notificationsCreateWithoutGroupeInput, notificationsUncheckedCreateWithoutGroupeInput> | notificationsCreateWithoutGroupeInput[] | notificationsUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutGroupeInput | notificationsCreateOrConnectWithoutGroupeInput[]
    createMany?: notificationsCreateManyGroupeInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type projet_groupesUncheckedCreateNestedManyWithoutGroupesInput = {
    create?: XOR<projet_groupesCreateWithoutGroupesInput, projet_groupesUncheckedCreateWithoutGroupesInput> | projet_groupesCreateWithoutGroupesInput[] | projet_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutGroupesInput | projet_groupesCreateOrConnectWithoutGroupesInput[]
    createMany?: projet_groupesCreateManyGroupesInputEnvelope
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
  }

  export type tache_assignations_groupesUncheckedCreateNestedManyWithoutGroupesInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutGroupesInput, tache_assignations_groupesUncheckedCreateWithoutGroupesInput> | tache_assignations_groupesCreateWithoutGroupesInput[] | tache_assignations_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutGroupesInput | tache_assignations_groupesCreateOrConnectWithoutGroupesInput[]
    createMany?: tache_assignations_groupesCreateManyGroupesInputEnvelope
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
  }

  export type GroupesUtilisateursUncheckedCreateNestedManyWithoutGroupesInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutGroupesInput, GroupesUtilisateursUncheckedCreateWithoutGroupesInput> | GroupesUtilisateursCreateWithoutGroupesInput[] | GroupesUtilisateursUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutGroupesInput | GroupesUtilisateursCreateOrConnectWithoutGroupesInput[]
    createMany?: GroupesUtilisateursCreateManyGroupesInputEnvelope
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutGroupeInput = {
    create?: XOR<notificationsCreateWithoutGroupeInput, notificationsUncheckedCreateWithoutGroupeInput> | notificationsCreateWithoutGroupeInput[] | notificationsUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutGroupeInput | notificationsCreateOrConnectWithoutGroupeInput[]
    createMany?: notificationsCreateManyGroupeInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type projet_groupesUpdateManyWithoutGroupesNestedInput = {
    create?: XOR<projet_groupesCreateWithoutGroupesInput, projet_groupesUncheckedCreateWithoutGroupesInput> | projet_groupesCreateWithoutGroupesInput[] | projet_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutGroupesInput | projet_groupesCreateOrConnectWithoutGroupesInput[]
    upsert?: projet_groupesUpsertWithWhereUniqueWithoutGroupesInput | projet_groupesUpsertWithWhereUniqueWithoutGroupesInput[]
    createMany?: projet_groupesCreateManyGroupesInputEnvelope
    set?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    disconnect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    delete?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    update?: projet_groupesUpdateWithWhereUniqueWithoutGroupesInput | projet_groupesUpdateWithWhereUniqueWithoutGroupesInput[]
    updateMany?: projet_groupesUpdateManyWithWhereWithoutGroupesInput | projet_groupesUpdateManyWithWhereWithoutGroupesInput[]
    deleteMany?: projet_groupesScalarWhereInput | projet_groupesScalarWhereInput[]
  }

  export type tache_assignations_groupesUpdateManyWithoutGroupesNestedInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutGroupesInput, tache_assignations_groupesUncheckedCreateWithoutGroupesInput> | tache_assignations_groupesCreateWithoutGroupesInput[] | tache_assignations_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutGroupesInput | tache_assignations_groupesCreateOrConnectWithoutGroupesInput[]
    upsert?: tache_assignations_groupesUpsertWithWhereUniqueWithoutGroupesInput | tache_assignations_groupesUpsertWithWhereUniqueWithoutGroupesInput[]
    createMany?: tache_assignations_groupesCreateManyGroupesInputEnvelope
    set?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    disconnect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    delete?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    update?: tache_assignations_groupesUpdateWithWhereUniqueWithoutGroupesInput | tache_assignations_groupesUpdateWithWhereUniqueWithoutGroupesInput[]
    updateMany?: tache_assignations_groupesUpdateManyWithWhereWithoutGroupesInput | tache_assignations_groupesUpdateManyWithWhereWithoutGroupesInput[]
    deleteMany?: tache_assignations_groupesScalarWhereInput | tache_assignations_groupesScalarWhereInput[]
  }

  export type GroupesUtilisateursUpdateManyWithoutGroupesNestedInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutGroupesInput, GroupesUtilisateursUncheckedCreateWithoutGroupesInput> | GroupesUtilisateursCreateWithoutGroupesInput[] | GroupesUtilisateursUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutGroupesInput | GroupesUtilisateursCreateOrConnectWithoutGroupesInput[]
    upsert?: GroupesUtilisateursUpsertWithWhereUniqueWithoutGroupesInput | GroupesUtilisateursUpsertWithWhereUniqueWithoutGroupesInput[]
    createMany?: GroupesUtilisateursCreateManyGroupesInputEnvelope
    set?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    disconnect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    delete?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    update?: GroupesUtilisateursUpdateWithWhereUniqueWithoutGroupesInput | GroupesUtilisateursUpdateWithWhereUniqueWithoutGroupesInput[]
    updateMany?: GroupesUtilisateursUpdateManyWithWhereWithoutGroupesInput | GroupesUtilisateursUpdateManyWithWhereWithoutGroupesInput[]
    deleteMany?: GroupesUtilisateursScalarWhereInput | GroupesUtilisateursScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutGroupeNestedInput = {
    create?: XOR<notificationsCreateWithoutGroupeInput, notificationsUncheckedCreateWithoutGroupeInput> | notificationsCreateWithoutGroupeInput[] | notificationsUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutGroupeInput | notificationsCreateOrConnectWithoutGroupeInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutGroupeInput | notificationsUpsertWithWhereUniqueWithoutGroupeInput[]
    createMany?: notificationsCreateManyGroupeInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutGroupeInput | notificationsUpdateWithWhereUniqueWithoutGroupeInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutGroupeInput | notificationsUpdateManyWithWhereWithoutGroupeInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type projet_groupesUncheckedUpdateManyWithoutGroupesNestedInput = {
    create?: XOR<projet_groupesCreateWithoutGroupesInput, projet_groupesUncheckedCreateWithoutGroupesInput> | projet_groupesCreateWithoutGroupesInput[] | projet_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutGroupesInput | projet_groupesCreateOrConnectWithoutGroupesInput[]
    upsert?: projet_groupesUpsertWithWhereUniqueWithoutGroupesInput | projet_groupesUpsertWithWhereUniqueWithoutGroupesInput[]
    createMany?: projet_groupesCreateManyGroupesInputEnvelope
    set?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    disconnect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    delete?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    update?: projet_groupesUpdateWithWhereUniqueWithoutGroupesInput | projet_groupesUpdateWithWhereUniqueWithoutGroupesInput[]
    updateMany?: projet_groupesUpdateManyWithWhereWithoutGroupesInput | projet_groupesUpdateManyWithWhereWithoutGroupesInput[]
    deleteMany?: projet_groupesScalarWhereInput | projet_groupesScalarWhereInput[]
  }

  export type tache_assignations_groupesUncheckedUpdateManyWithoutGroupesNestedInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutGroupesInput, tache_assignations_groupesUncheckedCreateWithoutGroupesInput> | tache_assignations_groupesCreateWithoutGroupesInput[] | tache_assignations_groupesUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutGroupesInput | tache_assignations_groupesCreateOrConnectWithoutGroupesInput[]
    upsert?: tache_assignations_groupesUpsertWithWhereUniqueWithoutGroupesInput | tache_assignations_groupesUpsertWithWhereUniqueWithoutGroupesInput[]
    createMany?: tache_assignations_groupesCreateManyGroupesInputEnvelope
    set?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    disconnect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    delete?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    update?: tache_assignations_groupesUpdateWithWhereUniqueWithoutGroupesInput | tache_assignations_groupesUpdateWithWhereUniqueWithoutGroupesInput[]
    updateMany?: tache_assignations_groupesUpdateManyWithWhereWithoutGroupesInput | tache_assignations_groupesUpdateManyWithWhereWithoutGroupesInput[]
    deleteMany?: tache_assignations_groupesScalarWhereInput | tache_assignations_groupesScalarWhereInput[]
  }

  export type GroupesUtilisateursUncheckedUpdateManyWithoutGroupesNestedInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutGroupesInput, GroupesUtilisateursUncheckedCreateWithoutGroupesInput> | GroupesUtilisateursCreateWithoutGroupesInput[] | GroupesUtilisateursUncheckedCreateWithoutGroupesInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutGroupesInput | GroupesUtilisateursCreateOrConnectWithoutGroupesInput[]
    upsert?: GroupesUtilisateursUpsertWithWhereUniqueWithoutGroupesInput | GroupesUtilisateursUpsertWithWhereUniqueWithoutGroupesInput[]
    createMany?: GroupesUtilisateursCreateManyGroupesInputEnvelope
    set?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    disconnect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    delete?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    update?: GroupesUtilisateursUpdateWithWhereUniqueWithoutGroupesInput | GroupesUtilisateursUpdateWithWhereUniqueWithoutGroupesInput[]
    updateMany?: GroupesUtilisateursUpdateManyWithWhereWithoutGroupesInput | GroupesUtilisateursUpdateManyWithWhereWithoutGroupesInput[]
    deleteMany?: GroupesUtilisateursScalarWhereInput | GroupesUtilisateursScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutGroupeNestedInput = {
    create?: XOR<notificationsCreateWithoutGroupeInput, notificationsUncheckedCreateWithoutGroupeInput> | notificationsCreateWithoutGroupeInput[] | notificationsUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutGroupeInput | notificationsCreateOrConnectWithoutGroupeInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutGroupeInput | notificationsUpsertWithWhereUniqueWithoutGroupeInput[]
    createMany?: notificationsCreateManyGroupeInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutGroupeInput | notificationsUpdateWithWhereUniqueWithoutGroupeInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutGroupeInput | notificationsUpdateManyWithWhereWithoutGroupeInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type evaluationsCreateNestedManyWithoutIndicateursInput = {
    create?: XOR<evaluationsCreateWithoutIndicateursInput, evaluationsUncheckedCreateWithoutIndicateursInput> | evaluationsCreateWithoutIndicateursInput[] | evaluationsUncheckedCreateWithoutIndicateursInput[]
    connectOrCreate?: evaluationsCreateOrConnectWithoutIndicateursInput | evaluationsCreateOrConnectWithoutIndicateursInput[]
    createMany?: evaluationsCreateManyIndicateursInputEnvelope
    connect?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
  }

  export type projetsCreateNestedOneWithoutIndicateursInput = {
    create?: XOR<projetsCreateWithoutIndicateursInput, projetsUncheckedCreateWithoutIndicateursInput>
    connectOrCreate?: projetsCreateOrConnectWithoutIndicateursInput
    connect?: projetsWhereUniqueInput
  }

  export type evaluationsUncheckedCreateNestedManyWithoutIndicateursInput = {
    create?: XOR<evaluationsCreateWithoutIndicateursInput, evaluationsUncheckedCreateWithoutIndicateursInput> | evaluationsCreateWithoutIndicateursInput[] | evaluationsUncheckedCreateWithoutIndicateursInput[]
    connectOrCreate?: evaluationsCreateOrConnectWithoutIndicateursInput | evaluationsCreateOrConnectWithoutIndicateursInput[]
    createMany?: evaluationsCreateManyIndicateursInputEnvelope
    connect?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
  }

  export type evaluationsUpdateManyWithoutIndicateursNestedInput = {
    create?: XOR<evaluationsCreateWithoutIndicateursInput, evaluationsUncheckedCreateWithoutIndicateursInput> | evaluationsCreateWithoutIndicateursInput[] | evaluationsUncheckedCreateWithoutIndicateursInput[]
    connectOrCreate?: evaluationsCreateOrConnectWithoutIndicateursInput | evaluationsCreateOrConnectWithoutIndicateursInput[]
    upsert?: evaluationsUpsertWithWhereUniqueWithoutIndicateursInput | evaluationsUpsertWithWhereUniqueWithoutIndicateursInput[]
    createMany?: evaluationsCreateManyIndicateursInputEnvelope
    set?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    disconnect?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    delete?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    connect?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    update?: evaluationsUpdateWithWhereUniqueWithoutIndicateursInput | evaluationsUpdateWithWhereUniqueWithoutIndicateursInput[]
    updateMany?: evaluationsUpdateManyWithWhereWithoutIndicateursInput | evaluationsUpdateManyWithWhereWithoutIndicateursInput[]
    deleteMany?: evaluationsScalarWhereInput | evaluationsScalarWhereInput[]
  }

  export type projetsUpdateOneRequiredWithoutIndicateursNestedInput = {
    create?: XOR<projetsCreateWithoutIndicateursInput, projetsUncheckedCreateWithoutIndicateursInput>
    connectOrCreate?: projetsCreateOrConnectWithoutIndicateursInput
    upsert?: projetsUpsertWithoutIndicateursInput
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutIndicateursInput, projetsUpdateWithoutIndicateursInput>, projetsUncheckedUpdateWithoutIndicateursInput>
  }

  export type evaluationsUncheckedUpdateManyWithoutIndicateursNestedInput = {
    create?: XOR<evaluationsCreateWithoutIndicateursInput, evaluationsUncheckedCreateWithoutIndicateursInput> | evaluationsCreateWithoutIndicateursInput[] | evaluationsUncheckedCreateWithoutIndicateursInput[]
    connectOrCreate?: evaluationsCreateOrConnectWithoutIndicateursInput | evaluationsCreateOrConnectWithoutIndicateursInput[]
    upsert?: evaluationsUpsertWithWhereUniqueWithoutIndicateursInput | evaluationsUpsertWithWhereUniqueWithoutIndicateursInput[]
    createMany?: evaluationsCreateManyIndicateursInputEnvelope
    set?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    disconnect?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    delete?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    connect?: evaluationsWhereUniqueInput | evaluationsWhereUniqueInput[]
    update?: evaluationsUpdateWithWhereUniqueWithoutIndicateursInput | evaluationsUpdateWithWhereUniqueWithoutIndicateursInput[]
    updateMany?: evaluationsUpdateManyWithWhereWithoutIndicateursInput | evaluationsUpdateManyWithWhereWithoutIndicateursInput[]
    deleteMany?: evaluationsScalarWhereInput | evaluationsScalarWhereInput[]
  }

  export type groupesCreateNestedOneWithoutGroupesUtilisateursInput = {
    create?: XOR<groupesCreateWithoutGroupesUtilisateursInput, groupesUncheckedCreateWithoutGroupesUtilisateursInput>
    connectOrCreate?: groupesCreateOrConnectWithoutGroupesUtilisateursInput
    connect?: groupesWhereUniqueInput
  }

  export type utilisateursCreateNestedOneWithoutGroupesUtilisateursInput = {
    create?: XOR<utilisateursCreateWithoutGroupesUtilisateursInput, utilisateursUncheckedCreateWithoutGroupesUtilisateursInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutGroupesUtilisateursInput
    connect?: utilisateursWhereUniqueInput
  }

  export type groupesUpdateOneRequiredWithoutGroupesUtilisateursNestedInput = {
    create?: XOR<groupesCreateWithoutGroupesUtilisateursInput, groupesUncheckedCreateWithoutGroupesUtilisateursInput>
    connectOrCreate?: groupesCreateOrConnectWithoutGroupesUtilisateursInput
    upsert?: groupesUpsertWithoutGroupesUtilisateursInput
    connect?: groupesWhereUniqueInput
    update?: XOR<XOR<groupesUpdateToOneWithWhereWithoutGroupesUtilisateursInput, groupesUpdateWithoutGroupesUtilisateursInput>, groupesUncheckedUpdateWithoutGroupesUtilisateursInput>
  }

  export type utilisateursUpdateOneRequiredWithoutGroupesUtilisateursNestedInput = {
    create?: XOR<utilisateursCreateWithoutGroupesUtilisateursInput, utilisateursUncheckedCreateWithoutGroupesUtilisateursInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutGroupesUtilisateursInput
    upsert?: utilisateursUpsertWithoutGroupesUtilisateursInput
    connect?: utilisateursWhereUniqueInput
    update?: XOR<XOR<utilisateursUpdateToOneWithWhereWithoutGroupesUtilisateursInput, utilisateursUpdateWithoutGroupesUtilisateursInput>, utilisateursUncheckedUpdateWithoutGroupesUtilisateursInput>
  }

  export type role_permissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type role_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type role_permissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type role_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type axesCreateNestedManyWithoutPlans_actionInput = {
    create?: XOR<axesCreateWithoutPlans_actionInput, axesUncheckedCreateWithoutPlans_actionInput> | axesCreateWithoutPlans_actionInput[] | axesUncheckedCreateWithoutPlans_actionInput[]
    connectOrCreate?: axesCreateOrConnectWithoutPlans_actionInput | axesCreateOrConnectWithoutPlans_actionInput[]
    createMany?: axesCreateManyPlans_actionInputEnvelope
    connect?: axesWhereUniqueInput | axesWhereUniqueInput[]
  }

  export type axesUncheckedCreateNestedManyWithoutPlans_actionInput = {
    create?: XOR<axesCreateWithoutPlans_actionInput, axesUncheckedCreateWithoutPlans_actionInput> | axesCreateWithoutPlans_actionInput[] | axesUncheckedCreateWithoutPlans_actionInput[]
    connectOrCreate?: axesCreateOrConnectWithoutPlans_actionInput | axesCreateOrConnectWithoutPlans_actionInput[]
    createMany?: axesCreateManyPlans_actionInputEnvelope
    connect?: axesWhereUniqueInput | axesWhereUniqueInput[]
  }

  export type axesUpdateManyWithoutPlans_actionNestedInput = {
    create?: XOR<axesCreateWithoutPlans_actionInput, axesUncheckedCreateWithoutPlans_actionInput> | axesCreateWithoutPlans_actionInput[] | axesUncheckedCreateWithoutPlans_actionInput[]
    connectOrCreate?: axesCreateOrConnectWithoutPlans_actionInput | axesCreateOrConnectWithoutPlans_actionInput[]
    upsert?: axesUpsertWithWhereUniqueWithoutPlans_actionInput | axesUpsertWithWhereUniqueWithoutPlans_actionInput[]
    createMany?: axesCreateManyPlans_actionInputEnvelope
    set?: axesWhereUniqueInput | axesWhereUniqueInput[]
    disconnect?: axesWhereUniqueInput | axesWhereUniqueInput[]
    delete?: axesWhereUniqueInput | axesWhereUniqueInput[]
    connect?: axesWhereUniqueInput | axesWhereUniqueInput[]
    update?: axesUpdateWithWhereUniqueWithoutPlans_actionInput | axesUpdateWithWhereUniqueWithoutPlans_actionInput[]
    updateMany?: axesUpdateManyWithWhereWithoutPlans_actionInput | axesUpdateManyWithWhereWithoutPlans_actionInput[]
    deleteMany?: axesScalarWhereInput | axesScalarWhereInput[]
  }

  export type axesUncheckedUpdateManyWithoutPlans_actionNestedInput = {
    create?: XOR<axesCreateWithoutPlans_actionInput, axesUncheckedCreateWithoutPlans_actionInput> | axesCreateWithoutPlans_actionInput[] | axesUncheckedCreateWithoutPlans_actionInput[]
    connectOrCreate?: axesCreateOrConnectWithoutPlans_actionInput | axesCreateOrConnectWithoutPlans_actionInput[]
    upsert?: axesUpsertWithWhereUniqueWithoutPlans_actionInput | axesUpsertWithWhereUniqueWithoutPlans_actionInput[]
    createMany?: axesCreateManyPlans_actionInputEnvelope
    set?: axesWhereUniqueInput | axesWhereUniqueInput[]
    disconnect?: axesWhereUniqueInput | axesWhereUniqueInput[]
    delete?: axesWhereUniqueInput | axesWhereUniqueInput[]
    connect?: axesWhereUniqueInput | axesWhereUniqueInput[]
    update?: axesUpdateWithWhereUniqueWithoutPlans_actionInput | axesUpdateWithWhereUniqueWithoutPlans_actionInput[]
    updateMany?: axesUpdateManyWithWhereWithoutPlans_actionInput | axesUpdateManyWithWhereWithoutPlans_actionInput[]
    deleteMany?: axesScalarWhereInput | axesScalarWhereInput[]
  }

  export type projetsCreateNestedManyWithoutPriorityInput = {
    create?: XOR<projetsCreateWithoutPriorityInput, projetsUncheckedCreateWithoutPriorityInput> | projetsCreateWithoutPriorityInput[] | projetsUncheckedCreateWithoutPriorityInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutPriorityInput | projetsCreateOrConnectWithoutPriorityInput[]
    createMany?: projetsCreateManyPriorityInputEnvelope
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
  }

  export type projetsUncheckedCreateNestedManyWithoutPriorityInput = {
    create?: XOR<projetsCreateWithoutPriorityInput, projetsUncheckedCreateWithoutPriorityInput> | projetsCreateWithoutPriorityInput[] | projetsUncheckedCreateWithoutPriorityInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutPriorityInput | projetsCreateOrConnectWithoutPriorityInput[]
    createMany?: projetsCreateManyPriorityInputEnvelope
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
  }

  export type projetsUpdateManyWithoutPriorityNestedInput = {
    create?: XOR<projetsCreateWithoutPriorityInput, projetsUncheckedCreateWithoutPriorityInput> | projetsCreateWithoutPriorityInput[] | projetsUncheckedCreateWithoutPriorityInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutPriorityInput | projetsCreateOrConnectWithoutPriorityInput[]
    upsert?: projetsUpsertWithWhereUniqueWithoutPriorityInput | projetsUpsertWithWhereUniqueWithoutPriorityInput[]
    createMany?: projetsCreateManyPriorityInputEnvelope
    set?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    disconnect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    delete?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    update?: projetsUpdateWithWhereUniqueWithoutPriorityInput | projetsUpdateWithWhereUniqueWithoutPriorityInput[]
    updateMany?: projetsUpdateManyWithWhereWithoutPriorityInput | projetsUpdateManyWithWhereWithoutPriorityInput[]
    deleteMany?: projetsScalarWhereInput | projetsScalarWhereInput[]
  }

  export type projetsUncheckedUpdateManyWithoutPriorityNestedInput = {
    create?: XOR<projetsCreateWithoutPriorityInput, projetsUncheckedCreateWithoutPriorityInput> | projetsCreateWithoutPriorityInput[] | projetsUncheckedCreateWithoutPriorityInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutPriorityInput | projetsCreateOrConnectWithoutPriorityInput[]
    upsert?: projetsUpsertWithWhereUniqueWithoutPriorityInput | projetsUpsertWithWhereUniqueWithoutPriorityInput[]
    createMany?: projetsCreateManyPriorityInputEnvelope
    set?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    disconnect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    delete?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    update?: projetsUpdateWithWhereUniqueWithoutPriorityInput | projetsUpdateWithWhereUniqueWithoutPriorityInput[]
    updateMany?: projetsUpdateManyWithWhereWithoutPriorityInput | projetsUpdateManyWithWhereWithoutPriorityInput[]
    deleteMany?: projetsScalarWhereInput | projetsScalarWhereInput[]
  }

  export type projetsCreateNestedOneWithoutProjet_groupesInput = {
    create?: XOR<projetsCreateWithoutProjet_groupesInput, projetsUncheckedCreateWithoutProjet_groupesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutProjet_groupesInput
    connect?: projetsWhereUniqueInput
  }

  export type groupesCreateNestedOneWithoutProjet_groupesInput = {
    create?: XOR<groupesCreateWithoutProjet_groupesInput, groupesUncheckedCreateWithoutProjet_groupesInput>
    connectOrCreate?: groupesCreateOrConnectWithoutProjet_groupesInput
    connect?: groupesWhereUniqueInput
  }

  export type projetsUpdateOneRequiredWithoutProjet_groupesNestedInput = {
    create?: XOR<projetsCreateWithoutProjet_groupesInput, projetsUncheckedCreateWithoutProjet_groupesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutProjet_groupesInput
    upsert?: projetsUpsertWithoutProjet_groupesInput
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutProjet_groupesInput, projetsUpdateWithoutProjet_groupesInput>, projetsUncheckedUpdateWithoutProjet_groupesInput>
  }

  export type groupesUpdateOneRequiredWithoutProjet_groupesNestedInput = {
    create?: XOR<groupesCreateWithoutProjet_groupesInput, groupesUncheckedCreateWithoutProjet_groupesInput>
    connectOrCreate?: groupesCreateOrConnectWithoutProjet_groupesInput
    upsert?: groupesUpsertWithoutProjet_groupesInput
    connect?: groupesWhereUniqueInput
    update?: XOR<XOR<groupesUpdateToOneWithWhereWithoutProjet_groupesInput, groupesUpdateWithoutProjet_groupesInput>, groupesUncheckedUpdateWithoutProjet_groupesInput>
  }

  export type projetsCreateNestedOneWithoutProjet_utilisateursInput = {
    create?: XOR<projetsCreateWithoutProjet_utilisateursInput, projetsUncheckedCreateWithoutProjet_utilisateursInput>
    connectOrCreate?: projetsCreateOrConnectWithoutProjet_utilisateursInput
    connect?: projetsWhereUniqueInput
  }

  export type utilisateursCreateNestedOneWithoutProjet_utilisateursInput = {
    create?: XOR<utilisateursCreateWithoutProjet_utilisateursInput, utilisateursUncheckedCreateWithoutProjet_utilisateursInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutProjet_utilisateursInput
    connect?: utilisateursWhereUniqueInput
  }

  export type projetsUpdateOneRequiredWithoutProjet_utilisateursNestedInput = {
    create?: XOR<projetsCreateWithoutProjet_utilisateursInput, projetsUncheckedCreateWithoutProjet_utilisateursInput>
    connectOrCreate?: projetsCreateOrConnectWithoutProjet_utilisateursInput
    upsert?: projetsUpsertWithoutProjet_utilisateursInput
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutProjet_utilisateursInput, projetsUpdateWithoutProjet_utilisateursInput>, projetsUncheckedUpdateWithoutProjet_utilisateursInput>
  }

  export type utilisateursUpdateOneRequiredWithoutProjet_utilisateursNestedInput = {
    create?: XOR<utilisateursCreateWithoutProjet_utilisateursInput, utilisateursUncheckedCreateWithoutProjet_utilisateursInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutProjet_utilisateursInput
    upsert?: utilisateursUpsertWithoutProjet_utilisateursInput
    connect?: utilisateursWhereUniqueInput
    update?: XOR<XOR<utilisateursUpdateToOneWithWhereWithoutProjet_utilisateursInput, utilisateursUpdateWithoutProjet_utilisateursInput>, utilisateursUncheckedUpdateWithoutProjet_utilisateursInput>
  }

  export type commentairesCreateNestedManyWithoutProjetsInput = {
    create?: XOR<commentairesCreateWithoutProjetsInput, commentairesUncheckedCreateWithoutProjetsInput> | commentairesCreateWithoutProjetsInput[] | commentairesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutProjetsInput | commentairesCreateOrConnectWithoutProjetsInput[]
    createMany?: commentairesCreateManyProjetsInputEnvelope
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
  }

  export type documentsCreateNestedManyWithoutProjetsInput = {
    create?: XOR<documentsCreateWithoutProjetsInput, documentsUncheckedCreateWithoutProjetsInput> | documentsCreateWithoutProjetsInput[] | documentsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjetsInput | documentsCreateOrConnectWithoutProjetsInput[]
    createMany?: documentsCreateManyProjetsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type indicateursCreateNestedManyWithoutProjetsInput = {
    create?: XOR<indicateursCreateWithoutProjetsInput, indicateursUncheckedCreateWithoutProjetsInput> | indicateursCreateWithoutProjetsInput[] | indicateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: indicateursCreateOrConnectWithoutProjetsInput | indicateursCreateOrConnectWithoutProjetsInput[]
    createMany?: indicateursCreateManyProjetsInputEnvelope
    connect?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
  }

  export type projet_groupesCreateNestedManyWithoutProjetsInput = {
    create?: XOR<projet_groupesCreateWithoutProjetsInput, projet_groupesUncheckedCreateWithoutProjetsInput> | projet_groupesCreateWithoutProjetsInput[] | projet_groupesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutProjetsInput | projet_groupesCreateOrConnectWithoutProjetsInput[]
    createMany?: projet_groupesCreateManyProjetsInputEnvelope
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
  }

  export type projet_utilisateursCreateNestedManyWithoutProjetsInput = {
    create?: XOR<projet_utilisateursCreateWithoutProjetsInput, projet_utilisateursUncheckedCreateWithoutProjetsInput> | projet_utilisateursCreateWithoutProjetsInput[] | projet_utilisateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutProjetsInput | projet_utilisateursCreateOrConnectWithoutProjetsInput[]
    createMany?: projet_utilisateursCreateManyProjetsInputEnvelope
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
  }

  export type utilisateursCreateNestedOneWithoutProjetsInput = {
    create?: XOR<utilisateursCreateWithoutProjetsInput, utilisateursUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutProjetsInput
    connect?: utilisateursWhereUniqueInput
  }

  export type axesCreateNestedOneWithoutProjetsInput = {
    create?: XOR<axesCreateWithoutProjetsInput, axesUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: axesCreateOrConnectWithoutProjetsInput
    connect?: axesWhereUniqueInput
  }

  export type priorityCreateNestedOneWithoutProjetsInput = {
    create?: XOR<priorityCreateWithoutProjetsInput, priorityUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: priorityCreateOrConnectWithoutProjetsInput
    connect?: priorityWhereUniqueInput
  }

  export type ressourcesCreateNestedManyWithoutProjetsInput = {
    create?: XOR<ressourcesCreateWithoutProjetsInput, ressourcesUncheckedCreateWithoutProjetsInput> | ressourcesCreateWithoutProjetsInput[] | ressourcesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: ressourcesCreateOrConnectWithoutProjetsInput | ressourcesCreateOrConnectWithoutProjetsInput[]
    createMany?: ressourcesCreateManyProjetsInputEnvelope
    connect?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
  }

  export type suggestionsCreateNestedManyWithoutProjetsInput = {
    create?: XOR<suggestionsCreateWithoutProjetsInput, suggestionsUncheckedCreateWithoutProjetsInput> | suggestionsCreateWithoutProjetsInput[] | suggestionsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutProjetsInput | suggestionsCreateOrConnectWithoutProjetsInput[]
    createMany?: suggestionsCreateManyProjetsInputEnvelope
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
  }

  export type tachesCreateNestedManyWithoutProjetInput = {
    create?: XOR<tachesCreateWithoutProjetInput, tachesUncheckedCreateWithoutProjetInput> | tachesCreateWithoutProjetInput[] | tachesUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutProjetInput | tachesCreateOrConnectWithoutProjetInput[]
    createMany?: tachesCreateManyProjetInputEnvelope
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
  }

  export type commentairesUncheckedCreateNestedManyWithoutProjetsInput = {
    create?: XOR<commentairesCreateWithoutProjetsInput, commentairesUncheckedCreateWithoutProjetsInput> | commentairesCreateWithoutProjetsInput[] | commentairesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutProjetsInput | commentairesCreateOrConnectWithoutProjetsInput[]
    createMany?: commentairesCreateManyProjetsInputEnvelope
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
  }

  export type documentsUncheckedCreateNestedManyWithoutProjetsInput = {
    create?: XOR<documentsCreateWithoutProjetsInput, documentsUncheckedCreateWithoutProjetsInput> | documentsCreateWithoutProjetsInput[] | documentsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjetsInput | documentsCreateOrConnectWithoutProjetsInput[]
    createMany?: documentsCreateManyProjetsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type indicateursUncheckedCreateNestedManyWithoutProjetsInput = {
    create?: XOR<indicateursCreateWithoutProjetsInput, indicateursUncheckedCreateWithoutProjetsInput> | indicateursCreateWithoutProjetsInput[] | indicateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: indicateursCreateOrConnectWithoutProjetsInput | indicateursCreateOrConnectWithoutProjetsInput[]
    createMany?: indicateursCreateManyProjetsInputEnvelope
    connect?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
  }

  export type projet_groupesUncheckedCreateNestedManyWithoutProjetsInput = {
    create?: XOR<projet_groupesCreateWithoutProjetsInput, projet_groupesUncheckedCreateWithoutProjetsInput> | projet_groupesCreateWithoutProjetsInput[] | projet_groupesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutProjetsInput | projet_groupesCreateOrConnectWithoutProjetsInput[]
    createMany?: projet_groupesCreateManyProjetsInputEnvelope
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
  }

  export type projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput = {
    create?: XOR<projet_utilisateursCreateWithoutProjetsInput, projet_utilisateursUncheckedCreateWithoutProjetsInput> | projet_utilisateursCreateWithoutProjetsInput[] | projet_utilisateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutProjetsInput | projet_utilisateursCreateOrConnectWithoutProjetsInput[]
    createMany?: projet_utilisateursCreateManyProjetsInputEnvelope
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
  }

  export type ressourcesUncheckedCreateNestedManyWithoutProjetsInput = {
    create?: XOR<ressourcesCreateWithoutProjetsInput, ressourcesUncheckedCreateWithoutProjetsInput> | ressourcesCreateWithoutProjetsInput[] | ressourcesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: ressourcesCreateOrConnectWithoutProjetsInput | ressourcesCreateOrConnectWithoutProjetsInput[]
    createMany?: ressourcesCreateManyProjetsInputEnvelope
    connect?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
  }

  export type suggestionsUncheckedCreateNestedManyWithoutProjetsInput = {
    create?: XOR<suggestionsCreateWithoutProjetsInput, suggestionsUncheckedCreateWithoutProjetsInput> | suggestionsCreateWithoutProjetsInput[] | suggestionsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutProjetsInput | suggestionsCreateOrConnectWithoutProjetsInput[]
    createMany?: suggestionsCreateManyProjetsInputEnvelope
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
  }

  export type tachesUncheckedCreateNestedManyWithoutProjetInput = {
    create?: XOR<tachesCreateWithoutProjetInput, tachesUncheckedCreateWithoutProjetInput> | tachesCreateWithoutProjetInput[] | tachesUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutProjetInput | tachesCreateOrConnectWithoutProjetInput[]
    createMany?: tachesCreateManyProjetInputEnvelope
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
  }

  export type commentairesUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<commentairesCreateWithoutProjetsInput, commentairesUncheckedCreateWithoutProjetsInput> | commentairesCreateWithoutProjetsInput[] | commentairesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutProjetsInput | commentairesCreateOrConnectWithoutProjetsInput[]
    upsert?: commentairesUpsertWithWhereUniqueWithoutProjetsInput | commentairesUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: commentairesCreateManyProjetsInputEnvelope
    set?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    disconnect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    delete?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    update?: commentairesUpdateWithWhereUniqueWithoutProjetsInput | commentairesUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: commentairesUpdateManyWithWhereWithoutProjetsInput | commentairesUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: commentairesScalarWhereInput | commentairesScalarWhereInput[]
  }

  export type documentsUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<documentsCreateWithoutProjetsInput, documentsUncheckedCreateWithoutProjetsInput> | documentsCreateWithoutProjetsInput[] | documentsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjetsInput | documentsCreateOrConnectWithoutProjetsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutProjetsInput | documentsUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: documentsCreateManyProjetsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutProjetsInput | documentsUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutProjetsInput | documentsUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type indicateursUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<indicateursCreateWithoutProjetsInput, indicateursUncheckedCreateWithoutProjetsInput> | indicateursCreateWithoutProjetsInput[] | indicateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: indicateursCreateOrConnectWithoutProjetsInput | indicateursCreateOrConnectWithoutProjetsInput[]
    upsert?: indicateursUpsertWithWhereUniqueWithoutProjetsInput | indicateursUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: indicateursCreateManyProjetsInputEnvelope
    set?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    disconnect?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    delete?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    connect?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    update?: indicateursUpdateWithWhereUniqueWithoutProjetsInput | indicateursUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: indicateursUpdateManyWithWhereWithoutProjetsInput | indicateursUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: indicateursScalarWhereInput | indicateursScalarWhereInput[]
  }

  export type projet_groupesUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<projet_groupesCreateWithoutProjetsInput, projet_groupesUncheckedCreateWithoutProjetsInput> | projet_groupesCreateWithoutProjetsInput[] | projet_groupesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutProjetsInput | projet_groupesCreateOrConnectWithoutProjetsInput[]
    upsert?: projet_groupesUpsertWithWhereUniqueWithoutProjetsInput | projet_groupesUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: projet_groupesCreateManyProjetsInputEnvelope
    set?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    disconnect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    delete?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    update?: projet_groupesUpdateWithWhereUniqueWithoutProjetsInput | projet_groupesUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: projet_groupesUpdateManyWithWhereWithoutProjetsInput | projet_groupesUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: projet_groupesScalarWhereInput | projet_groupesScalarWhereInput[]
  }

  export type projet_utilisateursUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<projet_utilisateursCreateWithoutProjetsInput, projet_utilisateursUncheckedCreateWithoutProjetsInput> | projet_utilisateursCreateWithoutProjetsInput[] | projet_utilisateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutProjetsInput | projet_utilisateursCreateOrConnectWithoutProjetsInput[]
    upsert?: projet_utilisateursUpsertWithWhereUniqueWithoutProjetsInput | projet_utilisateursUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: projet_utilisateursCreateManyProjetsInputEnvelope
    set?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    disconnect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    delete?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    update?: projet_utilisateursUpdateWithWhereUniqueWithoutProjetsInput | projet_utilisateursUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: projet_utilisateursUpdateManyWithWhereWithoutProjetsInput | projet_utilisateursUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: projet_utilisateursScalarWhereInput | projet_utilisateursScalarWhereInput[]
  }

  export type utilisateursUpdateOneWithoutProjetsNestedInput = {
    create?: XOR<utilisateursCreateWithoutProjetsInput, utilisateursUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutProjetsInput
    upsert?: utilisateursUpsertWithoutProjetsInput
    disconnect?: utilisateursWhereInput | boolean
    delete?: utilisateursWhereInput | boolean
    connect?: utilisateursWhereUniqueInput
    update?: XOR<XOR<utilisateursUpdateToOneWithWhereWithoutProjetsInput, utilisateursUpdateWithoutProjetsInput>, utilisateursUncheckedUpdateWithoutProjetsInput>
  }

  export type axesUpdateOneRequiredWithoutProjetsNestedInput = {
    create?: XOR<axesCreateWithoutProjetsInput, axesUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: axesCreateOrConnectWithoutProjetsInput
    upsert?: axesUpsertWithoutProjetsInput
    connect?: axesWhereUniqueInput
    update?: XOR<XOR<axesUpdateToOneWithWhereWithoutProjetsInput, axesUpdateWithoutProjetsInput>, axesUncheckedUpdateWithoutProjetsInput>
  }

  export type priorityUpdateOneWithoutProjetsNestedInput = {
    create?: XOR<priorityCreateWithoutProjetsInput, priorityUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: priorityCreateOrConnectWithoutProjetsInput
    upsert?: priorityUpsertWithoutProjetsInput
    disconnect?: priorityWhereInput | boolean
    delete?: priorityWhereInput | boolean
    connect?: priorityWhereUniqueInput
    update?: XOR<XOR<priorityUpdateToOneWithWhereWithoutProjetsInput, priorityUpdateWithoutProjetsInput>, priorityUncheckedUpdateWithoutProjetsInput>
  }

  export type ressourcesUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<ressourcesCreateWithoutProjetsInput, ressourcesUncheckedCreateWithoutProjetsInput> | ressourcesCreateWithoutProjetsInput[] | ressourcesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: ressourcesCreateOrConnectWithoutProjetsInput | ressourcesCreateOrConnectWithoutProjetsInput[]
    upsert?: ressourcesUpsertWithWhereUniqueWithoutProjetsInput | ressourcesUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: ressourcesCreateManyProjetsInputEnvelope
    set?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    disconnect?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    delete?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    connect?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    update?: ressourcesUpdateWithWhereUniqueWithoutProjetsInput | ressourcesUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: ressourcesUpdateManyWithWhereWithoutProjetsInput | ressourcesUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: ressourcesScalarWhereInput | ressourcesScalarWhereInput[]
  }

  export type suggestionsUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<suggestionsCreateWithoutProjetsInput, suggestionsUncheckedCreateWithoutProjetsInput> | suggestionsCreateWithoutProjetsInput[] | suggestionsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutProjetsInput | suggestionsCreateOrConnectWithoutProjetsInput[]
    upsert?: suggestionsUpsertWithWhereUniqueWithoutProjetsInput | suggestionsUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: suggestionsCreateManyProjetsInputEnvelope
    set?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    disconnect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    delete?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    update?: suggestionsUpdateWithWhereUniqueWithoutProjetsInput | suggestionsUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: suggestionsUpdateManyWithWhereWithoutProjetsInput | suggestionsUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
  }

  export type tachesUpdateManyWithoutProjetNestedInput = {
    create?: XOR<tachesCreateWithoutProjetInput, tachesUncheckedCreateWithoutProjetInput> | tachesCreateWithoutProjetInput[] | tachesUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutProjetInput | tachesCreateOrConnectWithoutProjetInput[]
    upsert?: tachesUpsertWithWhereUniqueWithoutProjetInput | tachesUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: tachesCreateManyProjetInputEnvelope
    set?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    disconnect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    delete?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    update?: tachesUpdateWithWhereUniqueWithoutProjetInput | tachesUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: tachesUpdateManyWithWhereWithoutProjetInput | tachesUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: tachesScalarWhereInput | tachesScalarWhereInput[]
  }

  export type commentairesUncheckedUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<commentairesCreateWithoutProjetsInput, commentairesUncheckedCreateWithoutProjetsInput> | commentairesCreateWithoutProjetsInput[] | commentairesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: commentairesCreateOrConnectWithoutProjetsInput | commentairesCreateOrConnectWithoutProjetsInput[]
    upsert?: commentairesUpsertWithWhereUniqueWithoutProjetsInput | commentairesUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: commentairesCreateManyProjetsInputEnvelope
    set?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    disconnect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    delete?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    connect?: commentairesWhereUniqueInput | commentairesWhereUniqueInput[]
    update?: commentairesUpdateWithWhereUniqueWithoutProjetsInput | commentairesUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: commentairesUpdateManyWithWhereWithoutProjetsInput | commentairesUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: commentairesScalarWhereInput | commentairesScalarWhereInput[]
  }

  export type documentsUncheckedUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<documentsCreateWithoutProjetsInput, documentsUncheckedCreateWithoutProjetsInput> | documentsCreateWithoutProjetsInput[] | documentsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjetsInput | documentsCreateOrConnectWithoutProjetsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutProjetsInput | documentsUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: documentsCreateManyProjetsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutProjetsInput | documentsUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutProjetsInput | documentsUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type indicateursUncheckedUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<indicateursCreateWithoutProjetsInput, indicateursUncheckedCreateWithoutProjetsInput> | indicateursCreateWithoutProjetsInput[] | indicateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: indicateursCreateOrConnectWithoutProjetsInput | indicateursCreateOrConnectWithoutProjetsInput[]
    upsert?: indicateursUpsertWithWhereUniqueWithoutProjetsInput | indicateursUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: indicateursCreateManyProjetsInputEnvelope
    set?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    disconnect?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    delete?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    connect?: indicateursWhereUniqueInput | indicateursWhereUniqueInput[]
    update?: indicateursUpdateWithWhereUniqueWithoutProjetsInput | indicateursUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: indicateursUpdateManyWithWhereWithoutProjetsInput | indicateursUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: indicateursScalarWhereInput | indicateursScalarWhereInput[]
  }

  export type projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<projet_groupesCreateWithoutProjetsInput, projet_groupesUncheckedCreateWithoutProjetsInput> | projet_groupesCreateWithoutProjetsInput[] | projet_groupesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_groupesCreateOrConnectWithoutProjetsInput | projet_groupesCreateOrConnectWithoutProjetsInput[]
    upsert?: projet_groupesUpsertWithWhereUniqueWithoutProjetsInput | projet_groupesUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: projet_groupesCreateManyProjetsInputEnvelope
    set?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    disconnect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    delete?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    connect?: projet_groupesWhereUniqueInput | projet_groupesWhereUniqueInput[]
    update?: projet_groupesUpdateWithWhereUniqueWithoutProjetsInput | projet_groupesUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: projet_groupesUpdateManyWithWhereWithoutProjetsInput | projet_groupesUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: projet_groupesScalarWhereInput | projet_groupesScalarWhereInput[]
  }

  export type projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<projet_utilisateursCreateWithoutProjetsInput, projet_utilisateursUncheckedCreateWithoutProjetsInput> | projet_utilisateursCreateWithoutProjetsInput[] | projet_utilisateursUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutProjetsInput | projet_utilisateursCreateOrConnectWithoutProjetsInput[]
    upsert?: projet_utilisateursUpsertWithWhereUniqueWithoutProjetsInput | projet_utilisateursUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: projet_utilisateursCreateManyProjetsInputEnvelope
    set?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    disconnect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    delete?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    update?: projet_utilisateursUpdateWithWhereUniqueWithoutProjetsInput | projet_utilisateursUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: projet_utilisateursUpdateManyWithWhereWithoutProjetsInput | projet_utilisateursUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: projet_utilisateursScalarWhereInput | projet_utilisateursScalarWhereInput[]
  }

  export type ressourcesUncheckedUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<ressourcesCreateWithoutProjetsInput, ressourcesUncheckedCreateWithoutProjetsInput> | ressourcesCreateWithoutProjetsInput[] | ressourcesUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: ressourcesCreateOrConnectWithoutProjetsInput | ressourcesCreateOrConnectWithoutProjetsInput[]
    upsert?: ressourcesUpsertWithWhereUniqueWithoutProjetsInput | ressourcesUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: ressourcesCreateManyProjetsInputEnvelope
    set?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    disconnect?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    delete?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    connect?: ressourcesWhereUniqueInput | ressourcesWhereUniqueInput[]
    update?: ressourcesUpdateWithWhereUniqueWithoutProjetsInput | ressourcesUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: ressourcesUpdateManyWithWhereWithoutProjetsInput | ressourcesUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: ressourcesScalarWhereInput | ressourcesScalarWhereInput[]
  }

  export type suggestionsUncheckedUpdateManyWithoutProjetsNestedInput = {
    create?: XOR<suggestionsCreateWithoutProjetsInput, suggestionsUncheckedCreateWithoutProjetsInput> | suggestionsCreateWithoutProjetsInput[] | suggestionsUncheckedCreateWithoutProjetsInput[]
    connectOrCreate?: suggestionsCreateOrConnectWithoutProjetsInput | suggestionsCreateOrConnectWithoutProjetsInput[]
    upsert?: suggestionsUpsertWithWhereUniqueWithoutProjetsInput | suggestionsUpsertWithWhereUniqueWithoutProjetsInput[]
    createMany?: suggestionsCreateManyProjetsInputEnvelope
    set?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    disconnect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    delete?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    connect?: suggestionsWhereUniqueInput | suggestionsWhereUniqueInput[]
    update?: suggestionsUpdateWithWhereUniqueWithoutProjetsInput | suggestionsUpdateWithWhereUniqueWithoutProjetsInput[]
    updateMany?: suggestionsUpdateManyWithWhereWithoutProjetsInput | suggestionsUpdateManyWithWhereWithoutProjetsInput[]
    deleteMany?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
  }

  export type tachesUncheckedUpdateManyWithoutProjetNestedInput = {
    create?: XOR<tachesCreateWithoutProjetInput, tachesUncheckedCreateWithoutProjetInput> | tachesCreateWithoutProjetInput[] | tachesUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutProjetInput | tachesCreateOrConnectWithoutProjetInput[]
    upsert?: tachesUpsertWithWhereUniqueWithoutProjetInput | tachesUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: tachesCreateManyProjetInputEnvelope
    set?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    disconnect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    delete?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    update?: tachesUpdateWithWhereUniqueWithoutProjetInput | tachesUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: tachesUpdateManyWithWhereWithoutProjetInput | tachesUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: tachesScalarWhereInput | tachesScalarWhereInput[]
  }

  export type projetsCreateNestedOneWithoutRessourcesInput = {
    create?: XOR<projetsCreateWithoutRessourcesInput, projetsUncheckedCreateWithoutRessourcesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutRessourcesInput
    connect?: projetsWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type projetsUpdateOneRequiredWithoutRessourcesNestedInput = {
    create?: XOR<projetsCreateWithoutRessourcesInput, projetsUncheckedCreateWithoutRessourcesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutRessourcesInput
    upsert?: projetsUpsertWithoutRessourcesInput
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutRessourcesInput, projetsUpdateWithoutRessourcesInput>, projetsUncheckedUpdateWithoutRessourcesInput>
  }

  export type rolesCreateNestedOneWithoutRole_permissionsInput = {
    create?: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_permissionsInput
    connect?: rolesWhereUniqueInput
  }

  export type permissionsCreateNestedOneWithoutRole_permissionsInput = {
    create?: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_permissionsInput
    connect?: permissionsWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutRole_permissionsNestedInput = {
    create?: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_permissionsInput
    upsert?: rolesUpsertWithoutRole_permissionsInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutRole_permissionsInput, rolesUpdateWithoutRole_permissionsInput>, rolesUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type permissionsUpdateOneRequiredWithoutRole_permissionsNestedInput = {
    create?: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_permissionsInput
    upsert?: permissionsUpsertWithoutRole_permissionsInput
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutRole_permissionsInput, permissionsUpdateWithoutRole_permissionsInput>, permissionsUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type comptesCreateNestedManyWithoutRolesInput = {
    create?: XOR<comptesCreateWithoutRolesInput, comptesUncheckedCreateWithoutRolesInput> | comptesCreateWithoutRolesInput[] | comptesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutRolesInput | comptesCreateOrConnectWithoutRolesInput[]
    createMany?: comptesCreateManyRolesInputEnvelope
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
  }

  export type role_permissionsCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type comptesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<comptesCreateWithoutRolesInput, comptesUncheckedCreateWithoutRolesInput> | comptesCreateWithoutRolesInput[] | comptesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutRolesInput | comptesCreateOrConnectWithoutRolesInput[]
    createMany?: comptesCreateManyRolesInputEnvelope
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
  }

  export type role_permissionsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type comptesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<comptesCreateWithoutRolesInput, comptesUncheckedCreateWithoutRolesInput> | comptesCreateWithoutRolesInput[] | comptesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutRolesInput | comptesCreateOrConnectWithoutRolesInput[]
    upsert?: comptesUpsertWithWhereUniqueWithoutRolesInput | comptesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: comptesCreateManyRolesInputEnvelope
    set?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    disconnect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    delete?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    update?: comptesUpdateWithWhereUniqueWithoutRolesInput | comptesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: comptesUpdateManyWithWhereWithoutRolesInput | comptesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: comptesScalarWhereInput | comptesScalarWhereInput[]
  }

  export type role_permissionsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutRolesInput | role_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type comptesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<comptesCreateWithoutRolesInput, comptesUncheckedCreateWithoutRolesInput> | comptesCreateWithoutRolesInput[] | comptesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutRolesInput | comptesCreateOrConnectWithoutRolesInput[]
    upsert?: comptesUpsertWithWhereUniqueWithoutRolesInput | comptesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: comptesCreateManyRolesInputEnvelope
    set?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    disconnect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    delete?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    update?: comptesUpdateWithWhereUniqueWithoutRolesInput | comptesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: comptesUpdateManyWithWhereWithoutRolesInput | comptesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: comptesScalarWhereInput | comptesScalarWhereInput[]
  }

  export type role_permissionsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutRolesInput | role_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type comptesCreateNestedOneWithoutSuggestionsInput = {
    create?: XOR<comptesCreateWithoutSuggestionsInput, comptesUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: comptesCreateOrConnectWithoutSuggestionsInput
    connect?: comptesWhereUniqueInput
  }

  export type projetsCreateNestedOneWithoutSuggestionsInput = {
    create?: XOR<projetsCreateWithoutSuggestionsInput, projetsUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: projetsCreateOrConnectWithoutSuggestionsInput
    connect?: projetsWhereUniqueInput
  }

  export type comptesUpdateOneRequiredWithoutSuggestionsNestedInput = {
    create?: XOR<comptesCreateWithoutSuggestionsInput, comptesUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: comptesCreateOrConnectWithoutSuggestionsInput
    upsert?: comptesUpsertWithoutSuggestionsInput
    connect?: comptesWhereUniqueInput
    update?: XOR<XOR<comptesUpdateToOneWithWhereWithoutSuggestionsInput, comptesUpdateWithoutSuggestionsInput>, comptesUncheckedUpdateWithoutSuggestionsInput>
  }

  export type projetsUpdateOneRequiredWithoutSuggestionsNestedInput = {
    create?: XOR<projetsCreateWithoutSuggestionsInput, projetsUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: projetsCreateOrConnectWithoutSuggestionsInput
    upsert?: projetsUpsertWithoutSuggestionsInput
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutSuggestionsInput, projetsUpdateWithoutSuggestionsInput>, projetsUncheckedUpdateWithoutSuggestionsInput>
  }

  export type tachesCreateNestedOneWithoutTache_assignations_groupesInput = {
    create?: XOR<tachesCreateWithoutTache_assignations_groupesInput, tachesUncheckedCreateWithoutTache_assignations_groupesInput>
    connectOrCreate?: tachesCreateOrConnectWithoutTache_assignations_groupesInput
    connect?: tachesWhereUniqueInput
  }

  export type groupesCreateNestedOneWithoutTache_assignations_groupesInput = {
    create?: XOR<groupesCreateWithoutTache_assignations_groupesInput, groupesUncheckedCreateWithoutTache_assignations_groupesInput>
    connectOrCreate?: groupesCreateOrConnectWithoutTache_assignations_groupesInput
    connect?: groupesWhereUniqueInput
  }

  export type tachesUpdateOneRequiredWithoutTache_assignations_groupesNestedInput = {
    create?: XOR<tachesCreateWithoutTache_assignations_groupesInput, tachesUncheckedCreateWithoutTache_assignations_groupesInput>
    connectOrCreate?: tachesCreateOrConnectWithoutTache_assignations_groupesInput
    upsert?: tachesUpsertWithoutTache_assignations_groupesInput
    connect?: tachesWhereUniqueInput
    update?: XOR<XOR<tachesUpdateToOneWithWhereWithoutTache_assignations_groupesInput, tachesUpdateWithoutTache_assignations_groupesInput>, tachesUncheckedUpdateWithoutTache_assignations_groupesInput>
  }

  export type groupesUpdateOneRequiredWithoutTache_assignations_groupesNestedInput = {
    create?: XOR<groupesCreateWithoutTache_assignations_groupesInput, groupesUncheckedCreateWithoutTache_assignations_groupesInput>
    connectOrCreate?: groupesCreateOrConnectWithoutTache_assignations_groupesInput
    upsert?: groupesUpsertWithoutTache_assignations_groupesInput
    connect?: groupesWhereUniqueInput
    update?: XOR<XOR<groupesUpdateToOneWithWhereWithoutTache_assignations_groupesInput, groupesUpdateWithoutTache_assignations_groupesInput>, groupesUncheckedUpdateWithoutTache_assignations_groupesInput>
  }

  export type tachesCreateNestedOneWithoutTache_assignations_utilisateursInput = {
    create?: XOR<tachesCreateWithoutTache_assignations_utilisateursInput, tachesUncheckedCreateWithoutTache_assignations_utilisateursInput>
    connectOrCreate?: tachesCreateOrConnectWithoutTache_assignations_utilisateursInput
    connect?: tachesWhereUniqueInput
  }

  export type utilisateursCreateNestedOneWithoutTache_assignations_utilisateursInput = {
    create?: XOR<utilisateursCreateWithoutTache_assignations_utilisateursInput, utilisateursUncheckedCreateWithoutTache_assignations_utilisateursInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutTache_assignations_utilisateursInput
    connect?: utilisateursWhereUniqueInput
  }

  export type tachesUpdateOneRequiredWithoutTache_assignations_utilisateursNestedInput = {
    create?: XOR<tachesCreateWithoutTache_assignations_utilisateursInput, tachesUncheckedCreateWithoutTache_assignations_utilisateursInput>
    connectOrCreate?: tachesCreateOrConnectWithoutTache_assignations_utilisateursInput
    upsert?: tachesUpsertWithoutTache_assignations_utilisateursInput
    connect?: tachesWhereUniqueInput
    update?: XOR<XOR<tachesUpdateToOneWithWhereWithoutTache_assignations_utilisateursInput, tachesUpdateWithoutTache_assignations_utilisateursInput>, tachesUncheckedUpdateWithoutTache_assignations_utilisateursInput>
  }

  export type utilisateursUpdateOneRequiredWithoutTache_assignations_utilisateursNestedInput = {
    create?: XOR<utilisateursCreateWithoutTache_assignations_utilisateursInput, utilisateursUncheckedCreateWithoutTache_assignations_utilisateursInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutTache_assignations_utilisateursInput
    upsert?: utilisateursUpsertWithoutTache_assignations_utilisateursInput
    connect?: utilisateursWhereUniqueInput
    update?: XOR<XOR<utilisateursUpdateToOneWithWhereWithoutTache_assignations_utilisateursInput, utilisateursUpdateWithoutTache_assignations_utilisateursInput>, utilisateursUncheckedUpdateWithoutTache_assignations_utilisateursInput>
  }

  export type tache_assignations_groupesCreateNestedManyWithoutTachesInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutTachesInput, tache_assignations_groupesUncheckedCreateWithoutTachesInput> | tache_assignations_groupesCreateWithoutTachesInput[] | tache_assignations_groupesUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutTachesInput | tache_assignations_groupesCreateOrConnectWithoutTachesInput[]
    createMany?: tache_assignations_groupesCreateManyTachesInputEnvelope
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
  }

  export type tache_assignations_utilisateursCreateNestedManyWithoutTachesInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutTachesInput, tache_assignations_utilisateursUncheckedCreateWithoutTachesInput> | tache_assignations_utilisateursCreateWithoutTachesInput[] | tache_assignations_utilisateursUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutTachesInput | tache_assignations_utilisateursCreateOrConnectWithoutTachesInput[]
    createMany?: tache_assignations_utilisateursCreateManyTachesInputEnvelope
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
  }

  export type utilisateursCreateNestedOneWithoutTachesInput = {
    create?: XOR<utilisateursCreateWithoutTachesInput, utilisateursUncheckedCreateWithoutTachesInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutTachesInput
    connect?: utilisateursWhereUniqueInput
  }

  export type projetsCreateNestedOneWithoutTachesInput = {
    create?: XOR<projetsCreateWithoutTachesInput, projetsUncheckedCreateWithoutTachesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutTachesInput
    connect?: projetsWhereUniqueInput
  }

  export type tache_assignations_groupesUncheckedCreateNestedManyWithoutTachesInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutTachesInput, tache_assignations_groupesUncheckedCreateWithoutTachesInput> | tache_assignations_groupesCreateWithoutTachesInput[] | tache_assignations_groupesUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutTachesInput | tache_assignations_groupesCreateOrConnectWithoutTachesInput[]
    createMany?: tache_assignations_groupesCreateManyTachesInputEnvelope
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
  }

  export type tache_assignations_utilisateursUncheckedCreateNestedManyWithoutTachesInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutTachesInput, tache_assignations_utilisateursUncheckedCreateWithoutTachesInput> | tache_assignations_utilisateursCreateWithoutTachesInput[] | tache_assignations_utilisateursUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutTachesInput | tache_assignations_utilisateursCreateOrConnectWithoutTachesInput[]
    createMany?: tache_assignations_utilisateursCreateManyTachesInputEnvelope
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
  }

  export type tache_assignations_groupesUpdateManyWithoutTachesNestedInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutTachesInput, tache_assignations_groupesUncheckedCreateWithoutTachesInput> | tache_assignations_groupesCreateWithoutTachesInput[] | tache_assignations_groupesUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutTachesInput | tache_assignations_groupesCreateOrConnectWithoutTachesInput[]
    upsert?: tache_assignations_groupesUpsertWithWhereUniqueWithoutTachesInput | tache_assignations_groupesUpsertWithWhereUniqueWithoutTachesInput[]
    createMany?: tache_assignations_groupesCreateManyTachesInputEnvelope
    set?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    disconnect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    delete?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    update?: tache_assignations_groupesUpdateWithWhereUniqueWithoutTachesInput | tache_assignations_groupesUpdateWithWhereUniqueWithoutTachesInput[]
    updateMany?: tache_assignations_groupesUpdateManyWithWhereWithoutTachesInput | tache_assignations_groupesUpdateManyWithWhereWithoutTachesInput[]
    deleteMany?: tache_assignations_groupesScalarWhereInput | tache_assignations_groupesScalarWhereInput[]
  }

  export type tache_assignations_utilisateursUpdateManyWithoutTachesNestedInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutTachesInput, tache_assignations_utilisateursUncheckedCreateWithoutTachesInput> | tache_assignations_utilisateursCreateWithoutTachesInput[] | tache_assignations_utilisateursUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutTachesInput | tache_assignations_utilisateursCreateOrConnectWithoutTachesInput[]
    upsert?: tache_assignations_utilisateursUpsertWithWhereUniqueWithoutTachesInput | tache_assignations_utilisateursUpsertWithWhereUniqueWithoutTachesInput[]
    createMany?: tache_assignations_utilisateursCreateManyTachesInputEnvelope
    set?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    disconnect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    delete?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    update?: tache_assignations_utilisateursUpdateWithWhereUniqueWithoutTachesInput | tache_assignations_utilisateursUpdateWithWhereUniqueWithoutTachesInput[]
    updateMany?: tache_assignations_utilisateursUpdateManyWithWhereWithoutTachesInput | tache_assignations_utilisateursUpdateManyWithWhereWithoutTachesInput[]
    deleteMany?: tache_assignations_utilisateursScalarWhereInput | tache_assignations_utilisateursScalarWhereInput[]
  }

  export type utilisateursUpdateOneWithoutTachesNestedInput = {
    create?: XOR<utilisateursCreateWithoutTachesInput, utilisateursUncheckedCreateWithoutTachesInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutTachesInput
    upsert?: utilisateursUpsertWithoutTachesInput
    disconnect?: utilisateursWhereInput | boolean
    delete?: utilisateursWhereInput | boolean
    connect?: utilisateursWhereUniqueInput
    update?: XOR<XOR<utilisateursUpdateToOneWithWhereWithoutTachesInput, utilisateursUpdateWithoutTachesInput>, utilisateursUncheckedUpdateWithoutTachesInput>
  }

  export type projetsUpdateOneWithoutTachesNestedInput = {
    create?: XOR<projetsCreateWithoutTachesInput, projetsUncheckedCreateWithoutTachesInput>
    connectOrCreate?: projetsCreateOrConnectWithoutTachesInput
    upsert?: projetsUpsertWithoutTachesInput
    disconnect?: projetsWhereInput | boolean
    delete?: projetsWhereInput | boolean
    connect?: projetsWhereUniqueInput
    update?: XOR<XOR<projetsUpdateToOneWithWhereWithoutTachesInput, projetsUpdateWithoutTachesInput>, projetsUncheckedUpdateWithoutTachesInput>
  }

  export type tache_assignations_groupesUncheckedUpdateManyWithoutTachesNestedInput = {
    create?: XOR<tache_assignations_groupesCreateWithoutTachesInput, tache_assignations_groupesUncheckedCreateWithoutTachesInput> | tache_assignations_groupesCreateWithoutTachesInput[] | tache_assignations_groupesUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_groupesCreateOrConnectWithoutTachesInput | tache_assignations_groupesCreateOrConnectWithoutTachesInput[]
    upsert?: tache_assignations_groupesUpsertWithWhereUniqueWithoutTachesInput | tache_assignations_groupesUpsertWithWhereUniqueWithoutTachesInput[]
    createMany?: tache_assignations_groupesCreateManyTachesInputEnvelope
    set?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    disconnect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    delete?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    connect?: tache_assignations_groupesWhereUniqueInput | tache_assignations_groupesWhereUniqueInput[]
    update?: tache_assignations_groupesUpdateWithWhereUniqueWithoutTachesInput | tache_assignations_groupesUpdateWithWhereUniqueWithoutTachesInput[]
    updateMany?: tache_assignations_groupesUpdateManyWithWhereWithoutTachesInput | tache_assignations_groupesUpdateManyWithWhereWithoutTachesInput[]
    deleteMany?: tache_assignations_groupesScalarWhereInput | tache_assignations_groupesScalarWhereInput[]
  }

  export type tache_assignations_utilisateursUncheckedUpdateManyWithoutTachesNestedInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutTachesInput, tache_assignations_utilisateursUncheckedCreateWithoutTachesInput> | tache_assignations_utilisateursCreateWithoutTachesInput[] | tache_assignations_utilisateursUncheckedCreateWithoutTachesInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutTachesInput | tache_assignations_utilisateursCreateOrConnectWithoutTachesInput[]
    upsert?: tache_assignations_utilisateursUpsertWithWhereUniqueWithoutTachesInput | tache_assignations_utilisateursUpsertWithWhereUniqueWithoutTachesInput[]
    createMany?: tache_assignations_utilisateursCreateManyTachesInputEnvelope
    set?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    disconnect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    delete?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    update?: tache_assignations_utilisateursUpdateWithWhereUniqueWithoutTachesInput | tache_assignations_utilisateursUpdateWithWhereUniqueWithoutTachesInput[]
    updateMany?: tache_assignations_utilisateursUpdateManyWithWhereWithoutTachesInput | tache_assignations_utilisateursUpdateManyWithWhereWithoutTachesInput[]
    deleteMany?: tache_assignations_utilisateursScalarWhereInput | tache_assignations_utilisateursScalarWhereInput[]
  }

  export type comptesCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<comptesCreateWithoutUtilisateursInput, comptesUncheckedCreateWithoutUtilisateursInput> | comptesCreateWithoutUtilisateursInput[] | comptesUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutUtilisateursInput | comptesCreateOrConnectWithoutUtilisateursInput[]
    createMany?: comptesCreateManyUtilisateursInputEnvelope
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
  }

  export type projet_utilisateursCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<projet_utilisateursCreateWithoutUtilisateursInput, projet_utilisateursUncheckedCreateWithoutUtilisateursInput> | projet_utilisateursCreateWithoutUtilisateursInput[] | projet_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutUtilisateursInput | projet_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    createMany?: projet_utilisateursCreateManyUtilisateursInputEnvelope
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
  }

  export type projetsCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<projetsCreateWithoutUtilisateursInput, projetsUncheckedCreateWithoutUtilisateursInput> | projetsCreateWithoutUtilisateursInput[] | projetsUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutUtilisateursInput | projetsCreateOrConnectWithoutUtilisateursInput[]
    createMany?: projetsCreateManyUtilisateursInputEnvelope
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
  }

  export type tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput> | tache_assignations_utilisateursCreateWithoutUtilisateursInput[] | tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput | tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    createMany?: tache_assignations_utilisateursCreateManyUtilisateursInputEnvelope
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
  }

  export type tachesCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<tachesCreateWithoutUtilisateurInput, tachesUncheckedCreateWithoutUtilisateurInput> | tachesCreateWithoutUtilisateurInput[] | tachesUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutUtilisateurInput | tachesCreateOrConnectWithoutUtilisateurInput[]
    createMany?: tachesCreateManyUtilisateurInputEnvelope
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
  }

  export type category_userCreateNestedOneWithoutUtilisateursInput = {
    create?: XOR<category_userCreateWithoutUtilisateursInput, category_userUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: category_userCreateOrConnectWithoutUtilisateursInput
    connect?: category_userWhereUniqueInput
  }

  export type GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutUtilisateursInput, GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput> | GroupesUtilisateursCreateWithoutUtilisateursInput[] | GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput | GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput[]
    createMany?: GroupesUtilisateursCreateManyUtilisateursInputEnvelope
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type comptesUncheckedCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<comptesCreateWithoutUtilisateursInput, comptesUncheckedCreateWithoutUtilisateursInput> | comptesCreateWithoutUtilisateursInput[] | comptesUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutUtilisateursInput | comptesCreateOrConnectWithoutUtilisateursInput[]
    createMany?: comptesCreateManyUtilisateursInputEnvelope
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
  }

  export type projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<projet_utilisateursCreateWithoutUtilisateursInput, projet_utilisateursUncheckedCreateWithoutUtilisateursInput> | projet_utilisateursCreateWithoutUtilisateursInput[] | projet_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutUtilisateursInput | projet_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    createMany?: projet_utilisateursCreateManyUtilisateursInputEnvelope
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
  }

  export type projetsUncheckedCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<projetsCreateWithoutUtilisateursInput, projetsUncheckedCreateWithoutUtilisateursInput> | projetsCreateWithoutUtilisateursInput[] | projetsUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutUtilisateursInput | projetsCreateOrConnectWithoutUtilisateursInput[]
    createMany?: projetsCreateManyUtilisateursInputEnvelope
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
  }

  export type tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput> | tache_assignations_utilisateursCreateWithoutUtilisateursInput[] | tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput | tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    createMany?: tache_assignations_utilisateursCreateManyUtilisateursInputEnvelope
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
  }

  export type tachesUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<tachesCreateWithoutUtilisateurInput, tachesUncheckedCreateWithoutUtilisateurInput> | tachesCreateWithoutUtilisateurInput[] | tachesUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutUtilisateurInput | tachesCreateOrConnectWithoutUtilisateurInput[]
    createMany?: tachesCreateManyUtilisateurInputEnvelope
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
  }

  export type GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutUtilisateursInput, GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput> | GroupesUtilisateursCreateWithoutUtilisateursInput[] | GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput | GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput[]
    createMany?: GroupesUtilisateursCreateManyUtilisateursInputEnvelope
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type comptesUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<comptesCreateWithoutUtilisateursInput, comptesUncheckedCreateWithoutUtilisateursInput> | comptesCreateWithoutUtilisateursInput[] | comptesUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutUtilisateursInput | comptesCreateOrConnectWithoutUtilisateursInput[]
    upsert?: comptesUpsertWithWhereUniqueWithoutUtilisateursInput | comptesUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: comptesCreateManyUtilisateursInputEnvelope
    set?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    disconnect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    delete?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    update?: comptesUpdateWithWhereUniqueWithoutUtilisateursInput | comptesUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: comptesUpdateManyWithWhereWithoutUtilisateursInput | comptesUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: comptesScalarWhereInput | comptesScalarWhereInput[]
  }

  export type projet_utilisateursUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<projet_utilisateursCreateWithoutUtilisateursInput, projet_utilisateursUncheckedCreateWithoutUtilisateursInput> | projet_utilisateursCreateWithoutUtilisateursInput[] | projet_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutUtilisateursInput | projet_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    upsert?: projet_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput | projet_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: projet_utilisateursCreateManyUtilisateursInputEnvelope
    set?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    disconnect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    delete?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    update?: projet_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput | projet_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: projet_utilisateursUpdateManyWithWhereWithoutUtilisateursInput | projet_utilisateursUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: projet_utilisateursScalarWhereInput | projet_utilisateursScalarWhereInput[]
  }

  export type projetsUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<projetsCreateWithoutUtilisateursInput, projetsUncheckedCreateWithoutUtilisateursInput> | projetsCreateWithoutUtilisateursInput[] | projetsUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutUtilisateursInput | projetsCreateOrConnectWithoutUtilisateursInput[]
    upsert?: projetsUpsertWithWhereUniqueWithoutUtilisateursInput | projetsUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: projetsCreateManyUtilisateursInputEnvelope
    set?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    disconnect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    delete?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    update?: projetsUpdateWithWhereUniqueWithoutUtilisateursInput | projetsUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: projetsUpdateManyWithWhereWithoutUtilisateursInput | projetsUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: projetsScalarWhereInput | projetsScalarWhereInput[]
  }

  export type tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput> | tache_assignations_utilisateursCreateWithoutUtilisateursInput[] | tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput | tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    upsert?: tache_assignations_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput | tache_assignations_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: tache_assignations_utilisateursCreateManyUtilisateursInputEnvelope
    set?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    disconnect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    delete?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    update?: tache_assignations_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput | tache_assignations_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: tache_assignations_utilisateursUpdateManyWithWhereWithoutUtilisateursInput | tache_assignations_utilisateursUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: tache_assignations_utilisateursScalarWhereInput | tache_assignations_utilisateursScalarWhereInput[]
  }

  export type tachesUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<tachesCreateWithoutUtilisateurInput, tachesUncheckedCreateWithoutUtilisateurInput> | tachesCreateWithoutUtilisateurInput[] | tachesUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutUtilisateurInput | tachesCreateOrConnectWithoutUtilisateurInput[]
    upsert?: tachesUpsertWithWhereUniqueWithoutUtilisateurInput | tachesUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: tachesCreateManyUtilisateurInputEnvelope
    set?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    disconnect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    delete?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    update?: tachesUpdateWithWhereUniqueWithoutUtilisateurInput | tachesUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: tachesUpdateManyWithWhereWithoutUtilisateurInput | tachesUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: tachesScalarWhereInput | tachesScalarWhereInput[]
  }

  export type category_userUpdateOneWithoutUtilisateursNestedInput = {
    create?: XOR<category_userCreateWithoutUtilisateursInput, category_userUncheckedCreateWithoutUtilisateursInput>
    connectOrCreate?: category_userCreateOrConnectWithoutUtilisateursInput
    upsert?: category_userUpsertWithoutUtilisateursInput
    disconnect?: category_userWhereInput | boolean
    delete?: category_userWhereInput | boolean
    connect?: category_userWhereUniqueInput
    update?: XOR<XOR<category_userUpdateToOneWithWhereWithoutUtilisateursInput, category_userUpdateWithoutUtilisateursInput>, category_userUncheckedUpdateWithoutUtilisateursInput>
  }

  export type GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutUtilisateursInput, GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput> | GroupesUtilisateursCreateWithoutUtilisateursInput[] | GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput | GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput[]
    upsert?: GroupesUtilisateursUpsertWithWhereUniqueWithoutUtilisateursInput | GroupesUtilisateursUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: GroupesUtilisateursCreateManyUtilisateursInputEnvelope
    set?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    disconnect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    delete?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    update?: GroupesUtilisateursUpdateWithWhereUniqueWithoutUtilisateursInput | GroupesUtilisateursUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: GroupesUtilisateursUpdateManyWithWhereWithoutUtilisateursInput | GroupesUtilisateursUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: GroupesUtilisateursScalarWhereInput | GroupesUtilisateursScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUserInput | notificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUserInput | notificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUserInput | notificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type comptesUncheckedUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<comptesCreateWithoutUtilisateursInput, comptesUncheckedCreateWithoutUtilisateursInput> | comptesCreateWithoutUtilisateursInput[] | comptesUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: comptesCreateOrConnectWithoutUtilisateursInput | comptesCreateOrConnectWithoutUtilisateursInput[]
    upsert?: comptesUpsertWithWhereUniqueWithoutUtilisateursInput | comptesUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: comptesCreateManyUtilisateursInputEnvelope
    set?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    disconnect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    delete?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    connect?: comptesWhereUniqueInput | comptesWhereUniqueInput[]
    update?: comptesUpdateWithWhereUniqueWithoutUtilisateursInput | comptesUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: comptesUpdateManyWithWhereWithoutUtilisateursInput | comptesUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: comptesScalarWhereInput | comptesScalarWhereInput[]
  }

  export type projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<projet_utilisateursCreateWithoutUtilisateursInput, projet_utilisateursUncheckedCreateWithoutUtilisateursInput> | projet_utilisateursCreateWithoutUtilisateursInput[] | projet_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projet_utilisateursCreateOrConnectWithoutUtilisateursInput | projet_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    upsert?: projet_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput | projet_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: projet_utilisateursCreateManyUtilisateursInputEnvelope
    set?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    disconnect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    delete?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    connect?: projet_utilisateursWhereUniqueInput | projet_utilisateursWhereUniqueInput[]
    update?: projet_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput | projet_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: projet_utilisateursUpdateManyWithWhereWithoutUtilisateursInput | projet_utilisateursUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: projet_utilisateursScalarWhereInput | projet_utilisateursScalarWhereInput[]
  }

  export type projetsUncheckedUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<projetsCreateWithoutUtilisateursInput, projetsUncheckedCreateWithoutUtilisateursInput> | projetsCreateWithoutUtilisateursInput[] | projetsUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: projetsCreateOrConnectWithoutUtilisateursInput | projetsCreateOrConnectWithoutUtilisateursInput[]
    upsert?: projetsUpsertWithWhereUniqueWithoutUtilisateursInput | projetsUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: projetsCreateManyUtilisateursInputEnvelope
    set?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    disconnect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    delete?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    connect?: projetsWhereUniqueInput | projetsWhereUniqueInput[]
    update?: projetsUpdateWithWhereUniqueWithoutUtilisateursInput | projetsUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: projetsUpdateManyWithWhereWithoutUtilisateursInput | projetsUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: projetsScalarWhereInput | projetsScalarWhereInput[]
  }

  export type tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<tache_assignations_utilisateursCreateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput> | tache_assignations_utilisateursCreateWithoutUtilisateursInput[] | tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput | tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput[]
    upsert?: tache_assignations_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput | tache_assignations_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: tache_assignations_utilisateursCreateManyUtilisateursInputEnvelope
    set?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    disconnect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    delete?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    connect?: tache_assignations_utilisateursWhereUniqueInput | tache_assignations_utilisateursWhereUniqueInput[]
    update?: tache_assignations_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput | tache_assignations_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: tache_assignations_utilisateursUpdateManyWithWhereWithoutUtilisateursInput | tache_assignations_utilisateursUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: tache_assignations_utilisateursScalarWhereInput | tache_assignations_utilisateursScalarWhereInput[]
  }

  export type tachesUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<tachesCreateWithoutUtilisateurInput, tachesUncheckedCreateWithoutUtilisateurInput> | tachesCreateWithoutUtilisateurInput[] | tachesUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: tachesCreateOrConnectWithoutUtilisateurInput | tachesCreateOrConnectWithoutUtilisateurInput[]
    upsert?: tachesUpsertWithWhereUniqueWithoutUtilisateurInput | tachesUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: tachesCreateManyUtilisateurInputEnvelope
    set?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    disconnect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    delete?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    connect?: tachesWhereUniqueInput | tachesWhereUniqueInput[]
    update?: tachesUpdateWithWhereUniqueWithoutUtilisateurInput | tachesUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: tachesUpdateManyWithWhereWithoutUtilisateurInput | tachesUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: tachesScalarWhereInput | tachesScalarWhereInput[]
  }

  export type GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput = {
    create?: XOR<GroupesUtilisateursCreateWithoutUtilisateursInput, GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput> | GroupesUtilisateursCreateWithoutUtilisateursInput[] | GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput[]
    connectOrCreate?: GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput | GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput[]
    upsert?: GroupesUtilisateursUpsertWithWhereUniqueWithoutUtilisateursInput | GroupesUtilisateursUpsertWithWhereUniqueWithoutUtilisateursInput[]
    createMany?: GroupesUtilisateursCreateManyUtilisateursInputEnvelope
    set?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    disconnect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    delete?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    connect?: GroupesUtilisateursWhereUniqueInput | GroupesUtilisateursWhereUniqueInput[]
    update?: GroupesUtilisateursUpdateWithWhereUniqueWithoutUtilisateursInput | GroupesUtilisateursUpdateWithWhereUniqueWithoutUtilisateursInput[]
    updateMany?: GroupesUtilisateursUpdateManyWithWhereWithoutUtilisateursInput | GroupesUtilisateursUpdateManyWithWhereWithoutUtilisateursInput[]
    deleteMany?: GroupesUtilisateursScalarWhereInput | GroupesUtilisateursScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUserInput | notificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUserInput | notificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUserInput | notificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type comptesCreateNestedOneWithoutVotesInput = {
    create?: XOR<comptesCreateWithoutVotesInput, comptesUncheckedCreateWithoutVotesInput>
    connectOrCreate?: comptesCreateOrConnectWithoutVotesInput
    connect?: comptesWhereUniqueInput
  }

  export type comptesUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<comptesCreateWithoutVotesInput, comptesUncheckedCreateWithoutVotesInput>
    connectOrCreate?: comptesCreateOrConnectWithoutVotesInput
    upsert?: comptesUpsertWithoutVotesInput
    connect?: comptesWhereUniqueInput
    update?: XOR<XOR<comptesUpdateToOneWithWhereWithoutVotesInput, comptesUpdateWithoutVotesInput>, comptesUncheckedUpdateWithoutVotesInput>
  }

  export type utilisateursCreateNestedOneWithoutNotificationInput = {
    create?: XOR<utilisateursCreateWithoutNotificationInput, utilisateursUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutNotificationInput
    connect?: utilisateursWhereUniqueInput
  }

  export type groupesCreateNestedOneWithoutNotificationInput = {
    create?: XOR<groupesCreateWithoutNotificationInput, groupesUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: groupesCreateOrConnectWithoutNotificationInput
    connect?: groupesWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type utilisateursUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<utilisateursCreateWithoutNotificationInput, utilisateursUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: utilisateursCreateOrConnectWithoutNotificationInput
    upsert?: utilisateursUpsertWithoutNotificationInput
    disconnect?: utilisateursWhereInput | boolean
    delete?: utilisateursWhereInput | boolean
    connect?: utilisateursWhereUniqueInput
    update?: XOR<XOR<utilisateursUpdateToOneWithWhereWithoutNotificationInput, utilisateursUpdateWithoutNotificationInput>, utilisateursUncheckedUpdateWithoutNotificationInput>
  }

  export type groupesUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<groupesCreateWithoutNotificationInput, groupesUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: groupesCreateOrConnectWithoutNotificationInput
    upsert?: groupesUpsertWithoutNotificationInput
    disconnect?: groupesWhereInput | boolean
    delete?: groupesWhereInput | boolean
    connect?: groupesWhereUniqueInput
    update?: XOR<XOR<groupesUpdateToOneWithWhereWithoutNotificationInput, groupesUpdateWithoutNotificationInput>, groupesUncheckedUpdateWithoutNotificationInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumcomptes_validityFilter<$PrismaModel = never> = {
    equals?: $Enums.comptes_validity | Enumcomptes_validityFieldRefInput<$PrismaModel>
    in?: $Enums.comptes_validity[]
    notIn?: $Enums.comptes_validity[]
    not?: NestedEnumcomptes_validityFilter<$PrismaModel> | $Enums.comptes_validity
  }

  export type NestedEnumcomptes_validityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.comptes_validity | Enumcomptes_validityFieldRefInput<$PrismaModel>
    in?: $Enums.comptes_validity[]
    notIn?: $Enums.comptes_validity[]
    not?: NestedEnumcomptes_validityWithAggregatesFilter<$PrismaModel> | $Enums.comptes_validity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcomptes_validityFilter<$PrismaModel>
    _max?: NestedEnumcomptes_validityFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type actualitesCreateWithoutActualite_imagesInput = {
    title: string
    content: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type actualitesUncheckedCreateWithoutActualite_imagesInput = {
    id?: number
    title: string
    content: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type actualitesCreateOrConnectWithoutActualite_imagesInput = {
    where: actualitesWhereUniqueInput
    create: XOR<actualitesCreateWithoutActualite_imagesInput, actualitesUncheckedCreateWithoutActualite_imagesInput>
  }

  export type actualitesUpsertWithoutActualite_imagesInput = {
    update: XOR<actualitesUpdateWithoutActualite_imagesInput, actualitesUncheckedUpdateWithoutActualite_imagesInput>
    create: XOR<actualitesCreateWithoutActualite_imagesInput, actualitesUncheckedCreateWithoutActualite_imagesInput>
    where?: actualitesWhereInput
  }

  export type actualitesUpdateToOneWithWhereWithoutActualite_imagesInput = {
    where?: actualitesWhereInput
    data: XOR<actualitesUpdateWithoutActualite_imagesInput, actualitesUncheckedUpdateWithoutActualite_imagesInput>
  }

  export type actualitesUpdateWithoutActualite_imagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type actualitesUncheckedUpdateWithoutActualite_imagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type actualite_imagesCreateWithoutActualitesInput = {
    image_url: string
  }

  export type actualite_imagesUncheckedCreateWithoutActualitesInput = {
    id?: number
    image_url: string
  }

  export type actualite_imagesCreateOrConnectWithoutActualitesInput = {
    where: actualite_imagesWhereUniqueInput
    create: XOR<actualite_imagesCreateWithoutActualitesInput, actualite_imagesUncheckedCreateWithoutActualitesInput>
  }

  export type actualite_imagesCreateManyActualitesInputEnvelope = {
    data: actualite_imagesCreateManyActualitesInput | actualite_imagesCreateManyActualitesInput[]
    skipDuplicates?: boolean
  }

  export type actualite_imagesUpsertWithWhereUniqueWithoutActualitesInput = {
    where: actualite_imagesWhereUniqueInput
    update: XOR<actualite_imagesUpdateWithoutActualitesInput, actualite_imagesUncheckedUpdateWithoutActualitesInput>
    create: XOR<actualite_imagesCreateWithoutActualitesInput, actualite_imagesUncheckedCreateWithoutActualitesInput>
  }

  export type actualite_imagesUpdateWithWhereUniqueWithoutActualitesInput = {
    where: actualite_imagesWhereUniqueInput
    data: XOR<actualite_imagesUpdateWithoutActualitesInput, actualite_imagesUncheckedUpdateWithoutActualitesInput>
  }

  export type actualite_imagesUpdateManyWithWhereWithoutActualitesInput = {
    where: actualite_imagesScalarWhereInput
    data: XOR<actualite_imagesUpdateManyMutationInput, actualite_imagesUncheckedUpdateManyWithoutActualitesInput>
  }

  export type actualite_imagesScalarWhereInput = {
    AND?: actualite_imagesScalarWhereInput | actualite_imagesScalarWhereInput[]
    OR?: actualite_imagesScalarWhereInput[]
    NOT?: actualite_imagesScalarWhereInput | actualite_imagesScalarWhereInput[]
    id?: IntFilter<"actualite_images"> | number
    actualite_id?: IntFilter<"actualite_images"> | number
    image_url?: StringFilter<"actualite_images"> | string
  }

  export type plans_actionCreateWithoutAxesInput = {
    name: string
    description?: string | null
    objectif?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type plans_actionUncheckedCreateWithoutAxesInput = {
    id?: number
    name: string
    description?: string | null
    objectif?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type plans_actionCreateOrConnectWithoutAxesInput = {
    where: plans_actionWhereUniqueInput
    create: XOR<plans_actionCreateWithoutAxesInput, plans_actionUncheckedCreateWithoutAxesInput>
  }

  export type projetsCreateWithoutAxesInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutAxesInput = {
    id?: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutAxesInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutAxesInput, projetsUncheckedCreateWithoutAxesInput>
  }

  export type projetsCreateManyAxesInputEnvelope = {
    data: projetsCreateManyAxesInput | projetsCreateManyAxesInput[]
    skipDuplicates?: boolean
  }

  export type plans_actionUpsertWithoutAxesInput = {
    update: XOR<plans_actionUpdateWithoutAxesInput, plans_actionUncheckedUpdateWithoutAxesInput>
    create: XOR<plans_actionCreateWithoutAxesInput, plans_actionUncheckedCreateWithoutAxesInput>
    where?: plans_actionWhereInput
  }

  export type plans_actionUpdateToOneWithWhereWithoutAxesInput = {
    where?: plans_actionWhereInput
    data: XOR<plans_actionUpdateWithoutAxesInput, plans_actionUncheckedUpdateWithoutAxesInput>
  }

  export type plans_actionUpdateWithoutAxesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type plans_actionUncheckedUpdateWithoutAxesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projetsUpsertWithWhereUniqueWithoutAxesInput = {
    where: projetsWhereUniqueInput
    update: XOR<projetsUpdateWithoutAxesInput, projetsUncheckedUpdateWithoutAxesInput>
    create: XOR<projetsCreateWithoutAxesInput, projetsUncheckedCreateWithoutAxesInput>
  }

  export type projetsUpdateWithWhereUniqueWithoutAxesInput = {
    where: projetsWhereUniqueInput
    data: XOR<projetsUpdateWithoutAxesInput, projetsUncheckedUpdateWithoutAxesInput>
  }

  export type projetsUpdateManyWithWhereWithoutAxesInput = {
    where: projetsScalarWhereInput
    data: XOR<projetsUpdateManyMutationInput, projetsUncheckedUpdateManyWithoutAxesInput>
  }

  export type projetsScalarWhereInput = {
    AND?: projetsScalarWhereInput | projetsScalarWhereInput[]
    OR?: projetsScalarWhereInput[]
    NOT?: projetsScalarWhereInput | projetsScalarWhereInput[]
    id?: IntFilter<"projets"> | number
    axe_id?: IntFilter<"projets"> | number
    priority_id?: IntNullableFilter<"projets"> | number | null
    manager?: IntNullableFilter<"projets"> | number | null
    name?: StringFilter<"projets"> | string
    description?: StringNullableFilter<"projets"> | string | null
    objectif?: StringNullableFilter<"projets"> | string | null
    statut?: StringNullableFilter<"projets"> | string | null
    budget?: IntNullableFilter<"projets"> | number | null
    start_date?: DateTimeNullableFilter<"projets"> | Date | string | null
    end_date?: DateTimeNullableFilter<"projets"> | Date | string | null
    created_date?: DateTimeFilter<"projets"> | Date | string
    last_updated?: DateTimeFilter<"projets"> | Date | string
    target_value?: FloatNullableFilter<"projets"> | number | null
    current_value?: FloatNullableFilter<"projets"> | number | null
  }

  export type utilisateursCreateWithoutCategory_userInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateWithoutCategory_userInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursCreateOrConnectWithoutCategory_userInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutCategory_userInput, utilisateursUncheckedCreateWithoutCategory_userInput>
  }

  export type utilisateursCreateManyCategory_userInputEnvelope = {
    data: utilisateursCreateManyCategory_userInput | utilisateursCreateManyCategory_userInput[]
    skipDuplicates?: boolean
  }

  export type utilisateursUpsertWithWhereUniqueWithoutCategory_userInput = {
    where: utilisateursWhereUniqueInput
    update: XOR<utilisateursUpdateWithoutCategory_userInput, utilisateursUncheckedUpdateWithoutCategory_userInput>
    create: XOR<utilisateursCreateWithoutCategory_userInput, utilisateursUncheckedCreateWithoutCategory_userInput>
  }

  export type utilisateursUpdateWithWhereUniqueWithoutCategory_userInput = {
    where: utilisateursWhereUniqueInput
    data: XOR<utilisateursUpdateWithoutCategory_userInput, utilisateursUncheckedUpdateWithoutCategory_userInput>
  }

  export type utilisateursUpdateManyWithWhereWithoutCategory_userInput = {
    where: utilisateursScalarWhereInput
    data: XOR<utilisateursUpdateManyMutationInput, utilisateursUncheckedUpdateManyWithoutCategory_userInput>
  }

  export type utilisateursScalarWhereInput = {
    AND?: utilisateursScalarWhereInput | utilisateursScalarWhereInput[]
    OR?: utilisateursScalarWhereInput[]
    NOT?: utilisateursScalarWhereInput | utilisateursScalarWhereInput[]
    id?: IntFilter<"utilisateurs"> | number
    nom?: StringFilter<"utilisateurs"> | string
    prenom?: StringFilter<"utilisateurs"> | string
    email?: StringFilter<"utilisateurs"> | string
    category_id?: IntNullableFilter<"utilisateurs"> | number | null
    created_at?: DateTimeFilter<"utilisateurs"> | Date | string
  }

  export type projetsCreateWithoutCommentairesInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutCommentairesInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutCommentairesInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutCommentairesInput, projetsUncheckedCreateWithoutCommentairesInput>
  }

  export type comptesCreateWithoutCommentairesInput = {
    username: string
    password: string
    validity?: $Enums.comptes_validity
    utilisateurs?: utilisateursCreateNestedOneWithoutComptesInput
    roles: rolesCreateNestedOneWithoutComptesInput
    suggestions?: suggestionsCreateNestedManyWithoutComptesInput
    votes?: votesCreateNestedManyWithoutComptesInput
  }

  export type comptesUncheckedCreateWithoutCommentairesInput = {
    id?: number
    username: string
    password: string
    role_id: number
    validity?: $Enums.comptes_validity
    user_id?: number | null
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutComptesInput
    votes?: votesUncheckedCreateNestedManyWithoutComptesInput
  }

  export type comptesCreateOrConnectWithoutCommentairesInput = {
    where: comptesWhereUniqueInput
    create: XOR<comptesCreateWithoutCommentairesInput, comptesUncheckedCreateWithoutCommentairesInput>
  }

  export type projetsUpsertWithoutCommentairesInput = {
    update: XOR<projetsUpdateWithoutCommentairesInput, projetsUncheckedUpdateWithoutCommentairesInput>
    create: XOR<projetsCreateWithoutCommentairesInput, projetsUncheckedCreateWithoutCommentairesInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutCommentairesInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutCommentairesInput, projetsUncheckedUpdateWithoutCommentairesInput>
  }

  export type projetsUpdateWithoutCommentairesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutCommentairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type comptesUpsertWithoutCommentairesInput = {
    update: XOR<comptesUpdateWithoutCommentairesInput, comptesUncheckedUpdateWithoutCommentairesInput>
    create: XOR<comptesCreateWithoutCommentairesInput, comptesUncheckedCreateWithoutCommentairesInput>
    where?: comptesWhereInput
  }

  export type comptesUpdateToOneWithWhereWithoutCommentairesInput = {
    where?: comptesWhereInput
    data: XOR<comptesUpdateWithoutCommentairesInput, comptesUncheckedUpdateWithoutCommentairesInput>
  }

  export type comptesUpdateWithoutCommentairesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    utilisateurs?: utilisateursUpdateOneWithoutComptesNestedInput
    roles?: rolesUpdateOneRequiredWithoutComptesNestedInput
    suggestions?: suggestionsUpdateManyWithoutComptesNestedInput
    votes?: votesUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateWithoutCommentairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    suggestions?: suggestionsUncheckedUpdateManyWithoutComptesNestedInput
    votes?: votesUncheckedUpdateManyWithoutComptesNestedInput
  }

  export type commentairesCreateWithoutComptesInput = {
    content: string
    created_at?: Date | string
    projets: projetsCreateNestedOneWithoutCommentairesInput
  }

  export type commentairesUncheckedCreateWithoutComptesInput = {
    id?: number
    project_id: number
    content: string
    created_at?: Date | string
  }

  export type commentairesCreateOrConnectWithoutComptesInput = {
    where: commentairesWhereUniqueInput
    create: XOR<commentairesCreateWithoutComptesInput, commentairesUncheckedCreateWithoutComptesInput>
  }

  export type commentairesCreateManyComptesInputEnvelope = {
    data: commentairesCreateManyComptesInput | commentairesCreateManyComptesInput[]
    skipDuplicates?: boolean
  }

  export type utilisateursCreateWithoutComptesInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateWithoutComptesInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursCreateOrConnectWithoutComptesInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutComptesInput, utilisateursUncheckedCreateWithoutComptesInput>
  }

  export type rolesCreateWithoutComptesInput = {
    nom: string
    created_date?: Date | string
    last_updated?: Date | string
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutComptesInput = {
    id?: number
    nom: string
    created_date?: Date | string
    last_updated?: Date | string
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutComptesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutComptesInput, rolesUncheckedCreateWithoutComptesInput>
  }

  export type suggestionsCreateWithoutComptesInput = {
    suggestion_content: string
    submitted_at?: Date | string
    projets: projetsCreateNestedOneWithoutSuggestionsInput
  }

  export type suggestionsUncheckedCreateWithoutComptesInput = {
    id?: number
    project_id: number
    suggestion_content: string
    submitted_at?: Date | string
  }

  export type suggestionsCreateOrConnectWithoutComptesInput = {
    where: suggestionsWhereUniqueInput
    create: XOR<suggestionsCreateWithoutComptesInput, suggestionsUncheckedCreateWithoutComptesInput>
  }

  export type suggestionsCreateManyComptesInputEnvelope = {
    data: suggestionsCreateManyComptesInput | suggestionsCreateManyComptesInput[]
    skipDuplicates?: boolean
  }

  export type votesCreateWithoutComptesInput = {
    vote_value?: number | null
    voted_at?: Date | string
  }

  export type votesUncheckedCreateWithoutComptesInput = {
    id?: number
    vote_value?: number | null
    voted_at?: Date | string
  }

  export type votesCreateOrConnectWithoutComptesInput = {
    where: votesWhereUniqueInput
    create: XOR<votesCreateWithoutComptesInput, votesUncheckedCreateWithoutComptesInput>
  }

  export type votesCreateManyComptesInputEnvelope = {
    data: votesCreateManyComptesInput | votesCreateManyComptesInput[]
    skipDuplicates?: boolean
  }

  export type commentairesUpsertWithWhereUniqueWithoutComptesInput = {
    where: commentairesWhereUniqueInput
    update: XOR<commentairesUpdateWithoutComptesInput, commentairesUncheckedUpdateWithoutComptesInput>
    create: XOR<commentairesCreateWithoutComptesInput, commentairesUncheckedCreateWithoutComptesInput>
  }

  export type commentairesUpdateWithWhereUniqueWithoutComptesInput = {
    where: commentairesWhereUniqueInput
    data: XOR<commentairesUpdateWithoutComptesInput, commentairesUncheckedUpdateWithoutComptesInput>
  }

  export type commentairesUpdateManyWithWhereWithoutComptesInput = {
    where: commentairesScalarWhereInput
    data: XOR<commentairesUpdateManyMutationInput, commentairesUncheckedUpdateManyWithoutComptesInput>
  }

  export type commentairesScalarWhereInput = {
    AND?: commentairesScalarWhereInput | commentairesScalarWhereInput[]
    OR?: commentairesScalarWhereInput[]
    NOT?: commentairesScalarWhereInput | commentairesScalarWhereInput[]
    id?: IntFilter<"commentaires"> | number
    project_id?: IntFilter<"commentaires"> | number
    compte_id?: IntFilter<"commentaires"> | number
    content?: StringFilter<"commentaires"> | string
    created_at?: DateTimeFilter<"commentaires"> | Date | string
  }

  export type utilisateursUpsertWithoutComptesInput = {
    update: XOR<utilisateursUpdateWithoutComptesInput, utilisateursUncheckedUpdateWithoutComptesInput>
    create: XOR<utilisateursCreateWithoutComptesInput, utilisateursUncheckedCreateWithoutComptesInput>
    where?: utilisateursWhereInput
  }

  export type utilisateursUpdateToOneWithWhereWithoutComptesInput = {
    where?: utilisateursWhereInput
    data: XOR<utilisateursUpdateWithoutComptesInput, utilisateursUncheckedUpdateWithoutComptesInput>
  }

  export type utilisateursUpdateWithoutComptesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rolesUpsertWithoutComptesInput = {
    update: XOR<rolesUpdateWithoutComptesInput, rolesUncheckedUpdateWithoutComptesInput>
    create: XOR<rolesCreateWithoutComptesInput, rolesUncheckedCreateWithoutComptesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutComptesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutComptesInput, rolesUncheckedUpdateWithoutComptesInput>
  }

  export type rolesUpdateWithoutComptesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type suggestionsUpsertWithWhereUniqueWithoutComptesInput = {
    where: suggestionsWhereUniqueInput
    update: XOR<suggestionsUpdateWithoutComptesInput, suggestionsUncheckedUpdateWithoutComptesInput>
    create: XOR<suggestionsCreateWithoutComptesInput, suggestionsUncheckedCreateWithoutComptesInput>
  }

  export type suggestionsUpdateWithWhereUniqueWithoutComptesInput = {
    where: suggestionsWhereUniqueInput
    data: XOR<suggestionsUpdateWithoutComptesInput, suggestionsUncheckedUpdateWithoutComptesInput>
  }

  export type suggestionsUpdateManyWithWhereWithoutComptesInput = {
    where: suggestionsScalarWhereInput
    data: XOR<suggestionsUpdateManyMutationInput, suggestionsUncheckedUpdateManyWithoutComptesInput>
  }

  export type suggestionsScalarWhereInput = {
    AND?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
    OR?: suggestionsScalarWhereInput[]
    NOT?: suggestionsScalarWhereInput | suggestionsScalarWhereInput[]
    id?: IntFilter<"suggestions"> | number
    compte_id?: IntFilter<"suggestions"> | number
    project_id?: IntFilter<"suggestions"> | number
    suggestion_content?: StringFilter<"suggestions"> | string
    submitted_at?: DateTimeFilter<"suggestions"> | Date | string
  }

  export type votesUpsertWithWhereUniqueWithoutComptesInput = {
    where: votesWhereUniqueInput
    update: XOR<votesUpdateWithoutComptesInput, votesUncheckedUpdateWithoutComptesInput>
    create: XOR<votesCreateWithoutComptesInput, votesUncheckedCreateWithoutComptesInput>
  }

  export type votesUpdateWithWhereUniqueWithoutComptesInput = {
    where: votesWhereUniqueInput
    data: XOR<votesUpdateWithoutComptesInput, votesUncheckedUpdateWithoutComptesInput>
  }

  export type votesUpdateManyWithWhereWithoutComptesInput = {
    where: votesScalarWhereInput
    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutComptesInput>
  }

  export type votesScalarWhereInput = {
    AND?: votesScalarWhereInput | votesScalarWhereInput[]
    OR?: votesScalarWhereInput[]
    NOT?: votesScalarWhereInput | votesScalarWhereInput[]
    id?: IntFilter<"votes"> | number
    compte_id?: IntFilter<"votes"> | number
    vote_value?: IntNullableFilter<"votes"> | number | null
    voted_at?: DateTimeFilter<"votes"> | Date | string
  }

  export type projetsCreateWithoutDocumentsInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutDocumentsInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutDocumentsInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutDocumentsInput, projetsUncheckedCreateWithoutDocumentsInput>
  }

  export type projetsUpsertWithoutDocumentsInput = {
    update: XOR<projetsUpdateWithoutDocumentsInput, projetsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<projetsCreateWithoutDocumentsInput, projetsUncheckedCreateWithoutDocumentsInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutDocumentsInput, projetsUncheckedUpdateWithoutDocumentsInput>
  }

  export type projetsUpdateWithoutDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type indicateursCreateWithoutEvaluationsInput = {
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
    projets: projetsCreateNestedOneWithoutIndicateursInput
  }

  export type indicateursUncheckedCreateWithoutEvaluationsInput = {
    id?: number
    project_id: number
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type indicateursCreateOrConnectWithoutEvaluationsInput = {
    where: indicateursWhereUniqueInput
    create: XOR<indicateursCreateWithoutEvaluationsInput, indicateursUncheckedCreateWithoutEvaluationsInput>
  }

  export type indicateursUpsertWithoutEvaluationsInput = {
    update: XOR<indicateursUpdateWithoutEvaluationsInput, indicateursUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<indicateursCreateWithoutEvaluationsInput, indicateursUncheckedCreateWithoutEvaluationsInput>
    where?: indicateursWhereInput
  }

  export type indicateursUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: indicateursWhereInput
    data: XOR<indicateursUpdateWithoutEvaluationsInput, indicateursUncheckedUpdateWithoutEvaluationsInput>
  }

  export type indicateursUpdateWithoutEvaluationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUpdateOneRequiredWithoutIndicateursNestedInput
  }

  export type indicateursUncheckedUpdateWithoutEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_groupesCreateWithoutGroupesInput = {
    projets: projetsCreateNestedOneWithoutProjet_groupesInput
  }

  export type projet_groupesUncheckedCreateWithoutGroupesInput = {
    projet_id: number
  }

  export type projet_groupesCreateOrConnectWithoutGroupesInput = {
    where: projet_groupesWhereUniqueInput
    create: XOR<projet_groupesCreateWithoutGroupesInput, projet_groupesUncheckedCreateWithoutGroupesInput>
  }

  export type projet_groupesCreateManyGroupesInputEnvelope = {
    data: projet_groupesCreateManyGroupesInput | projet_groupesCreateManyGroupesInput[]
    skipDuplicates?: boolean
  }

  export type tache_assignations_groupesCreateWithoutGroupesInput = {
    taches: tachesCreateNestedOneWithoutTache_assignations_groupesInput
  }

  export type tache_assignations_groupesUncheckedCreateWithoutGroupesInput = {
    tache_id: number
  }

  export type tache_assignations_groupesCreateOrConnectWithoutGroupesInput = {
    where: tache_assignations_groupesWhereUniqueInput
    create: XOR<tache_assignations_groupesCreateWithoutGroupesInput, tache_assignations_groupesUncheckedCreateWithoutGroupesInput>
  }

  export type tache_assignations_groupesCreateManyGroupesInputEnvelope = {
    data: tache_assignations_groupesCreateManyGroupesInput | tache_assignations_groupesCreateManyGroupesInput[]
    skipDuplicates?: boolean
  }

  export type GroupesUtilisateursCreateWithoutGroupesInput = {
    utilisateurs: utilisateursCreateNestedOneWithoutGroupesUtilisateursInput
  }

  export type GroupesUtilisateursUncheckedCreateWithoutGroupesInput = {
    utilisateur_id: number
  }

  export type GroupesUtilisateursCreateOrConnectWithoutGroupesInput = {
    where: GroupesUtilisateursWhereUniqueInput
    create: XOR<GroupesUtilisateursCreateWithoutGroupesInput, GroupesUtilisateursUncheckedCreateWithoutGroupesInput>
  }

  export type GroupesUtilisateursCreateManyGroupesInputEnvelope = {
    data: GroupesUtilisateursCreateManyGroupesInput | GroupesUtilisateursCreateManyGroupesInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutGroupeInput = {
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    user?: utilisateursCreateNestedOneWithoutNotificationInput
  }

  export type notificationsUncheckedCreateWithoutGroupeInput = {
    id?: number
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    userId?: number | null
  }

  export type notificationsCreateOrConnectWithoutGroupeInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutGroupeInput, notificationsUncheckedCreateWithoutGroupeInput>
  }

  export type notificationsCreateManyGroupeInputEnvelope = {
    data: notificationsCreateManyGroupeInput | notificationsCreateManyGroupeInput[]
    skipDuplicates?: boolean
  }

  export type projet_groupesUpsertWithWhereUniqueWithoutGroupesInput = {
    where: projet_groupesWhereUniqueInput
    update: XOR<projet_groupesUpdateWithoutGroupesInput, projet_groupesUncheckedUpdateWithoutGroupesInput>
    create: XOR<projet_groupesCreateWithoutGroupesInput, projet_groupesUncheckedCreateWithoutGroupesInput>
  }

  export type projet_groupesUpdateWithWhereUniqueWithoutGroupesInput = {
    where: projet_groupesWhereUniqueInput
    data: XOR<projet_groupesUpdateWithoutGroupesInput, projet_groupesUncheckedUpdateWithoutGroupesInput>
  }

  export type projet_groupesUpdateManyWithWhereWithoutGroupesInput = {
    where: projet_groupesScalarWhereInput
    data: XOR<projet_groupesUpdateManyMutationInput, projet_groupesUncheckedUpdateManyWithoutGroupesInput>
  }

  export type projet_groupesScalarWhereInput = {
    AND?: projet_groupesScalarWhereInput | projet_groupesScalarWhereInput[]
    OR?: projet_groupesScalarWhereInput[]
    NOT?: projet_groupesScalarWhereInput | projet_groupesScalarWhereInput[]
    projet_id?: IntFilter<"projet_groupes"> | number
    groupe_id?: IntFilter<"projet_groupes"> | number
  }

  export type tache_assignations_groupesUpsertWithWhereUniqueWithoutGroupesInput = {
    where: tache_assignations_groupesWhereUniqueInput
    update: XOR<tache_assignations_groupesUpdateWithoutGroupesInput, tache_assignations_groupesUncheckedUpdateWithoutGroupesInput>
    create: XOR<tache_assignations_groupesCreateWithoutGroupesInput, tache_assignations_groupesUncheckedCreateWithoutGroupesInput>
  }

  export type tache_assignations_groupesUpdateWithWhereUniqueWithoutGroupesInput = {
    where: tache_assignations_groupesWhereUniqueInput
    data: XOR<tache_assignations_groupesUpdateWithoutGroupesInput, tache_assignations_groupesUncheckedUpdateWithoutGroupesInput>
  }

  export type tache_assignations_groupesUpdateManyWithWhereWithoutGroupesInput = {
    where: tache_assignations_groupesScalarWhereInput
    data: XOR<tache_assignations_groupesUpdateManyMutationInput, tache_assignations_groupesUncheckedUpdateManyWithoutGroupesInput>
  }

  export type tache_assignations_groupesScalarWhereInput = {
    AND?: tache_assignations_groupesScalarWhereInput | tache_assignations_groupesScalarWhereInput[]
    OR?: tache_assignations_groupesScalarWhereInput[]
    NOT?: tache_assignations_groupesScalarWhereInput | tache_assignations_groupesScalarWhereInput[]
    tache_id?: IntFilter<"tache_assignations_groupes"> | number
    groupe_id?: IntFilter<"tache_assignations_groupes"> | number
  }

  export type GroupesUtilisateursUpsertWithWhereUniqueWithoutGroupesInput = {
    where: GroupesUtilisateursWhereUniqueInput
    update: XOR<GroupesUtilisateursUpdateWithoutGroupesInput, GroupesUtilisateursUncheckedUpdateWithoutGroupesInput>
    create: XOR<GroupesUtilisateursCreateWithoutGroupesInput, GroupesUtilisateursUncheckedCreateWithoutGroupesInput>
  }

  export type GroupesUtilisateursUpdateWithWhereUniqueWithoutGroupesInput = {
    where: GroupesUtilisateursWhereUniqueInput
    data: XOR<GroupesUtilisateursUpdateWithoutGroupesInput, GroupesUtilisateursUncheckedUpdateWithoutGroupesInput>
  }

  export type GroupesUtilisateursUpdateManyWithWhereWithoutGroupesInput = {
    where: GroupesUtilisateursScalarWhereInput
    data: XOR<GroupesUtilisateursUpdateManyMutationInput, GroupesUtilisateursUncheckedUpdateManyWithoutGroupesInput>
  }

  export type GroupesUtilisateursScalarWhereInput = {
    AND?: GroupesUtilisateursScalarWhereInput | GroupesUtilisateursScalarWhereInput[]
    OR?: GroupesUtilisateursScalarWhereInput[]
    NOT?: GroupesUtilisateursScalarWhereInput | GroupesUtilisateursScalarWhereInput[]
    groupe_id?: IntFilter<"GroupesUtilisateurs"> | number
    utilisateur_id?: IntFilter<"GroupesUtilisateurs"> | number
  }

  export type notificationsUpsertWithWhereUniqueWithoutGroupeInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutGroupeInput, notificationsUncheckedUpdateWithoutGroupeInput>
    create: XOR<notificationsCreateWithoutGroupeInput, notificationsUncheckedCreateWithoutGroupeInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutGroupeInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutGroupeInput, notificationsUncheckedUpdateWithoutGroupeInput>
  }

  export type notificationsUpdateManyWithWhereWithoutGroupeInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutGroupeInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: IntFilter<"notifications"> | number
    titre?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: IntNullableFilter<"notifications"> | number | null
    groupeId?: IntNullableFilter<"notifications"> | number | null
  }

  export type evaluationsCreateWithoutIndicateursInput = {
    evaluation_date?: Date | string | null
    value?: number | null
    comment?: string | null
  }

  export type evaluationsUncheckedCreateWithoutIndicateursInput = {
    id?: number
    evaluation_date?: Date | string | null
    value?: number | null
    comment?: string | null
  }

  export type evaluationsCreateOrConnectWithoutIndicateursInput = {
    where: evaluationsWhereUniqueInput
    create: XOR<evaluationsCreateWithoutIndicateursInput, evaluationsUncheckedCreateWithoutIndicateursInput>
  }

  export type evaluationsCreateManyIndicateursInputEnvelope = {
    data: evaluationsCreateManyIndicateursInput | evaluationsCreateManyIndicateursInput[]
    skipDuplicates?: boolean
  }

  export type projetsCreateWithoutIndicateursInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutIndicateursInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutIndicateursInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutIndicateursInput, projetsUncheckedCreateWithoutIndicateursInput>
  }

  export type evaluationsUpsertWithWhereUniqueWithoutIndicateursInput = {
    where: evaluationsWhereUniqueInput
    update: XOR<evaluationsUpdateWithoutIndicateursInput, evaluationsUncheckedUpdateWithoutIndicateursInput>
    create: XOR<evaluationsCreateWithoutIndicateursInput, evaluationsUncheckedCreateWithoutIndicateursInput>
  }

  export type evaluationsUpdateWithWhereUniqueWithoutIndicateursInput = {
    where: evaluationsWhereUniqueInput
    data: XOR<evaluationsUpdateWithoutIndicateursInput, evaluationsUncheckedUpdateWithoutIndicateursInput>
  }

  export type evaluationsUpdateManyWithWhereWithoutIndicateursInput = {
    where: evaluationsScalarWhereInput
    data: XOR<evaluationsUpdateManyMutationInput, evaluationsUncheckedUpdateManyWithoutIndicateursInput>
  }

  export type evaluationsScalarWhereInput = {
    AND?: evaluationsScalarWhereInput | evaluationsScalarWhereInput[]
    OR?: evaluationsScalarWhereInput[]
    NOT?: evaluationsScalarWhereInput | evaluationsScalarWhereInput[]
    id?: IntFilter<"evaluations"> | number
    indicator_id?: IntFilter<"evaluations"> | number
    evaluation_date?: DateTimeNullableFilter<"evaluations"> | Date | string | null
    value?: FloatNullableFilter<"evaluations"> | number | null
    comment?: StringNullableFilter<"evaluations"> | string | null
  }

  export type projetsUpsertWithoutIndicateursInput = {
    update: XOR<projetsUpdateWithoutIndicateursInput, projetsUncheckedUpdateWithoutIndicateursInput>
    create: XOR<projetsCreateWithoutIndicateursInput, projetsUncheckedCreateWithoutIndicateursInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutIndicateursInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutIndicateursInput, projetsUncheckedUpdateWithoutIndicateursInput>
  }

  export type projetsUpdateWithoutIndicateursInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutIndicateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type groupesCreateWithoutGroupesUtilisateursInput = {
    nom: string
    projet_groupes?: projet_groupesCreateNestedManyWithoutGroupesInput
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutGroupesInput
    Notification?: notificationsCreateNestedManyWithoutGroupeInput
  }

  export type groupesUncheckedCreateWithoutGroupesUtilisateursInput = {
    id?: number
    nom: string
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutGroupesInput
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutGroupesInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutGroupeInput
  }

  export type groupesCreateOrConnectWithoutGroupesUtilisateursInput = {
    where: groupesWhereUniqueInput
    create: XOR<groupesCreateWithoutGroupesUtilisateursInput, groupesUncheckedCreateWithoutGroupesUtilisateursInput>
  }

  export type utilisateursCreateWithoutGroupesUtilisateursInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateWithoutGroupesUtilisateursInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursCreateOrConnectWithoutGroupesUtilisateursInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutGroupesUtilisateursInput, utilisateursUncheckedCreateWithoutGroupesUtilisateursInput>
  }

  export type groupesUpsertWithoutGroupesUtilisateursInput = {
    update: XOR<groupesUpdateWithoutGroupesUtilisateursInput, groupesUncheckedUpdateWithoutGroupesUtilisateursInput>
    create: XOR<groupesCreateWithoutGroupesUtilisateursInput, groupesUncheckedCreateWithoutGroupesUtilisateursInput>
    where?: groupesWhereInput
  }

  export type groupesUpdateToOneWithWhereWithoutGroupesUtilisateursInput = {
    where?: groupesWhereInput
    data: XOR<groupesUpdateWithoutGroupesUtilisateursInput, groupesUncheckedUpdateWithoutGroupesUtilisateursInput>
  }

  export type groupesUpdateWithoutGroupesUtilisateursInput = {
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUpdateManyWithoutGroupesNestedInput
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUpdateManyWithoutGroupeNestedInput
  }

  export type groupesUncheckedUpdateWithoutGroupesUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutGroupeNestedInput
  }

  export type utilisateursUpsertWithoutGroupesUtilisateursInput = {
    update: XOR<utilisateursUpdateWithoutGroupesUtilisateursInput, utilisateursUncheckedUpdateWithoutGroupesUtilisateursInput>
    create: XOR<utilisateursCreateWithoutGroupesUtilisateursInput, utilisateursUncheckedCreateWithoutGroupesUtilisateursInput>
    where?: utilisateursWhereInput
  }

  export type utilisateursUpdateToOneWithWhereWithoutGroupesUtilisateursInput = {
    where?: utilisateursWhereInput
    data: XOR<utilisateursUpdateWithoutGroupesUtilisateursInput, utilisateursUncheckedUpdateWithoutGroupesUtilisateursInput>
  }

  export type utilisateursUpdateWithoutGroupesUtilisateursInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutGroupesUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type role_permissionsCreateWithoutPermissionsInput = {
    roles: rolesCreateNestedOneWithoutRole_permissionsInput
  }

  export type role_permissionsUncheckedCreateWithoutPermissionsInput = {
    role_id: number
  }

  export type role_permissionsCreateOrConnectWithoutPermissionsInput = {
    where: role_permissionsWhereUniqueInput
    create: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_permissionsCreateManyPermissionsInputEnvelope = {
    data: role_permissionsCreateManyPermissionsInput | role_permissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: role_permissionsWhereUniqueInput
    update: XOR<role_permissionsUpdateWithoutPermissionsInput, role_permissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: role_permissionsWhereUniqueInput
    data: XOR<role_permissionsUpdateWithoutPermissionsInput, role_permissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type role_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: role_permissionsScalarWhereInput
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type role_permissionsScalarWhereInput = {
    AND?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
    OR?: role_permissionsScalarWhereInput[]
    NOT?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
    role_id?: IntFilter<"role_permissions"> | number
    permission_id?: IntFilter<"role_permissions"> | number
  }

  export type axesCreateWithoutPlans_actionInput = {
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
    projets?: projetsCreateNestedManyWithoutAxesInput
  }

  export type axesUncheckedCreateWithoutPlans_actionInput = {
    id?: number
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
    projets?: projetsUncheckedCreateNestedManyWithoutAxesInput
  }

  export type axesCreateOrConnectWithoutPlans_actionInput = {
    where: axesWhereUniqueInput
    create: XOR<axesCreateWithoutPlans_actionInput, axesUncheckedCreateWithoutPlans_actionInput>
  }

  export type axesCreateManyPlans_actionInputEnvelope = {
    data: axesCreateManyPlans_actionInput | axesCreateManyPlans_actionInput[]
    skipDuplicates?: boolean
  }

  export type axesUpsertWithWhereUniqueWithoutPlans_actionInput = {
    where: axesWhereUniqueInput
    update: XOR<axesUpdateWithoutPlans_actionInput, axesUncheckedUpdateWithoutPlans_actionInput>
    create: XOR<axesCreateWithoutPlans_actionInput, axesUncheckedCreateWithoutPlans_actionInput>
  }

  export type axesUpdateWithWhereUniqueWithoutPlans_actionInput = {
    where: axesWhereUniqueInput
    data: XOR<axesUpdateWithoutPlans_actionInput, axesUncheckedUpdateWithoutPlans_actionInput>
  }

  export type axesUpdateManyWithWhereWithoutPlans_actionInput = {
    where: axesScalarWhereInput
    data: XOR<axesUpdateManyMutationInput, axesUncheckedUpdateManyWithoutPlans_actionInput>
  }

  export type axesScalarWhereInput = {
    AND?: axesScalarWhereInput | axesScalarWhereInput[]
    OR?: axesScalarWhereInput[]
    NOT?: axesScalarWhereInput | axesScalarWhereInput[]
    id?: IntFilter<"axes"> | number
    plan_id?: IntFilter<"axes"> | number
    name?: StringFilter<"axes"> | string
    description?: StringNullableFilter<"axes"> | string | null
    statut?: StringNullableFilter<"axes"> | string | null
    objectif?: StringNullableFilter<"axes"> | string | null
    created_date?: DateTimeFilter<"axes"> | Date | string
    last_updated?: DateTimeFilter<"axes"> | Date | string
  }

  export type projetsCreateWithoutPriorityInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutPriorityInput = {
    id?: number
    axe_id: number
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutPriorityInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutPriorityInput, projetsUncheckedCreateWithoutPriorityInput>
  }

  export type projetsCreateManyPriorityInputEnvelope = {
    data: projetsCreateManyPriorityInput | projetsCreateManyPriorityInput[]
    skipDuplicates?: boolean
  }

  export type projetsUpsertWithWhereUniqueWithoutPriorityInput = {
    where: projetsWhereUniqueInput
    update: XOR<projetsUpdateWithoutPriorityInput, projetsUncheckedUpdateWithoutPriorityInput>
    create: XOR<projetsCreateWithoutPriorityInput, projetsUncheckedCreateWithoutPriorityInput>
  }

  export type projetsUpdateWithWhereUniqueWithoutPriorityInput = {
    where: projetsWhereUniqueInput
    data: XOR<projetsUpdateWithoutPriorityInput, projetsUncheckedUpdateWithoutPriorityInput>
  }

  export type projetsUpdateManyWithWhereWithoutPriorityInput = {
    where: projetsScalarWhereInput
    data: XOR<projetsUpdateManyMutationInput, projetsUncheckedUpdateManyWithoutPriorityInput>
  }

  export type projetsCreateWithoutProjet_groupesInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutProjet_groupesInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutProjet_groupesInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutProjet_groupesInput, projetsUncheckedCreateWithoutProjet_groupesInput>
  }

  export type groupesCreateWithoutProjet_groupesInput = {
    nom: string
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutGroupesInput
    Notification?: notificationsCreateNestedManyWithoutGroupeInput
  }

  export type groupesUncheckedCreateWithoutProjet_groupesInput = {
    id?: number
    nom: string
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutGroupesInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutGroupeInput
  }

  export type groupesCreateOrConnectWithoutProjet_groupesInput = {
    where: groupesWhereUniqueInput
    create: XOR<groupesCreateWithoutProjet_groupesInput, groupesUncheckedCreateWithoutProjet_groupesInput>
  }

  export type projetsUpsertWithoutProjet_groupesInput = {
    update: XOR<projetsUpdateWithoutProjet_groupesInput, projetsUncheckedUpdateWithoutProjet_groupesInput>
    create: XOR<projetsCreateWithoutProjet_groupesInput, projetsUncheckedCreateWithoutProjet_groupesInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutProjet_groupesInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutProjet_groupesInput, projetsUncheckedUpdateWithoutProjet_groupesInput>
  }

  export type projetsUpdateWithoutProjet_groupesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutProjet_groupesInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type groupesUpsertWithoutProjet_groupesInput = {
    update: XOR<groupesUpdateWithoutProjet_groupesInput, groupesUncheckedUpdateWithoutProjet_groupesInput>
    create: XOR<groupesCreateWithoutProjet_groupesInput, groupesUncheckedCreateWithoutProjet_groupesInput>
    where?: groupesWhereInput
  }

  export type groupesUpdateToOneWithWhereWithoutProjet_groupesInput = {
    where?: groupesWhereInput
    data: XOR<groupesUpdateWithoutProjet_groupesInput, groupesUncheckedUpdateWithoutProjet_groupesInput>
  }

  export type groupesUpdateWithoutProjet_groupesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUpdateManyWithoutGroupeNestedInput
  }

  export type groupesUncheckedUpdateWithoutProjet_groupesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutGroupeNestedInput
  }

  export type projetsCreateWithoutProjet_utilisateursInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutProjet_utilisateursInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutProjet_utilisateursInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutProjet_utilisateursInput, projetsUncheckedCreateWithoutProjet_utilisateursInput>
  }

  export type utilisateursCreateWithoutProjet_utilisateursInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateWithoutProjet_utilisateursInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursCreateOrConnectWithoutProjet_utilisateursInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutProjet_utilisateursInput, utilisateursUncheckedCreateWithoutProjet_utilisateursInput>
  }

  export type projetsUpsertWithoutProjet_utilisateursInput = {
    update: XOR<projetsUpdateWithoutProjet_utilisateursInput, projetsUncheckedUpdateWithoutProjet_utilisateursInput>
    create: XOR<projetsCreateWithoutProjet_utilisateursInput, projetsUncheckedCreateWithoutProjet_utilisateursInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutProjet_utilisateursInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutProjet_utilisateursInput, projetsUncheckedUpdateWithoutProjet_utilisateursInput>
  }

  export type projetsUpdateWithoutProjet_utilisateursInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutProjet_utilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type utilisateursUpsertWithoutProjet_utilisateursInput = {
    update: XOR<utilisateursUpdateWithoutProjet_utilisateursInput, utilisateursUncheckedUpdateWithoutProjet_utilisateursInput>
    create: XOR<utilisateursCreateWithoutProjet_utilisateursInput, utilisateursUncheckedCreateWithoutProjet_utilisateursInput>
    where?: utilisateursWhereInput
  }

  export type utilisateursUpdateToOneWithWhereWithoutProjet_utilisateursInput = {
    where?: utilisateursWhereInput
    data: XOR<utilisateursUpdateWithoutProjet_utilisateursInput, utilisateursUncheckedUpdateWithoutProjet_utilisateursInput>
  }

  export type utilisateursUpdateWithoutProjet_utilisateursInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutProjet_utilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type commentairesCreateWithoutProjetsInput = {
    content: string
    created_at?: Date | string
    comptes: comptesCreateNestedOneWithoutCommentairesInput
  }

  export type commentairesUncheckedCreateWithoutProjetsInput = {
    id?: number
    compte_id: number
    content: string
    created_at?: Date | string
  }

  export type commentairesCreateOrConnectWithoutProjetsInput = {
    where: commentairesWhereUniqueInput
    create: XOR<commentairesCreateWithoutProjetsInput, commentairesUncheckedCreateWithoutProjetsInput>
  }

  export type commentairesCreateManyProjetsInputEnvelope = {
    data: commentairesCreateManyProjetsInput | commentairesCreateManyProjetsInput[]
    skipDuplicates?: boolean
  }

  export type documentsCreateWithoutProjetsInput = {
    name: string
    file_path?: string | null
    uploaded_at?: Date | string
  }

  export type documentsUncheckedCreateWithoutProjetsInput = {
    id?: number
    name: string
    file_path?: string | null
    uploaded_at?: Date | string
  }

  export type documentsCreateOrConnectWithoutProjetsInput = {
    where: documentsWhereUniqueInput
    create: XOR<documentsCreateWithoutProjetsInput, documentsUncheckedCreateWithoutProjetsInput>
  }

  export type documentsCreateManyProjetsInputEnvelope = {
    data: documentsCreateManyProjetsInput | documentsCreateManyProjetsInput[]
    skipDuplicates?: boolean
  }

  export type indicateursCreateWithoutProjetsInput = {
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
    evaluations?: evaluationsCreateNestedManyWithoutIndicateursInput
  }

  export type indicateursUncheckedCreateWithoutProjetsInput = {
    id?: number
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
    evaluations?: evaluationsUncheckedCreateNestedManyWithoutIndicateursInput
  }

  export type indicateursCreateOrConnectWithoutProjetsInput = {
    where: indicateursWhereUniqueInput
    create: XOR<indicateursCreateWithoutProjetsInput, indicateursUncheckedCreateWithoutProjetsInput>
  }

  export type indicateursCreateManyProjetsInputEnvelope = {
    data: indicateursCreateManyProjetsInput | indicateursCreateManyProjetsInput[]
    skipDuplicates?: boolean
  }

  export type projet_groupesCreateWithoutProjetsInput = {
    groupes: groupesCreateNestedOneWithoutProjet_groupesInput
  }

  export type projet_groupesUncheckedCreateWithoutProjetsInput = {
    groupe_id: number
  }

  export type projet_groupesCreateOrConnectWithoutProjetsInput = {
    where: projet_groupesWhereUniqueInput
    create: XOR<projet_groupesCreateWithoutProjetsInput, projet_groupesUncheckedCreateWithoutProjetsInput>
  }

  export type projet_groupesCreateManyProjetsInputEnvelope = {
    data: projet_groupesCreateManyProjetsInput | projet_groupesCreateManyProjetsInput[]
    skipDuplicates?: boolean
  }

  export type projet_utilisateursCreateWithoutProjetsInput = {
    utilisateurs: utilisateursCreateNestedOneWithoutProjet_utilisateursInput
  }

  export type projet_utilisateursUncheckedCreateWithoutProjetsInput = {
    utilisateur_id: number
  }

  export type projet_utilisateursCreateOrConnectWithoutProjetsInput = {
    where: projet_utilisateursWhereUniqueInput
    create: XOR<projet_utilisateursCreateWithoutProjetsInput, projet_utilisateursUncheckedCreateWithoutProjetsInput>
  }

  export type projet_utilisateursCreateManyProjetsInputEnvelope = {
    data: projet_utilisateursCreateManyProjetsInput | projet_utilisateursCreateManyProjetsInput[]
    skipDuplicates?: boolean
  }

  export type utilisateursCreateWithoutProjetsInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateWithoutProjetsInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursCreateOrConnectWithoutProjetsInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutProjetsInput, utilisateursUncheckedCreateWithoutProjetsInput>
  }

  export type axesCreateWithoutProjetsInput = {
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
    plans_action: plans_actionCreateNestedOneWithoutAxesInput
  }

  export type axesUncheckedCreateWithoutProjetsInput = {
    id?: number
    plan_id: number
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type axesCreateOrConnectWithoutProjetsInput = {
    where: axesWhereUniqueInput
    create: XOR<axesCreateWithoutProjetsInput, axesUncheckedCreateWithoutProjetsInput>
  }

  export type priorityCreateWithoutProjetsInput = {
    name: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type priorityUncheckedCreateWithoutProjetsInput = {
    id?: number
    name: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type priorityCreateOrConnectWithoutProjetsInput = {
    where: priorityWhereUniqueInput
    create: XOR<priorityCreateWithoutProjetsInput, priorityUncheckedCreateWithoutProjetsInput>
  }

  export type ressourcesCreateWithoutProjetsInput = {
    name: string
    description?: string | null
    quantity?: number | null
    unit?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesUncheckedCreateWithoutProjetsInput = {
    id?: number
    name: string
    description?: string | null
    quantity?: number | null
    unit?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesCreateOrConnectWithoutProjetsInput = {
    where: ressourcesWhereUniqueInput
    create: XOR<ressourcesCreateWithoutProjetsInput, ressourcesUncheckedCreateWithoutProjetsInput>
  }

  export type ressourcesCreateManyProjetsInputEnvelope = {
    data: ressourcesCreateManyProjetsInput | ressourcesCreateManyProjetsInput[]
    skipDuplicates?: boolean
  }

  export type suggestionsCreateWithoutProjetsInput = {
    suggestion_content: string
    submitted_at?: Date | string
    comptes: comptesCreateNestedOneWithoutSuggestionsInput
  }

  export type suggestionsUncheckedCreateWithoutProjetsInput = {
    id?: number
    compte_id: number
    suggestion_content: string
    submitted_at?: Date | string
  }

  export type suggestionsCreateOrConnectWithoutProjetsInput = {
    where: suggestionsWhereUniqueInput
    create: XOR<suggestionsCreateWithoutProjetsInput, suggestionsUncheckedCreateWithoutProjetsInput>
  }

  export type suggestionsCreateManyProjetsInputEnvelope = {
    data: suggestionsCreateManyProjetsInput | suggestionsCreateManyProjetsInput[]
    skipDuplicates?: boolean
  }

  export type tachesCreateWithoutProjetInput = {
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutTachesInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutTachesInput
    utilisateur?: utilisateursCreateNestedOneWithoutTachesInput
  }

  export type tachesUncheckedCreateWithoutProjetInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    utilisateur_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutTachesInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutTachesInput
  }

  export type tachesCreateOrConnectWithoutProjetInput = {
    where: tachesWhereUniqueInput
    create: XOR<tachesCreateWithoutProjetInput, tachesUncheckedCreateWithoutProjetInput>
  }

  export type tachesCreateManyProjetInputEnvelope = {
    data: tachesCreateManyProjetInput | tachesCreateManyProjetInput[]
    skipDuplicates?: boolean
  }

  export type commentairesUpsertWithWhereUniqueWithoutProjetsInput = {
    where: commentairesWhereUniqueInput
    update: XOR<commentairesUpdateWithoutProjetsInput, commentairesUncheckedUpdateWithoutProjetsInput>
    create: XOR<commentairesCreateWithoutProjetsInput, commentairesUncheckedCreateWithoutProjetsInput>
  }

  export type commentairesUpdateWithWhereUniqueWithoutProjetsInput = {
    where: commentairesWhereUniqueInput
    data: XOR<commentairesUpdateWithoutProjetsInput, commentairesUncheckedUpdateWithoutProjetsInput>
  }

  export type commentairesUpdateManyWithWhereWithoutProjetsInput = {
    where: commentairesScalarWhereInput
    data: XOR<commentairesUpdateManyMutationInput, commentairesUncheckedUpdateManyWithoutProjetsInput>
  }

  export type documentsUpsertWithWhereUniqueWithoutProjetsInput = {
    where: documentsWhereUniqueInput
    update: XOR<documentsUpdateWithoutProjetsInput, documentsUncheckedUpdateWithoutProjetsInput>
    create: XOR<documentsCreateWithoutProjetsInput, documentsUncheckedCreateWithoutProjetsInput>
  }

  export type documentsUpdateWithWhereUniqueWithoutProjetsInput = {
    where: documentsWhereUniqueInput
    data: XOR<documentsUpdateWithoutProjetsInput, documentsUncheckedUpdateWithoutProjetsInput>
  }

  export type documentsUpdateManyWithWhereWithoutProjetsInput = {
    where: documentsScalarWhereInput
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyWithoutProjetsInput>
  }

  export type documentsScalarWhereInput = {
    AND?: documentsScalarWhereInput | documentsScalarWhereInput[]
    OR?: documentsScalarWhereInput[]
    NOT?: documentsScalarWhereInput | documentsScalarWhereInput[]
    id?: IntFilter<"documents"> | number
    project_id?: IntFilter<"documents"> | number
    name?: StringFilter<"documents"> | string
    file_path?: StringNullableFilter<"documents"> | string | null
    uploaded_at?: DateTimeFilter<"documents"> | Date | string
  }

  export type indicateursUpsertWithWhereUniqueWithoutProjetsInput = {
    where: indicateursWhereUniqueInput
    update: XOR<indicateursUpdateWithoutProjetsInput, indicateursUncheckedUpdateWithoutProjetsInput>
    create: XOR<indicateursCreateWithoutProjetsInput, indicateursUncheckedCreateWithoutProjetsInput>
  }

  export type indicateursUpdateWithWhereUniqueWithoutProjetsInput = {
    where: indicateursWhereUniqueInput
    data: XOR<indicateursUpdateWithoutProjetsInput, indicateursUncheckedUpdateWithoutProjetsInput>
  }

  export type indicateursUpdateManyWithWhereWithoutProjetsInput = {
    where: indicateursScalarWhereInput
    data: XOR<indicateursUpdateManyMutationInput, indicateursUncheckedUpdateManyWithoutProjetsInput>
  }

  export type indicateursScalarWhereInput = {
    AND?: indicateursScalarWhereInput | indicateursScalarWhereInput[]
    OR?: indicateursScalarWhereInput[]
    NOT?: indicateursScalarWhereInput | indicateursScalarWhereInput[]
    id?: IntFilter<"indicateurs"> | number
    project_id?: IntFilter<"indicateurs"> | number
    name?: StringFilter<"indicateurs"> | string
    description?: StringNullableFilter<"indicateurs"> | string | null
    unit?: StringNullableFilter<"indicateurs"> | string | null
    baseline_value?: FloatNullableFilter<"indicateurs"> | number | null
    target_value?: FloatNullableFilter<"indicateurs"> | number | null
    current_value?: FloatNullableFilter<"indicateurs"> | number | null
    latitude?: FloatNullableFilter<"indicateurs"> | number | null
    longitude?: FloatNullableFilter<"indicateurs"> | number | null
    created_date?: DateTimeFilter<"indicateurs"> | Date | string
    last_updated?: DateTimeFilter<"indicateurs"> | Date | string
  }

  export type projet_groupesUpsertWithWhereUniqueWithoutProjetsInput = {
    where: projet_groupesWhereUniqueInput
    update: XOR<projet_groupesUpdateWithoutProjetsInput, projet_groupesUncheckedUpdateWithoutProjetsInput>
    create: XOR<projet_groupesCreateWithoutProjetsInput, projet_groupesUncheckedCreateWithoutProjetsInput>
  }

  export type projet_groupesUpdateWithWhereUniqueWithoutProjetsInput = {
    where: projet_groupesWhereUniqueInput
    data: XOR<projet_groupesUpdateWithoutProjetsInput, projet_groupesUncheckedUpdateWithoutProjetsInput>
  }

  export type projet_groupesUpdateManyWithWhereWithoutProjetsInput = {
    where: projet_groupesScalarWhereInput
    data: XOR<projet_groupesUpdateManyMutationInput, projet_groupesUncheckedUpdateManyWithoutProjetsInput>
  }

  export type projet_utilisateursUpsertWithWhereUniqueWithoutProjetsInput = {
    where: projet_utilisateursWhereUniqueInput
    update: XOR<projet_utilisateursUpdateWithoutProjetsInput, projet_utilisateursUncheckedUpdateWithoutProjetsInput>
    create: XOR<projet_utilisateursCreateWithoutProjetsInput, projet_utilisateursUncheckedCreateWithoutProjetsInput>
  }

  export type projet_utilisateursUpdateWithWhereUniqueWithoutProjetsInput = {
    where: projet_utilisateursWhereUniqueInput
    data: XOR<projet_utilisateursUpdateWithoutProjetsInput, projet_utilisateursUncheckedUpdateWithoutProjetsInput>
  }

  export type projet_utilisateursUpdateManyWithWhereWithoutProjetsInput = {
    where: projet_utilisateursScalarWhereInput
    data: XOR<projet_utilisateursUpdateManyMutationInput, projet_utilisateursUncheckedUpdateManyWithoutProjetsInput>
  }

  export type projet_utilisateursScalarWhereInput = {
    AND?: projet_utilisateursScalarWhereInput | projet_utilisateursScalarWhereInput[]
    OR?: projet_utilisateursScalarWhereInput[]
    NOT?: projet_utilisateursScalarWhereInput | projet_utilisateursScalarWhereInput[]
    projet_id?: IntFilter<"projet_utilisateurs"> | number
    utilisateur_id?: IntFilter<"projet_utilisateurs"> | number
  }

  export type utilisateursUpsertWithoutProjetsInput = {
    update: XOR<utilisateursUpdateWithoutProjetsInput, utilisateursUncheckedUpdateWithoutProjetsInput>
    create: XOR<utilisateursCreateWithoutProjetsInput, utilisateursUncheckedCreateWithoutProjetsInput>
    where?: utilisateursWhereInput
  }

  export type utilisateursUpdateToOneWithWhereWithoutProjetsInput = {
    where?: utilisateursWhereInput
    data: XOR<utilisateursUpdateWithoutProjetsInput, utilisateursUncheckedUpdateWithoutProjetsInput>
  }

  export type utilisateursUpdateWithoutProjetsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type axesUpsertWithoutProjetsInput = {
    update: XOR<axesUpdateWithoutProjetsInput, axesUncheckedUpdateWithoutProjetsInput>
    create: XOR<axesCreateWithoutProjetsInput, axesUncheckedCreateWithoutProjetsInput>
    where?: axesWhereInput
  }

  export type axesUpdateToOneWithWhereWithoutProjetsInput = {
    where?: axesWhereInput
    data: XOR<axesUpdateWithoutProjetsInput, axesUncheckedUpdateWithoutProjetsInput>
  }

  export type axesUpdateWithoutProjetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    plans_action?: plans_actionUpdateOneRequiredWithoutAxesNestedInput
  }

  export type axesUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type priorityUpsertWithoutProjetsInput = {
    update: XOR<priorityUpdateWithoutProjetsInput, priorityUncheckedUpdateWithoutProjetsInput>
    create: XOR<priorityCreateWithoutProjetsInput, priorityUncheckedCreateWithoutProjetsInput>
    where?: priorityWhereInput
  }

  export type priorityUpdateToOneWithWhereWithoutProjetsInput = {
    where?: priorityWhereInput
    data: XOR<priorityUpdateWithoutProjetsInput, priorityUncheckedUpdateWithoutProjetsInput>
  }

  export type priorityUpdateWithoutProjetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type priorityUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ressourcesUpsertWithWhereUniqueWithoutProjetsInput = {
    where: ressourcesWhereUniqueInput
    update: XOR<ressourcesUpdateWithoutProjetsInput, ressourcesUncheckedUpdateWithoutProjetsInput>
    create: XOR<ressourcesCreateWithoutProjetsInput, ressourcesUncheckedCreateWithoutProjetsInput>
  }

  export type ressourcesUpdateWithWhereUniqueWithoutProjetsInput = {
    where: ressourcesWhereUniqueInput
    data: XOR<ressourcesUpdateWithoutProjetsInput, ressourcesUncheckedUpdateWithoutProjetsInput>
  }

  export type ressourcesUpdateManyWithWhereWithoutProjetsInput = {
    where: ressourcesScalarWhereInput
    data: XOR<ressourcesUpdateManyMutationInput, ressourcesUncheckedUpdateManyWithoutProjetsInput>
  }

  export type ressourcesScalarWhereInput = {
    AND?: ressourcesScalarWhereInput | ressourcesScalarWhereInput[]
    OR?: ressourcesScalarWhereInput[]
    NOT?: ressourcesScalarWhereInput | ressourcesScalarWhereInput[]
    id?: IntFilter<"ressources"> | number
    project_id?: IntFilter<"ressources"> | number
    name?: StringFilter<"ressources"> | string
    description?: StringNullableFilter<"ressources"> | string | null
    quantity?: FloatNullableFilter<"ressources"> | number | null
    unit?: StringNullableFilter<"ressources"> | string | null
    cost?: DecimalNullableFilter<"ressources"> | Decimal | DecimalJsLike | number | string | null
  }

  export type suggestionsUpsertWithWhereUniqueWithoutProjetsInput = {
    where: suggestionsWhereUniqueInput
    update: XOR<suggestionsUpdateWithoutProjetsInput, suggestionsUncheckedUpdateWithoutProjetsInput>
    create: XOR<suggestionsCreateWithoutProjetsInput, suggestionsUncheckedCreateWithoutProjetsInput>
  }

  export type suggestionsUpdateWithWhereUniqueWithoutProjetsInput = {
    where: suggestionsWhereUniqueInput
    data: XOR<suggestionsUpdateWithoutProjetsInput, suggestionsUncheckedUpdateWithoutProjetsInput>
  }

  export type suggestionsUpdateManyWithWhereWithoutProjetsInput = {
    where: suggestionsScalarWhereInput
    data: XOR<suggestionsUpdateManyMutationInput, suggestionsUncheckedUpdateManyWithoutProjetsInput>
  }

  export type tachesUpsertWithWhereUniqueWithoutProjetInput = {
    where: tachesWhereUniqueInput
    update: XOR<tachesUpdateWithoutProjetInput, tachesUncheckedUpdateWithoutProjetInput>
    create: XOR<tachesCreateWithoutProjetInput, tachesUncheckedCreateWithoutProjetInput>
  }

  export type tachesUpdateWithWhereUniqueWithoutProjetInput = {
    where: tachesWhereUniqueInput
    data: XOR<tachesUpdateWithoutProjetInput, tachesUncheckedUpdateWithoutProjetInput>
  }

  export type tachesUpdateManyWithWhereWithoutProjetInput = {
    where: tachesScalarWhereInput
    data: XOR<tachesUpdateManyMutationInput, tachesUncheckedUpdateManyWithoutProjetInput>
  }

  export type tachesScalarWhereInput = {
    AND?: tachesScalarWhereInput | tachesScalarWhereInput[]
    OR?: tachesScalarWhereInput[]
    NOT?: tachesScalarWhereInput | tachesScalarWhereInput[]
    id?: IntFilter<"taches"> | number
    libelle?: StringFilter<"taches"> | string
    description?: StringNullableFilter<"taches"> | string | null
    dateDebut?: DateTimeNullableFilter<"taches"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"taches"> | Date | string | null
    projet_id?: IntNullableFilter<"taches"> | number | null
    utilisateur_id?: IntNullableFilter<"taches"> | number | null
    statut?: StringNullableFilter<"taches"> | string | null
    priorite?: StringNullableFilter<"taches"> | string | null
    dateCreation?: DateTimeFilter<"taches"> | Date | string
    dateMiseAJour?: DateTimeFilter<"taches"> | Date | string
    delaiEstime?: StringNullableFilter<"taches"> | string | null
    delaiReel?: StringNullableFilter<"taches"> | string | null
    commentaires?: StringNullableFilter<"taches"> | string | null
    tacheParentId?: IntNullableFilter<"taches"> | number | null
  }

  export type projetsCreateWithoutRessourcesInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutRessourcesInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutRessourcesInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutRessourcesInput, projetsUncheckedCreateWithoutRessourcesInput>
  }

  export type projetsUpsertWithoutRessourcesInput = {
    update: XOR<projetsUpdateWithoutRessourcesInput, projetsUncheckedUpdateWithoutRessourcesInput>
    create: XOR<projetsCreateWithoutRessourcesInput, projetsUncheckedCreateWithoutRessourcesInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutRessourcesInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutRessourcesInput, projetsUncheckedUpdateWithoutRessourcesInput>
  }

  export type projetsUpdateWithoutRessourcesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutRessourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type rolesCreateWithoutRole_permissionsInput = {
    nom: string
    created_date?: Date | string
    last_updated?: Date | string
    comptes?: comptesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutRole_permissionsInput = {
    id?: number
    nom: string
    created_date?: Date | string
    last_updated?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutRole_permissionsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
  }

  export type permissionsCreateWithoutRole_permissionsInput = {
    name: string
    description?: string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type permissionsUncheckedCreateWithoutRole_permissionsInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type permissionsCreateOrConnectWithoutRole_permissionsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
  }

  export type rolesUpsertWithoutRole_permissionsInput = {
    update: XOR<rolesUpdateWithoutRole_permissionsInput, rolesUncheckedUpdateWithoutRole_permissionsInput>
    create: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutRole_permissionsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutRole_permissionsInput, rolesUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type rolesUpdateWithoutRole_permissionsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutRole_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type permissionsUpsertWithoutRole_permissionsInput = {
    update: XOR<permissionsUpdateWithoutRole_permissionsInput, permissionsUncheckedUpdateWithoutRole_permissionsInput>
    create: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutRole_permissionsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutRole_permissionsInput, permissionsUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type permissionsUpdateWithoutRole_permissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionsUncheckedUpdateWithoutRole_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comptesCreateWithoutRolesInput = {
    username: string
    password: string
    validity?: $Enums.comptes_validity
    commentaires?: commentairesCreateNestedManyWithoutComptesInput
    utilisateurs?: utilisateursCreateNestedOneWithoutComptesInput
    suggestions?: suggestionsCreateNestedManyWithoutComptesInput
    votes?: votesCreateNestedManyWithoutComptesInput
  }

  export type comptesUncheckedCreateWithoutRolesInput = {
    id?: number
    username: string
    password: string
    validity?: $Enums.comptes_validity
    user_id?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutComptesInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutComptesInput
    votes?: votesUncheckedCreateNestedManyWithoutComptesInput
  }

  export type comptesCreateOrConnectWithoutRolesInput = {
    where: comptesWhereUniqueInput
    create: XOR<comptesCreateWithoutRolesInput, comptesUncheckedCreateWithoutRolesInput>
  }

  export type comptesCreateManyRolesInputEnvelope = {
    data: comptesCreateManyRolesInput | comptesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type role_permissionsCreateWithoutRolesInput = {
    permissions: permissionsCreateNestedOneWithoutRole_permissionsInput
  }

  export type role_permissionsUncheckedCreateWithoutRolesInput = {
    permission_id: number
  }

  export type role_permissionsCreateOrConnectWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    create: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_permissionsCreateManyRolesInputEnvelope = {
    data: role_permissionsCreateManyRolesInput | role_permissionsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type comptesUpsertWithWhereUniqueWithoutRolesInput = {
    where: comptesWhereUniqueInput
    update: XOR<comptesUpdateWithoutRolesInput, comptesUncheckedUpdateWithoutRolesInput>
    create: XOR<comptesCreateWithoutRolesInput, comptesUncheckedCreateWithoutRolesInput>
  }

  export type comptesUpdateWithWhereUniqueWithoutRolesInput = {
    where: comptesWhereUniqueInput
    data: XOR<comptesUpdateWithoutRolesInput, comptesUncheckedUpdateWithoutRolesInput>
  }

  export type comptesUpdateManyWithWhereWithoutRolesInput = {
    where: comptesScalarWhereInput
    data: XOR<comptesUpdateManyMutationInput, comptesUncheckedUpdateManyWithoutRolesInput>
  }

  export type comptesScalarWhereInput = {
    AND?: comptesScalarWhereInput | comptesScalarWhereInput[]
    OR?: comptesScalarWhereInput[]
    NOT?: comptesScalarWhereInput | comptesScalarWhereInput[]
    id?: IntFilter<"comptes"> | number
    username?: StringFilter<"comptes"> | string
    password?: StringFilter<"comptes"> | string
    role_id?: IntFilter<"comptes"> | number
    validity?: Enumcomptes_validityFilter<"comptes"> | $Enums.comptes_validity
    user_id?: IntNullableFilter<"comptes"> | number | null
  }

  export type role_permissionsUpsertWithWhereUniqueWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    update: XOR<role_permissionsUpdateWithoutRolesInput, role_permissionsUncheckedUpdateWithoutRolesInput>
    create: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_permissionsUpdateWithWhereUniqueWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    data: XOR<role_permissionsUpdateWithoutRolesInput, role_permissionsUncheckedUpdateWithoutRolesInput>
  }

  export type role_permissionsUpdateManyWithWhereWithoutRolesInput = {
    where: role_permissionsScalarWhereInput
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyWithoutRolesInput>
  }

  export type comptesCreateWithoutSuggestionsInput = {
    username: string
    password: string
    validity?: $Enums.comptes_validity
    commentaires?: commentairesCreateNestedManyWithoutComptesInput
    utilisateurs?: utilisateursCreateNestedOneWithoutComptesInput
    roles: rolesCreateNestedOneWithoutComptesInput
    votes?: votesCreateNestedManyWithoutComptesInput
  }

  export type comptesUncheckedCreateWithoutSuggestionsInput = {
    id?: number
    username: string
    password: string
    role_id: number
    validity?: $Enums.comptes_validity
    user_id?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutComptesInput
    votes?: votesUncheckedCreateNestedManyWithoutComptesInput
  }

  export type comptesCreateOrConnectWithoutSuggestionsInput = {
    where: comptesWhereUniqueInput
    create: XOR<comptesCreateWithoutSuggestionsInput, comptesUncheckedCreateWithoutSuggestionsInput>
  }

  export type projetsCreateWithoutSuggestionsInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutSuggestionsInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutSuggestionsInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutSuggestionsInput, projetsUncheckedCreateWithoutSuggestionsInput>
  }

  export type comptesUpsertWithoutSuggestionsInput = {
    update: XOR<comptesUpdateWithoutSuggestionsInput, comptesUncheckedUpdateWithoutSuggestionsInput>
    create: XOR<comptesCreateWithoutSuggestionsInput, comptesUncheckedCreateWithoutSuggestionsInput>
    where?: comptesWhereInput
  }

  export type comptesUpdateToOneWithWhereWithoutSuggestionsInput = {
    where?: comptesWhereInput
    data: XOR<comptesUpdateWithoutSuggestionsInput, comptesUncheckedUpdateWithoutSuggestionsInput>
  }

  export type comptesUpdateWithoutSuggestionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    commentaires?: commentairesUpdateManyWithoutComptesNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutComptesNestedInput
    roles?: rolesUpdateOneRequiredWithoutComptesNestedInput
    votes?: votesUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateWithoutSuggestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutComptesNestedInput
    votes?: votesUncheckedUpdateManyWithoutComptesNestedInput
  }

  export type projetsUpsertWithoutSuggestionsInput = {
    update: XOR<projetsUpdateWithoutSuggestionsInput, projetsUncheckedUpdateWithoutSuggestionsInput>
    create: XOR<projetsCreateWithoutSuggestionsInput, projetsUncheckedCreateWithoutSuggestionsInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutSuggestionsInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutSuggestionsInput, projetsUncheckedUpdateWithoutSuggestionsInput>
  }

  export type projetsUpdateWithoutSuggestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutSuggestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type tachesCreateWithoutTache_assignations_groupesInput = {
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutTachesInput
    utilisateur?: utilisateursCreateNestedOneWithoutTachesInput
    projet?: projetsCreateNestedOneWithoutTachesInput
  }

  export type tachesUncheckedCreateWithoutTache_assignations_groupesInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    projet_id?: number | null
    utilisateur_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutTachesInput
  }

  export type tachesCreateOrConnectWithoutTache_assignations_groupesInput = {
    where: tachesWhereUniqueInput
    create: XOR<tachesCreateWithoutTache_assignations_groupesInput, tachesUncheckedCreateWithoutTache_assignations_groupesInput>
  }

  export type groupesCreateWithoutTache_assignations_groupesInput = {
    nom: string
    projet_groupes?: projet_groupesCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutGroupesInput
    Notification?: notificationsCreateNestedManyWithoutGroupeInput
  }

  export type groupesUncheckedCreateWithoutTache_assignations_groupesInput = {
    id?: number
    nom: string
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutGroupesInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutGroupeInput
  }

  export type groupesCreateOrConnectWithoutTache_assignations_groupesInput = {
    where: groupesWhereUniqueInput
    create: XOR<groupesCreateWithoutTache_assignations_groupesInput, groupesUncheckedCreateWithoutTache_assignations_groupesInput>
  }

  export type tachesUpsertWithoutTache_assignations_groupesInput = {
    update: XOR<tachesUpdateWithoutTache_assignations_groupesInput, tachesUncheckedUpdateWithoutTache_assignations_groupesInput>
    create: XOR<tachesCreateWithoutTache_assignations_groupesInput, tachesUncheckedCreateWithoutTache_assignations_groupesInput>
    where?: tachesWhereInput
  }

  export type tachesUpdateToOneWithWhereWithoutTache_assignations_groupesInput = {
    where?: tachesWhereInput
    data: XOR<tachesUpdateWithoutTache_assignations_groupesInput, tachesUncheckedUpdateWithoutTache_assignations_groupesInput>
  }

  export type tachesUpdateWithoutTache_assignations_groupesInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutTachesNestedInput
    utilisateur?: utilisateursUpdateOneWithoutTachesNestedInput
    projet?: projetsUpdateOneWithoutTachesNestedInput
  }

  export type tachesUncheckedUpdateWithoutTache_assignations_groupesInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateur_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutTachesNestedInput
  }

  export type groupesUpsertWithoutTache_assignations_groupesInput = {
    update: XOR<groupesUpdateWithoutTache_assignations_groupesInput, groupesUncheckedUpdateWithoutTache_assignations_groupesInput>
    create: XOR<groupesCreateWithoutTache_assignations_groupesInput, groupesUncheckedCreateWithoutTache_assignations_groupesInput>
    where?: groupesWhereInput
  }

  export type groupesUpdateToOneWithWhereWithoutTache_assignations_groupesInput = {
    where?: groupesWhereInput
    data: XOR<groupesUpdateWithoutTache_assignations_groupesInput, groupesUncheckedUpdateWithoutTache_assignations_groupesInput>
  }

  export type groupesUpdateWithoutTache_assignations_groupesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUpdateManyWithoutGroupeNestedInput
  }

  export type groupesUncheckedUpdateWithoutTache_assignations_groupesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutGroupesNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutGroupeNestedInput
  }

  export type tachesCreateWithoutTache_assignations_utilisateursInput = {
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutTachesInput
    utilisateur?: utilisateursCreateNestedOneWithoutTachesInput
    projet?: projetsCreateNestedOneWithoutTachesInput
  }

  export type tachesUncheckedCreateWithoutTache_assignations_utilisateursInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    projet_id?: number | null
    utilisateur_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutTachesInput
  }

  export type tachesCreateOrConnectWithoutTache_assignations_utilisateursInput = {
    where: tachesWhereUniqueInput
    create: XOR<tachesCreateWithoutTache_assignations_utilisateursInput, tachesUncheckedCreateWithoutTache_assignations_utilisateursInput>
  }

  export type utilisateursCreateWithoutTache_assignations_utilisateursInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateWithoutTache_assignations_utilisateursInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursCreateOrConnectWithoutTache_assignations_utilisateursInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutTache_assignations_utilisateursInput, utilisateursUncheckedCreateWithoutTache_assignations_utilisateursInput>
  }

  export type tachesUpsertWithoutTache_assignations_utilisateursInput = {
    update: XOR<tachesUpdateWithoutTache_assignations_utilisateursInput, tachesUncheckedUpdateWithoutTache_assignations_utilisateursInput>
    create: XOR<tachesCreateWithoutTache_assignations_utilisateursInput, tachesUncheckedCreateWithoutTache_assignations_utilisateursInput>
    where?: tachesWhereInput
  }

  export type tachesUpdateToOneWithWhereWithoutTache_assignations_utilisateursInput = {
    where?: tachesWhereInput
    data: XOR<tachesUpdateWithoutTache_assignations_utilisateursInput, tachesUncheckedUpdateWithoutTache_assignations_utilisateursInput>
  }

  export type tachesUpdateWithoutTache_assignations_utilisateursInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutTachesNestedInput
    utilisateur?: utilisateursUpdateOneWithoutTachesNestedInput
    projet?: projetsUpdateOneWithoutTachesNestedInput
  }

  export type tachesUncheckedUpdateWithoutTache_assignations_utilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    utilisateur_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutTachesNestedInput
  }

  export type utilisateursUpsertWithoutTache_assignations_utilisateursInput = {
    update: XOR<utilisateursUpdateWithoutTache_assignations_utilisateursInput, utilisateursUncheckedUpdateWithoutTache_assignations_utilisateursInput>
    create: XOR<utilisateursCreateWithoutTache_assignations_utilisateursInput, utilisateursUncheckedCreateWithoutTache_assignations_utilisateursInput>
    where?: utilisateursWhereInput
  }

  export type utilisateursUpdateToOneWithWhereWithoutTache_assignations_utilisateursInput = {
    where?: utilisateursWhereInput
    data: XOR<utilisateursUpdateWithoutTache_assignations_utilisateursInput, utilisateursUncheckedUpdateWithoutTache_assignations_utilisateursInput>
  }

  export type utilisateursUpdateWithoutTache_assignations_utilisateursInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutTache_assignations_utilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tache_assignations_groupesCreateWithoutTachesInput = {
    groupes: groupesCreateNestedOneWithoutTache_assignations_groupesInput
  }

  export type tache_assignations_groupesUncheckedCreateWithoutTachesInput = {
    groupe_id: number
  }

  export type tache_assignations_groupesCreateOrConnectWithoutTachesInput = {
    where: tache_assignations_groupesWhereUniqueInput
    create: XOR<tache_assignations_groupesCreateWithoutTachesInput, tache_assignations_groupesUncheckedCreateWithoutTachesInput>
  }

  export type tache_assignations_groupesCreateManyTachesInputEnvelope = {
    data: tache_assignations_groupesCreateManyTachesInput | tache_assignations_groupesCreateManyTachesInput[]
    skipDuplicates?: boolean
  }

  export type tache_assignations_utilisateursCreateWithoutTachesInput = {
    utilisateurs: utilisateursCreateNestedOneWithoutTache_assignations_utilisateursInput
  }

  export type tache_assignations_utilisateursUncheckedCreateWithoutTachesInput = {
    utilisateur_id: number
  }

  export type tache_assignations_utilisateursCreateOrConnectWithoutTachesInput = {
    where: tache_assignations_utilisateursWhereUniqueInput
    create: XOR<tache_assignations_utilisateursCreateWithoutTachesInput, tache_assignations_utilisateursUncheckedCreateWithoutTachesInput>
  }

  export type tache_assignations_utilisateursCreateManyTachesInputEnvelope = {
    data: tache_assignations_utilisateursCreateManyTachesInput | tache_assignations_utilisateursCreateManyTachesInput[]
    skipDuplicates?: boolean
  }

  export type utilisateursCreateWithoutTachesInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsCreateNestedManyWithoutUserInput
  }

  export type utilisateursUncheckedCreateWithoutTachesInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    Notification?: notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type utilisateursCreateOrConnectWithoutTachesInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutTachesInput, utilisateursUncheckedCreateWithoutTachesInput>
  }

  export type projetsCreateWithoutTachesInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    utilisateurs?: utilisateursCreateNestedOneWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
  }

  export type projetsUncheckedCreateWithoutTachesInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
  }

  export type projetsCreateOrConnectWithoutTachesInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutTachesInput, projetsUncheckedCreateWithoutTachesInput>
  }

  export type tache_assignations_groupesUpsertWithWhereUniqueWithoutTachesInput = {
    where: tache_assignations_groupesWhereUniqueInput
    update: XOR<tache_assignations_groupesUpdateWithoutTachesInput, tache_assignations_groupesUncheckedUpdateWithoutTachesInput>
    create: XOR<tache_assignations_groupesCreateWithoutTachesInput, tache_assignations_groupesUncheckedCreateWithoutTachesInput>
  }

  export type tache_assignations_groupesUpdateWithWhereUniqueWithoutTachesInput = {
    where: tache_assignations_groupesWhereUniqueInput
    data: XOR<tache_assignations_groupesUpdateWithoutTachesInput, tache_assignations_groupesUncheckedUpdateWithoutTachesInput>
  }

  export type tache_assignations_groupesUpdateManyWithWhereWithoutTachesInput = {
    where: tache_assignations_groupesScalarWhereInput
    data: XOR<tache_assignations_groupesUpdateManyMutationInput, tache_assignations_groupesUncheckedUpdateManyWithoutTachesInput>
  }

  export type tache_assignations_utilisateursUpsertWithWhereUniqueWithoutTachesInput = {
    where: tache_assignations_utilisateursWhereUniqueInput
    update: XOR<tache_assignations_utilisateursUpdateWithoutTachesInput, tache_assignations_utilisateursUncheckedUpdateWithoutTachesInput>
    create: XOR<tache_assignations_utilisateursCreateWithoutTachesInput, tache_assignations_utilisateursUncheckedCreateWithoutTachesInput>
  }

  export type tache_assignations_utilisateursUpdateWithWhereUniqueWithoutTachesInput = {
    where: tache_assignations_utilisateursWhereUniqueInput
    data: XOR<tache_assignations_utilisateursUpdateWithoutTachesInput, tache_assignations_utilisateursUncheckedUpdateWithoutTachesInput>
  }

  export type tache_assignations_utilisateursUpdateManyWithWhereWithoutTachesInput = {
    where: tache_assignations_utilisateursScalarWhereInput
    data: XOR<tache_assignations_utilisateursUpdateManyMutationInput, tache_assignations_utilisateursUncheckedUpdateManyWithoutTachesInput>
  }

  export type tache_assignations_utilisateursScalarWhereInput = {
    AND?: tache_assignations_utilisateursScalarWhereInput | tache_assignations_utilisateursScalarWhereInput[]
    OR?: tache_assignations_utilisateursScalarWhereInput[]
    NOT?: tache_assignations_utilisateursScalarWhereInput | tache_assignations_utilisateursScalarWhereInput[]
    tache_id?: IntFilter<"tache_assignations_utilisateurs"> | number
    utilisateur_id?: IntFilter<"tache_assignations_utilisateurs"> | number
  }

  export type utilisateursUpsertWithoutTachesInput = {
    update: XOR<utilisateursUpdateWithoutTachesInput, utilisateursUncheckedUpdateWithoutTachesInput>
    create: XOR<utilisateursCreateWithoutTachesInput, utilisateursUncheckedCreateWithoutTachesInput>
    where?: utilisateursWhereInput
  }

  export type utilisateursUpdateToOneWithWhereWithoutTachesInput = {
    where?: utilisateursWhereInput
    data: XOR<utilisateursUpdateWithoutTachesInput, utilisateursUncheckedUpdateWithoutTachesInput>
  }

  export type utilisateursUpdateWithoutTachesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutTachesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type projetsUpsertWithoutTachesInput = {
    update: XOR<projetsUpdateWithoutTachesInput, projetsUncheckedUpdateWithoutTachesInput>
    create: XOR<projetsCreateWithoutTachesInput, projetsUncheckedCreateWithoutTachesInput>
    where?: projetsWhereInput
  }

  export type projetsUpdateToOneWithWhereWithoutTachesInput = {
    where?: projetsWhereInput
    data: XOR<projetsUpdateWithoutTachesInput, projetsUncheckedUpdateWithoutTachesInput>
  }

  export type projetsUpdateWithoutTachesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
  }

  export type projetsUncheckedUpdateWithoutTachesInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
  }

  export type comptesCreateWithoutUtilisateursInput = {
    username: string
    password: string
    validity?: $Enums.comptes_validity
    commentaires?: commentairesCreateNestedManyWithoutComptesInput
    roles: rolesCreateNestedOneWithoutComptesInput
    suggestions?: suggestionsCreateNestedManyWithoutComptesInput
    votes?: votesCreateNestedManyWithoutComptesInput
  }

  export type comptesUncheckedCreateWithoutUtilisateursInput = {
    id?: number
    username: string
    password: string
    role_id: number
    validity?: $Enums.comptes_validity
    commentaires?: commentairesUncheckedCreateNestedManyWithoutComptesInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutComptesInput
    votes?: votesUncheckedCreateNestedManyWithoutComptesInput
  }

  export type comptesCreateOrConnectWithoutUtilisateursInput = {
    where: comptesWhereUniqueInput
    create: XOR<comptesCreateWithoutUtilisateursInput, comptesUncheckedCreateWithoutUtilisateursInput>
  }

  export type comptesCreateManyUtilisateursInputEnvelope = {
    data: comptesCreateManyUtilisateursInput | comptesCreateManyUtilisateursInput[]
    skipDuplicates?: boolean
  }

  export type projet_utilisateursCreateWithoutUtilisateursInput = {
    projets: projetsCreateNestedOneWithoutProjet_utilisateursInput
  }

  export type projet_utilisateursUncheckedCreateWithoutUtilisateursInput = {
    projet_id: number
  }

  export type projet_utilisateursCreateOrConnectWithoutUtilisateursInput = {
    where: projet_utilisateursWhereUniqueInput
    create: XOR<projet_utilisateursCreateWithoutUtilisateursInput, projet_utilisateursUncheckedCreateWithoutUtilisateursInput>
  }

  export type projet_utilisateursCreateManyUtilisateursInputEnvelope = {
    data: projet_utilisateursCreateManyUtilisateursInput | projet_utilisateursCreateManyUtilisateursInput[]
    skipDuplicates?: boolean
  }

  export type projetsCreateWithoutUtilisateursInput = {
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesCreateNestedManyWithoutProjetsInput
    documents?: documentsCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutProjetsInput
    axes: axesCreateNestedOneWithoutProjetsInput
    priority?: priorityCreateNestedOneWithoutProjetsInput
    ressources?: ressourcesCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsCreateNestedManyWithoutProjetsInput
    taches?: tachesCreateNestedManyWithoutProjetInput
  }

  export type projetsUncheckedCreateWithoutUtilisateursInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutProjetsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjetsInput
    indicateurs?: indicateursUncheckedCreateNestedManyWithoutProjetsInput
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutProjetsInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutProjetsInput
    ressources?: ressourcesUncheckedCreateNestedManyWithoutProjetsInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutProjetsInput
    taches?: tachesUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetsCreateOrConnectWithoutUtilisateursInput = {
    where: projetsWhereUniqueInput
    create: XOR<projetsCreateWithoutUtilisateursInput, projetsUncheckedCreateWithoutUtilisateursInput>
  }

  export type projetsCreateManyUtilisateursInputEnvelope = {
    data: projetsCreateManyUtilisateursInput | projetsCreateManyUtilisateursInput[]
    skipDuplicates?: boolean
  }

  export type tache_assignations_utilisateursCreateWithoutUtilisateursInput = {
    taches: tachesCreateNestedOneWithoutTache_assignations_utilisateursInput
  }

  export type tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput = {
    tache_id: number
  }

  export type tache_assignations_utilisateursCreateOrConnectWithoutUtilisateursInput = {
    where: tache_assignations_utilisateursWhereUniqueInput
    create: XOR<tache_assignations_utilisateursCreateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput>
  }

  export type tache_assignations_utilisateursCreateManyUtilisateursInputEnvelope = {
    data: tache_assignations_utilisateursCreateManyUtilisateursInput | tache_assignations_utilisateursCreateManyUtilisateursInput[]
    skipDuplicates?: boolean
  }

  export type tachesCreateWithoutUtilisateurInput = {
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutTachesInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutTachesInput
    projet?: projetsCreateNestedOneWithoutTachesInput
  }

  export type tachesUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    projet_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutTachesInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutTachesInput
  }

  export type tachesCreateOrConnectWithoutUtilisateurInput = {
    where: tachesWhereUniqueInput
    create: XOR<tachesCreateWithoutUtilisateurInput, tachesUncheckedCreateWithoutUtilisateurInput>
  }

  export type tachesCreateManyUtilisateurInputEnvelope = {
    data: tachesCreateManyUtilisateurInput | tachesCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type category_userCreateWithoutUtilisateursInput = {
    name: string
    description: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type category_userUncheckedCreateWithoutUtilisateursInput = {
    id?: number
    name: string
    description: string
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type category_userCreateOrConnectWithoutUtilisateursInput = {
    where: category_userWhereUniqueInput
    create: XOR<category_userCreateWithoutUtilisateursInput, category_userUncheckedCreateWithoutUtilisateursInput>
  }

  export type GroupesUtilisateursCreateWithoutUtilisateursInput = {
    groupes: groupesCreateNestedOneWithoutGroupesUtilisateursInput
  }

  export type GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput = {
    groupe_id: number
  }

  export type GroupesUtilisateursCreateOrConnectWithoutUtilisateursInput = {
    where: GroupesUtilisateursWhereUniqueInput
    create: XOR<GroupesUtilisateursCreateWithoutUtilisateursInput, GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput>
  }

  export type GroupesUtilisateursCreateManyUtilisateursInputEnvelope = {
    data: GroupesUtilisateursCreateManyUtilisateursInput | GroupesUtilisateursCreateManyUtilisateursInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUserInput = {
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    groupe?: groupesCreateNestedOneWithoutNotificationInput
  }

  export type notificationsUncheckedCreateWithoutUserInput = {
    id?: number
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    groupeId?: number | null
  }

  export type notificationsCreateOrConnectWithoutUserInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput>
  }

  export type notificationsCreateManyUserInputEnvelope = {
    data: notificationsCreateManyUserInput | notificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type comptesUpsertWithWhereUniqueWithoutUtilisateursInput = {
    where: comptesWhereUniqueInput
    update: XOR<comptesUpdateWithoutUtilisateursInput, comptesUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<comptesCreateWithoutUtilisateursInput, comptesUncheckedCreateWithoutUtilisateursInput>
  }

  export type comptesUpdateWithWhereUniqueWithoutUtilisateursInput = {
    where: comptesWhereUniqueInput
    data: XOR<comptesUpdateWithoutUtilisateursInput, comptesUncheckedUpdateWithoutUtilisateursInput>
  }

  export type comptesUpdateManyWithWhereWithoutUtilisateursInput = {
    where: comptesScalarWhereInput
    data: XOR<comptesUpdateManyMutationInput, comptesUncheckedUpdateManyWithoutUtilisateursInput>
  }

  export type projet_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput = {
    where: projet_utilisateursWhereUniqueInput
    update: XOR<projet_utilisateursUpdateWithoutUtilisateursInput, projet_utilisateursUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<projet_utilisateursCreateWithoutUtilisateursInput, projet_utilisateursUncheckedCreateWithoutUtilisateursInput>
  }

  export type projet_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput = {
    where: projet_utilisateursWhereUniqueInput
    data: XOR<projet_utilisateursUpdateWithoutUtilisateursInput, projet_utilisateursUncheckedUpdateWithoutUtilisateursInput>
  }

  export type projet_utilisateursUpdateManyWithWhereWithoutUtilisateursInput = {
    where: projet_utilisateursScalarWhereInput
    data: XOR<projet_utilisateursUpdateManyMutationInput, projet_utilisateursUncheckedUpdateManyWithoutUtilisateursInput>
  }

  export type projetsUpsertWithWhereUniqueWithoutUtilisateursInput = {
    where: projetsWhereUniqueInput
    update: XOR<projetsUpdateWithoutUtilisateursInput, projetsUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<projetsCreateWithoutUtilisateursInput, projetsUncheckedCreateWithoutUtilisateursInput>
  }

  export type projetsUpdateWithWhereUniqueWithoutUtilisateursInput = {
    where: projetsWhereUniqueInput
    data: XOR<projetsUpdateWithoutUtilisateursInput, projetsUncheckedUpdateWithoutUtilisateursInput>
  }

  export type projetsUpdateManyWithWhereWithoutUtilisateursInput = {
    where: projetsScalarWhereInput
    data: XOR<projetsUpdateManyMutationInput, projetsUncheckedUpdateManyWithoutUtilisateursInput>
  }

  export type tache_assignations_utilisateursUpsertWithWhereUniqueWithoutUtilisateursInput = {
    where: tache_assignations_utilisateursWhereUniqueInput
    update: XOR<tache_assignations_utilisateursUpdateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<tache_assignations_utilisateursCreateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedCreateWithoutUtilisateursInput>
  }

  export type tache_assignations_utilisateursUpdateWithWhereUniqueWithoutUtilisateursInput = {
    where: tache_assignations_utilisateursWhereUniqueInput
    data: XOR<tache_assignations_utilisateursUpdateWithoutUtilisateursInput, tache_assignations_utilisateursUncheckedUpdateWithoutUtilisateursInput>
  }

  export type tache_assignations_utilisateursUpdateManyWithWhereWithoutUtilisateursInput = {
    where: tache_assignations_utilisateursScalarWhereInput
    data: XOR<tache_assignations_utilisateursUpdateManyMutationInput, tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursInput>
  }

  export type tachesUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: tachesWhereUniqueInput
    update: XOR<tachesUpdateWithoutUtilisateurInput, tachesUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<tachesCreateWithoutUtilisateurInput, tachesUncheckedCreateWithoutUtilisateurInput>
  }

  export type tachesUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: tachesWhereUniqueInput
    data: XOR<tachesUpdateWithoutUtilisateurInput, tachesUncheckedUpdateWithoutUtilisateurInput>
  }

  export type tachesUpdateManyWithWhereWithoutUtilisateurInput = {
    where: tachesScalarWhereInput
    data: XOR<tachesUpdateManyMutationInput, tachesUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type category_userUpsertWithoutUtilisateursInput = {
    update: XOR<category_userUpdateWithoutUtilisateursInput, category_userUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<category_userCreateWithoutUtilisateursInput, category_userUncheckedCreateWithoutUtilisateursInput>
    where?: category_userWhereInput
  }

  export type category_userUpdateToOneWithWhereWithoutUtilisateursInput = {
    where?: category_userWhereInput
    data: XOR<category_userUpdateWithoutUtilisateursInput, category_userUncheckedUpdateWithoutUtilisateursInput>
  }

  export type category_userUpdateWithoutUtilisateursInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_userUncheckedUpdateWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupesUtilisateursUpsertWithWhereUniqueWithoutUtilisateursInput = {
    where: GroupesUtilisateursWhereUniqueInput
    update: XOR<GroupesUtilisateursUpdateWithoutUtilisateursInput, GroupesUtilisateursUncheckedUpdateWithoutUtilisateursInput>
    create: XOR<GroupesUtilisateursCreateWithoutUtilisateursInput, GroupesUtilisateursUncheckedCreateWithoutUtilisateursInput>
  }

  export type GroupesUtilisateursUpdateWithWhereUniqueWithoutUtilisateursInput = {
    where: GroupesUtilisateursWhereUniqueInput
    data: XOR<GroupesUtilisateursUpdateWithoutUtilisateursInput, GroupesUtilisateursUncheckedUpdateWithoutUtilisateursInput>
  }

  export type GroupesUtilisateursUpdateManyWithWhereWithoutUtilisateursInput = {
    where: GroupesUtilisateursScalarWhereInput
    data: XOR<GroupesUtilisateursUpdateManyMutationInput, GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUserInput, notificationsUncheckedUpdateWithoutUserInput>
    create: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUserInput, notificationsUncheckedUpdateWithoutUserInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUserInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type comptesCreateWithoutVotesInput = {
    username: string
    password: string
    validity?: $Enums.comptes_validity
    commentaires?: commentairesCreateNestedManyWithoutComptesInput
    utilisateurs?: utilisateursCreateNestedOneWithoutComptesInput
    roles: rolesCreateNestedOneWithoutComptesInput
    suggestions?: suggestionsCreateNestedManyWithoutComptesInput
  }

  export type comptesUncheckedCreateWithoutVotesInput = {
    id?: number
    username: string
    password: string
    role_id: number
    validity?: $Enums.comptes_validity
    user_id?: number | null
    commentaires?: commentairesUncheckedCreateNestedManyWithoutComptesInput
    suggestions?: suggestionsUncheckedCreateNestedManyWithoutComptesInput
  }

  export type comptesCreateOrConnectWithoutVotesInput = {
    where: comptesWhereUniqueInput
    create: XOR<comptesCreateWithoutVotesInput, comptesUncheckedCreateWithoutVotesInput>
  }

  export type comptesUpsertWithoutVotesInput = {
    update: XOR<comptesUpdateWithoutVotesInput, comptesUncheckedUpdateWithoutVotesInput>
    create: XOR<comptesCreateWithoutVotesInput, comptesUncheckedCreateWithoutVotesInput>
    where?: comptesWhereInput
  }

  export type comptesUpdateToOneWithWhereWithoutVotesInput = {
    where?: comptesWhereInput
    data: XOR<comptesUpdateWithoutVotesInput, comptesUncheckedUpdateWithoutVotesInput>
  }

  export type comptesUpdateWithoutVotesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    commentaires?: commentairesUpdateManyWithoutComptesNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutComptesNestedInput
    roles?: rolesUpdateOneRequiredWithoutComptesNestedInput
    suggestions?: suggestionsUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateWithoutVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutComptesNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutComptesNestedInput
  }

  export type utilisateursCreateWithoutNotificationInput = {
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
    comptes?: comptesCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursCreateNestedManyWithoutUtilisateursInput
    projets?: projetsCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursCreateNestedManyWithoutUtilisateursInput
    taches?: tachesCreateNestedManyWithoutUtilisateurInput
    category_user?: category_userCreateNestedOneWithoutUtilisateursInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutUtilisateursInput
  }

  export type utilisateursUncheckedCreateWithoutNotificationInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    category_id?: number | null
    created_at?: Date | string
    comptes?: comptesUncheckedCreateNestedManyWithoutUtilisateursInput
    projet_utilisateurs?: projet_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    projets?: projetsUncheckedCreateNestedManyWithoutUtilisateursInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
    taches?: tachesUncheckedCreateNestedManyWithoutUtilisateurInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutUtilisateursInput
  }

  export type utilisateursCreateOrConnectWithoutNotificationInput = {
    where: utilisateursWhereUniqueInput
    create: XOR<utilisateursCreateWithoutNotificationInput, utilisateursUncheckedCreateWithoutNotificationInput>
  }

  export type groupesCreateWithoutNotificationInput = {
    nom: string
    projet_groupes?: projet_groupesCreateNestedManyWithoutGroupesInput
    tache_assignations_groupes?: tache_assignations_groupesCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursCreateNestedManyWithoutGroupesInput
  }

  export type groupesUncheckedCreateWithoutNotificationInput = {
    id?: number
    nom: string
    projet_groupes?: projet_groupesUncheckedCreateNestedManyWithoutGroupesInput
    tache_assignations_groupes?: tache_assignations_groupesUncheckedCreateNestedManyWithoutGroupesInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedCreateNestedManyWithoutGroupesInput
  }

  export type groupesCreateOrConnectWithoutNotificationInput = {
    where: groupesWhereUniqueInput
    create: XOR<groupesCreateWithoutNotificationInput, groupesUncheckedCreateWithoutNotificationInput>
  }

  export type utilisateursUpsertWithoutNotificationInput = {
    update: XOR<utilisateursUpdateWithoutNotificationInput, utilisateursUncheckedUpdateWithoutNotificationInput>
    create: XOR<utilisateursCreateWithoutNotificationInput, utilisateursUncheckedCreateWithoutNotificationInput>
    where?: utilisateursWhereInput
  }

  export type utilisateursUpdateToOneWithWhereWithoutNotificationInput = {
    where?: utilisateursWhereInput
    data: XOR<utilisateursUpdateWithoutNotificationInput, utilisateursUncheckedUpdateWithoutNotificationInput>
  }

  export type utilisateursUpdateWithoutNotificationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    category_user?: category_userUpdateOneWithoutUtilisateursNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
  }

  export type groupesUpsertWithoutNotificationInput = {
    update: XOR<groupesUpdateWithoutNotificationInput, groupesUncheckedUpdateWithoutNotificationInput>
    create: XOR<groupesCreateWithoutNotificationInput, groupesUncheckedCreateWithoutNotificationInput>
    where?: groupesWhereInput
  }

  export type groupesUpdateToOneWithWhereWithoutNotificationInput = {
    where?: groupesWhereInput
    data: XOR<groupesUpdateWithoutNotificationInput, groupesUncheckedUpdateWithoutNotificationInput>
  }

  export type groupesUpdateWithoutNotificationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUpdateManyWithoutGroupesNestedInput
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutGroupesNestedInput
  }

  export type groupesUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutGroupesNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutGroupesNestedInput
  }

  export type actualite_imagesCreateManyActualitesInput = {
    id?: number
    image_url: string
  }

  export type actualite_imagesUpdateWithoutActualitesInput = {
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type actualite_imagesUncheckedUpdateWithoutActualitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type actualite_imagesUncheckedUpdateManyWithoutActualitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type projetsCreateManyAxesInput = {
    id?: number
    priority_id?: number | null
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
  }

  export type projetsUpdateWithoutAxesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutAxesInput = {
    id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateManyWithoutAxesInput = {
    id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type utilisateursCreateManyCategory_userInput = {
    id?: number
    nom: string
    prenom: string
    email: string
    created_at?: Date | string
  }

  export type utilisateursUpdateWithoutCategory_userInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateWithoutCategory_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUncheckedUpdateManyWithoutUtilisateursNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    projets?: projetsUncheckedUpdateManyWithoutUtilisateursNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    taches?: tachesUncheckedUpdateManyWithoutUtilisateurNestedInput
    groupesUtilisateurs?: GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursNestedInput
    Notification?: notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type utilisateursUncheckedUpdateManyWithoutCategory_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentairesCreateManyComptesInput = {
    id?: number
    project_id: number
    content: string
    created_at?: Date | string
  }

  export type suggestionsCreateManyComptesInput = {
    id?: number
    project_id: number
    suggestion_content: string
    submitted_at?: Date | string
  }

  export type votesCreateManyComptesInput = {
    id?: number
    vote_value?: number | null
    voted_at?: Date | string
  }

  export type commentairesUpdateWithoutComptesInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUpdateOneRequiredWithoutCommentairesNestedInput
  }

  export type commentairesUncheckedUpdateWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentairesUncheckedUpdateManyWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUpdateWithoutComptesInput = {
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUpdateOneRequiredWithoutSuggestionsNestedInput
  }

  export type suggestionsUncheckedUpdateWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateManyWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesUpdateWithoutComptesInput = {
    vote_value?: NullableIntFieldUpdateOperationsInput | number | null
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesUncheckedUpdateWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    vote_value?: NullableIntFieldUpdateOperationsInput | number | null
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesUncheckedUpdateManyWithoutComptesInput = {
    id?: IntFieldUpdateOperationsInput | number
    vote_value?: NullableIntFieldUpdateOperationsInput | number | null
    voted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_groupesCreateManyGroupesInput = {
    projet_id: number
  }

  export type tache_assignations_groupesCreateManyGroupesInput = {
    tache_id: number
  }

  export type GroupesUtilisateursCreateManyGroupesInput = {
    utilisateur_id: number
  }

  export type notificationsCreateManyGroupeInput = {
    id?: number
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    userId?: number | null
  }

  export type projet_groupesUpdateWithoutGroupesInput = {
    projets?: projetsUpdateOneRequiredWithoutProjet_groupesNestedInput
  }

  export type projet_groupesUncheckedUpdateWithoutGroupesInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_groupesUncheckedUpdateManyWithoutGroupesInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_groupesUpdateWithoutGroupesInput = {
    taches?: tachesUpdateOneRequiredWithoutTache_assignations_groupesNestedInput
  }

  export type tache_assignations_groupesUncheckedUpdateWithoutGroupesInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_groupesUncheckedUpdateManyWithoutGroupesInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupesUtilisateursUpdateWithoutGroupesInput = {
    utilisateurs?: utilisateursUpdateOneRequiredWithoutGroupesUtilisateursNestedInput
  }

  export type GroupesUtilisateursUncheckedUpdateWithoutGroupesInput = {
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupesUtilisateursUncheckedUpdateManyWithoutGroupesInput = {
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type notificationsUpdateWithoutGroupeInput = {
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: utilisateursUpdateOneWithoutNotificationNestedInput
  }

  export type notificationsUncheckedUpdateWithoutGroupeInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notificationsUncheckedUpdateManyWithoutGroupeInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type evaluationsCreateManyIndicateursInput = {
    id?: number
    evaluation_date?: Date | string | null
    value?: number | null
    comment?: string | null
  }

  export type evaluationsUpdateWithoutIndicateursInput = {
    evaluation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type evaluationsUncheckedUpdateWithoutIndicateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type evaluationsUncheckedUpdateManyWithoutIndicateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_permissionsCreateManyPermissionsInput = {
    role_id: number
  }

  export type role_permissionsUpdateWithoutPermissionsInput = {
    roles?: rolesUpdateOneRequiredWithoutRole_permissionsNestedInput
  }

  export type role_permissionsUncheckedUpdateWithoutPermissionsInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type role_permissionsUncheckedUpdateManyWithoutPermissionsInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type axesCreateManyPlans_actionInput = {
    id?: number
    name: string
    description?: string | null
    statut?: string | null
    objectif?: string | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type axesUpdateWithoutPlans_actionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUpdateManyWithoutAxesNestedInput
  }

  export type axesUncheckedUpdateWithoutPlans_actionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    projets?: projetsUncheckedUpdateManyWithoutAxesNestedInput
  }

  export type axesUncheckedUpdateManyWithoutPlans_actionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projetsCreateManyPriorityInput = {
    id?: number
    axe_id: number
    manager?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
  }

  export type projetsUpdateWithoutPriorityInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutPriorityInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateManyWithoutPriorityInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    manager?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type commentairesCreateManyProjetsInput = {
    id?: number
    compte_id: number
    content: string
    created_at?: Date | string
  }

  export type documentsCreateManyProjetsInput = {
    id?: number
    name: string
    file_path?: string | null
    uploaded_at?: Date | string
  }

  export type indicateursCreateManyProjetsInput = {
    id?: number
    name: string
    description?: string | null
    unit?: string | null
    baseline_value?: number | null
    target_value?: number | null
    current_value?: number | null
    latitude?: number | null
    longitude?: number | null
    created_date?: Date | string
    last_updated?: Date | string
  }

  export type projet_groupesCreateManyProjetsInput = {
    groupe_id: number
  }

  export type projet_utilisateursCreateManyProjetsInput = {
    utilisateur_id: number
  }

  export type ressourcesCreateManyProjetsInput = {
    id?: number
    name: string
    description?: string | null
    quantity?: number | null
    unit?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
  }

  export type suggestionsCreateManyProjetsInput = {
    id?: number
    compte_id: number
    suggestion_content: string
    submitted_at?: Date | string
  }

  export type tachesCreateManyProjetInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    utilisateur_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
  }

  export type commentairesUpdateWithoutProjetsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateOneRequiredWithoutCommentairesNestedInput
  }

  export type commentairesUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentairesUncheckedUpdateManyWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentsUpdateWithoutProjetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentsUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentsUncheckedUpdateManyWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type indicateursUpdateWithoutProjetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: evaluationsUpdateManyWithoutIndicateursNestedInput
  }

  export type indicateursUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: evaluationsUncheckedUpdateManyWithoutIndicateursNestedInput
  }

  export type indicateursUncheckedUpdateManyWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    baseline_value?: NullableFloatFieldUpdateOperationsInput | number | null
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_groupesUpdateWithoutProjetsInput = {
    groupes?: groupesUpdateOneRequiredWithoutProjet_groupesNestedInput
  }

  export type projet_groupesUncheckedUpdateWithoutProjetsInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_groupesUncheckedUpdateManyWithoutProjetsInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_utilisateursUpdateWithoutProjetsInput = {
    utilisateurs?: utilisateursUpdateOneRequiredWithoutProjet_utilisateursNestedInput
  }

  export type projet_utilisateursUncheckedUpdateWithoutProjetsInput = {
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_utilisateursUncheckedUpdateManyWithoutProjetsInput = {
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type ressourcesUpdateWithoutProjetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ressourcesUncheckedUpdateManyWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type suggestionsUpdateWithoutProjetsInput = {
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comptes?: comptesUpdateOneRequiredWithoutSuggestionsNestedInput
  }

  export type suggestionsUncheckedUpdateWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateManyWithoutProjetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    compte_id?: IntFieldUpdateOperationsInput | number
    suggestion_content?: StringFieldUpdateOperationsInput | string
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tachesUpdateWithoutProjetInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutTachesNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutTachesNestedInput
    utilisateur?: utilisateursUpdateOneWithoutTachesNestedInput
  }

  export type tachesUncheckedUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utilisateur_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutTachesNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutTachesNestedInput
  }

  export type tachesUncheckedUpdateManyWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utilisateur_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type comptesCreateManyRolesInput = {
    id?: number
    username: string
    password: string
    validity?: $Enums.comptes_validity
    user_id?: number | null
  }

  export type role_permissionsCreateManyRolesInput = {
    permission_id: number
  }

  export type comptesUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    commentaires?: commentairesUpdateManyWithoutComptesNestedInput
    utilisateurs?: utilisateursUpdateOneWithoutComptesNestedInput
    suggestions?: suggestionsUpdateManyWithoutComptesNestedInput
    votes?: votesUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutComptesNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutComptesNestedInput
    votes?: votesUncheckedUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type role_permissionsUpdateWithoutRolesInput = {
    permissions?: permissionsUpdateOneRequiredWithoutRole_permissionsNestedInput
  }

  export type role_permissionsUncheckedUpdateWithoutRolesInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type role_permissionsUncheckedUpdateManyWithoutRolesInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_groupesCreateManyTachesInput = {
    groupe_id: number
  }

  export type tache_assignations_utilisateursCreateManyTachesInput = {
    utilisateur_id: number
  }

  export type tache_assignations_groupesUpdateWithoutTachesInput = {
    groupes?: groupesUpdateOneRequiredWithoutTache_assignations_groupesNestedInput
  }

  export type tache_assignations_groupesUncheckedUpdateWithoutTachesInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_groupesUncheckedUpdateManyWithoutTachesInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_utilisateursUpdateWithoutTachesInput = {
    utilisateurs?: utilisateursUpdateOneRequiredWithoutTache_assignations_utilisateursNestedInput
  }

  export type tache_assignations_utilisateursUncheckedUpdateWithoutTachesInput = {
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_utilisateursUncheckedUpdateManyWithoutTachesInput = {
    utilisateur_id?: IntFieldUpdateOperationsInput | number
  }

  export type comptesCreateManyUtilisateursInput = {
    id?: number
    username: string
    password: string
    role_id: number
    validity?: $Enums.comptes_validity
  }

  export type projet_utilisateursCreateManyUtilisateursInput = {
    projet_id: number
  }

  export type projetsCreateManyUtilisateursInput = {
    id?: number
    axe_id: number
    priority_id?: number | null
    name: string
    description?: string | null
    objectif?: string | null
    statut?: string | null
    budget?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    created_date?: Date | string
    last_updated?: Date | string
    target_value?: number | null
    current_value?: number | null
  }

  export type tache_assignations_utilisateursCreateManyUtilisateursInput = {
    tache_id: number
  }

  export type tachesCreateManyUtilisateurInput = {
    id?: number
    libelle: string
    description?: string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    projet_id?: number | null
    statut?: string | null
    priorite?: string | null
    dateCreation?: Date | string
    dateMiseAJour?: Date | string
    delaiEstime?: string | null
    delaiReel?: string | null
    commentaires?: string | null
    tacheParentId?: number | null
  }

  export type GroupesUtilisateursCreateManyUtilisateursInput = {
    groupe_id: number
  }

  export type notificationsCreateManyUserInput = {
    id?: number
    titre: string
    message: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    groupeId?: number | null
  }

  export type comptesUpdateWithoutUtilisateursInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    commentaires?: commentairesUpdateManyWithoutComptesNestedInput
    roles?: rolesUpdateOneRequiredWithoutComptesNestedInput
    suggestions?: suggestionsUpdateManyWithoutComptesNestedInput
    votes?: votesUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
    commentaires?: commentairesUncheckedUpdateManyWithoutComptesNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutComptesNestedInput
    votes?: votesUncheckedUpdateManyWithoutComptesNestedInput
  }

  export type comptesUncheckedUpdateManyWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    validity?: Enumcomptes_validityFieldUpdateOperationsInput | $Enums.comptes_validity
  }

  export type projet_utilisateursUpdateWithoutUtilisateursInput = {
    projets?: projetsUpdateOneRequiredWithoutProjet_utilisateursNestedInput
  }

  export type projet_utilisateursUncheckedUpdateWithoutUtilisateursInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
  }

  export type projet_utilisateursUncheckedUpdateManyWithoutUtilisateursInput = {
    projet_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetsUpdateWithoutUtilisateursInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUpdateManyWithoutProjetsNestedInput
    documents?: documentsUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUpdateManyWithoutProjetsNestedInput
    axes?: axesUpdateOneRequiredWithoutProjetsNestedInput
    priority?: priorityUpdateOneWithoutProjetsNestedInput
    ressources?: ressourcesUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUpdateManyWithoutProjetsNestedInput
    taches?: tachesUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: commentairesUncheckedUpdateManyWithoutProjetsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjetsNestedInput
    indicateurs?: indicateursUncheckedUpdateManyWithoutProjetsNestedInput
    projet_groupes?: projet_groupesUncheckedUpdateManyWithoutProjetsNestedInput
    projet_utilisateurs?: projet_utilisateursUncheckedUpdateManyWithoutProjetsNestedInput
    ressources?: ressourcesUncheckedUpdateManyWithoutProjetsNestedInput
    suggestions?: suggestionsUncheckedUpdateManyWithoutProjetsNestedInput
    taches?: tachesUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetsUncheckedUpdateManyWithoutUtilisateursInput = {
    id?: IntFieldUpdateOperationsInput | number
    axe_id?: IntFieldUpdateOperationsInput | number
    priority_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    target_value?: NullableFloatFieldUpdateOperationsInput | number | null
    current_value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type tache_assignations_utilisateursUpdateWithoutUtilisateursInput = {
    taches?: tachesUpdateOneRequiredWithoutTache_assignations_utilisateursNestedInput
  }

  export type tache_assignations_utilisateursUncheckedUpdateWithoutUtilisateursInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
  }

  export type tache_assignations_utilisateursUncheckedUpdateManyWithoutUtilisateursInput = {
    tache_id?: IntFieldUpdateOperationsInput | number
  }

  export type tachesUpdateWithoutUtilisateurInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUpdateManyWithoutTachesNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUpdateManyWithoutTachesNestedInput
    projet?: projetsUpdateOneWithoutTachesNestedInput
  }

  export type tachesUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
    tache_assignations_groupes?: tache_assignations_groupesUncheckedUpdateManyWithoutTachesNestedInput
    tache_assignations_utilisateurs?: tache_assignations_utilisateursUncheckedUpdateManyWithoutTachesNestedInput
  }

  export type tachesUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: NullableStringFieldUpdateOperationsInput | string | null
    priorite?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateMiseAJour?: DateTimeFieldUpdateOperationsInput | Date | string
    delaiEstime?: NullableStringFieldUpdateOperationsInput | string | null
    delaiReel?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    tacheParentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GroupesUtilisateursUpdateWithoutUtilisateursInput = {
    groupes?: groupesUpdateOneRequiredWithoutGroupesUtilisateursNestedInput
  }

  export type GroupesUtilisateursUncheckedUpdateWithoutUtilisateursInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type GroupesUtilisateursUncheckedUpdateManyWithoutUtilisateursInput = {
    groupe_id?: IntFieldUpdateOperationsInput | number
  }

  export type notificationsUpdateWithoutUserInput = {
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupe?: groupesUpdateOneWithoutNotificationNestedInput
  }

  export type notificationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notificationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupeId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ActualitesCountOutputTypeDefaultArgs instead
     */
    export type ActualitesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActualitesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AxesCountOutputTypeDefaultArgs instead
     */
    export type AxesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AxesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Category_userCountOutputTypeDefaultArgs instead
     */
    export type Category_userCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Category_userCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComptesCountOutputTypeDefaultArgs instead
     */
    export type ComptesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComptesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupesCountOutputTypeDefaultArgs instead
     */
    export type GroupesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicateursCountOutputTypeDefaultArgs instead
     */
    export type IndicateursCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicateursCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionsCountOutputTypeDefaultArgs instead
     */
    export type PermissionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Plans_actionCountOutputTypeDefaultArgs instead
     */
    export type Plans_actionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Plans_actionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriorityCountOutputTypeDefaultArgs instead
     */
    export type PriorityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriorityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjetsCountOutputTypeDefaultArgs instead
     */
    export type ProjetsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjetsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TachesCountOutputTypeDefaultArgs instead
     */
    export type TachesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TachesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UtilisateursCountOutputTypeDefaultArgs instead
     */
    export type UtilisateursCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UtilisateursCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use actualite_imagesDefaultArgs instead
     */
    export type actualite_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = actualite_imagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use actualitesDefaultArgs instead
     */
    export type actualitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = actualitesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use axesDefaultArgs instead
     */
    export type axesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = axesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use category_userDefaultArgs instead
     */
    export type category_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = category_userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use commentairesDefaultArgs instead
     */
    export type commentairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = commentairesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comptesDefaultArgs instead
     */
    export type comptesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comptesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use documentsDefaultArgs instead
     */
    export type documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = documentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use evaluationsDefaultArgs instead
     */
    export type evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = evaluationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groupesDefaultArgs instead
     */
    export type groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groupesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use indicateursDefaultArgs instead
     */
    export type indicateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = indicateursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupesUtilisateursDefaultArgs instead
     */
    export type GroupesUtilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupesUtilisateursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use newsletterDefaultArgs instead
     */
    export type newsletterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = newsletterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permissionsDefaultArgs instead
     */
    export type permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use plans_actionDefaultArgs instead
     */
    export type plans_actionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = plans_actionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use priorityDefaultArgs instead
     */
    export type priorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = priorityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projet_groupesDefaultArgs instead
     */
    export type projet_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projet_groupesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projet_utilisateursDefaultArgs instead
     */
    export type projet_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projet_utilisateursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projetsDefaultArgs instead
     */
    export type projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projetsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ressourcesDefaultArgs instead
     */
    export type ressourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ressourcesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use role_permissionsDefaultArgs instead
     */
    export type role_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = role_permissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use suggestionsDefaultArgs instead
     */
    export type suggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = suggestionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tache_assignations_groupesDefaultArgs instead
     */
    export type tache_assignations_groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tache_assignations_groupesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tache_assignations_utilisateursDefaultArgs instead
     */
    export type tache_assignations_utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tache_assignations_utilisateursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tachesDefaultArgs instead
     */
    export type tachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tachesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use utilisateursDefaultArgs instead
     */
    export type utilisateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = utilisateursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use votesDefaultArgs instead
     */
    export type votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = votesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationsDefaultArgs instead
     */
    export type notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}